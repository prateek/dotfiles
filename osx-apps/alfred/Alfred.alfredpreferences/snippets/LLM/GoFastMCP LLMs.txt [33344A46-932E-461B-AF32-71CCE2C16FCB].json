{
  "alfredsnippet" : {
    "snippet" : "# Advanced Features\nSource: https:\/\/gofastmcp.com\/clients\/advanced-features\n\nLearn about the advanced features of the FastMCP Client.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nIn addition to basic server interaction, FastMCP clients can also handle more advanced features and server interaction patterns. The `Client` constructor accepts additional configuration to handle these server requests.\n\n<Tip>\n  To enable many of these features, you must provide an appropriate handler or callback function. For example. In most cases, if you do not provide a handler, FastMCP's default handler will emit a `DEBUG` level log.\n<\/Tip>\n\n## Logging and Notifications\n\n<VersionBadge version=\"2.0.0\" \/>\n\nMCP servers can emit logs to clients. To process these logs, you can provide a `log_handler` to the client.\n\nThe `log_handler` must be an async function that accepts a single argument, which is an instance of `fastmcp.client.logging.LogMessage`. This has attributes like `level`, `logger`, and `data`.\n\n```python {2, 12}\nfrom fastmcp import Client\nfrom fastmcp.client.logging import LogMessage\n\nasync def log_handler(message: LogMessage):\n    level = message.level.upper()\n    logger = message.logger or 'default'\n    data = message.data\n    print(f\"[Server Log - {level}] {logger}: {data}\")\n\nclient_with_logging = Client(\n    ...,\n    log_handler=log_handler,\n)\n```\n\n## Progress Monitoring\n\n<VersionBadge version=\"2.3.5\" \/>\n\nMCP servers can report progress during long-running operations. The client can set a progress handler to receive and process these updates.\n\n```python {2, 13}\nfrom fastmcp import Client\nfrom fastmcp.client.progress import ProgressHandler\n\nasync def my_progress_handler(\n    progress: float, \n    total: float | None, \n    message: str | None\n) -> None:\n    print(f\"Progress: {progress} \/ {total} ({message})\")\n\nclient = Client(\n    ...,\n    progress_handler=my_progress_handler\n)\n```\n\nBy default, FastMCP uses a handler that logs progress updates at the debug level. This default handler properly handles cases where `total` or `message` might be None.\n\nYou can override the progress handler for specific tool calls:\n\n```python\n# Client uses the default debug logger for progress\nclient = Client(...)\n\nasync with client:\n    # Use default progress handler (debug logging)\n    result1 = await client.call_tool(\"long_task\", {\"param\": \"value\"})\n    \n    # Override with custom progress handler just for this call\n    result2 = await client.call_tool(\n        \"another_task\", \n        {\"param\": \"value\"}, \n        progress_handler=my_progress_handler\n    )\n```\n\nA typical progress update includes:\n\n* Current progress value (e.g., 2 of 5 steps completed)\n* Total expected value (may be None)\n* Status message (may be None)\n\n## LLM Sampling\n\n<VersionBadge version=\"2.0.0\" \/>\n\nMCP Servers can request LLM completions from clients. The client can provide a `sampling_handler` to handle these requests. The sampling handler receives a list of messages and other parameters from the server, and should return a string completion.\n\nThe following example uses the `marvin` library to generate a completion:\n\n```python {8-17, 21}\nimport marvin\nfrom fastmcp import Client\nfrom fastmcp.client.sampling import (\n    SamplingMessage,\n    SamplingParams,\n    RequestContext,\n)\n\nasync def sampling_handler(\n    messages: list[SamplingMessage],\n    params: SamplingParams,\n    context: RequestContext\n) -> str:\n    return await marvin.say_async(\n        message=[m.content.text for m in messages],\n        instructions=params.systemPrompt,\n    )\n\nclient = Client(\n    ...,\n    sampling_handler=sampling_handler,\n)\n```\n\n## Roots\n\n<VersionBadge version=\"2.0.0\" \/>\n\nRoots are a way for clients to inform servers about the resources they have access to or certain boundaries on their access. The server can use this information to adjust behavior or provide more accurate responses.\n\nServers can request roots from clients, and clients can notify servers when their roots change.\n\nTo set the roots when creating a client, users can either provide a list of roots (which can be a list of strings) or an async function that returns a list of roots.\n\n<CodeGroup>\n  ```python Static Roots {5}\n  from fastmcp import Client\n\n  client = Client(\n      ..., \n      roots=[\"\/path\/to\/root1\", \"\/path\/to\/root2\"],\n  )\n  ```\n\n  ```python Dynamic Roots Callback {4-6, 10}\n  from fastmcp import Client\n  from fastmcp.client.roots import RequestContext\n\n  async def roots_callback(context: RequestContext) -> list[str]:\n      print(f\"Server requested roots (Request ID: {context.request_id})\")\n      return [\"\/path\/to\/root1\", \"\/path\/to\/root2\"]\n\n  client = Client(\n      ..., \n      roots=roots_callback,\n  )\n  ```\n<\/CodeGroup>\n\n\n# Client Overview\nSource: https:\/\/gofastmcp.com\/clients\/client\n\nLearn how to use the FastMCP Client to interact with MCP servers.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.0.0\" \/>\n\nThe `fastmcp.Client` provides a high-level, asynchronous interface for interacting with any Model Context Protocol (MCP) server, whether it's built with FastMCP or another implementation. It simplifies communication by handling protocol details and connection management.\n\n## FastMCP Client\n\nThe FastMCP Client architecture separates the protocol logic (`Client`) from the connection mechanism (`Transport`).\n\n* **`Client`**: Handles sending MCP requests (like `tools\/call`, `resources\/read`), receiving responses, and managing callbacks.\n* **`Transport`**: Responsible for establishing and maintaining the connection to the server (e.g., via WebSockets, SSE, Stdio, or in-memory).\n\n```python\nfrom fastmcp import Client, FastMCP\nfrom fastmcp.client import (\n    RootsHandler,\n    RootsList,\n    LogHandler,\n    MessageHandler,\n    SamplingHandler,\n    ProgressHandler  # For handling progress notifications\n)\n```\n\n### Transports\n\nClients must be initialized with a `transport`. You can either provide an already instantiated transport object, or provide a transport source and let FastMCP attempt to infer the correct transport to use.\n\nThe following inference rules are used to determine the appropriate `ClientTransport` based on the input type:\n\n1. **`ClientTransport` Instance**: If you provide an already instantiated transport object, it's used directly.\n2. **`FastMCP` Instance**: Creates a `FastMCPTransport` for efficient in-memory communication (ideal for testing). This also works with a **FastMCP 1.0 server** created via `mcp.server.fastmcp.FastMCP`.\n3. **`Path` or `str` pointing to an existing file**:\n   * If it ends with `.py`: Creates a `PythonStdioTransport` to run the script using `python`.\n   * If it ends with `.js`: Creates a `NodeStdioTransport` to run the script using `node`.\n4. **`AnyUrl` or `str` pointing to a URL that begins with `http:\/\/` or `https:\/\/`**:\n   * Creates a `StreamableHttpTransport`\n5. **`MCPConfig` or dictionary matching MCPConfig schema**: Creates a client that connects to one or more MCP servers specified in the config.\n6. **Other**: Raises a `ValueError` if the type cannot be inferred.\n\n```python\nimport asyncio\nfrom fastmcp import Client, FastMCP\n\n# Example transports (more details in Transports page)\nserver_instance = FastMCP(name=\"TestServer\") # In-memory server\nhttp_url = \"https:\/\/example.com\/mcp\"        # HTTP server URL\nserver_script = \"my_mcp_server.py\"         # Path to a Python server file\n\n# Client automatically infers the transport type\nclient_in_memory = Client(server_instance)\nclient_http = Client(http_url)\n\nclient_stdio = Client(server_script)\n\nprint(client_in_memory.transport)\nprint(client_http.transport)\nprint(client_stdio.transport)\n\n# Expected Output (types may vary slightly based on environment):\n# <FastMCP(server='TestServer')>\n# <StreamableHttp(url='https:\/\/example.com\/mcp')>\n# <PythonStdioTransport(command='python', args=['\/path\/to\/your\/my_mcp_server.py'])>\n```\n\nYou can also initialize a client from an MCP configuration dictionary or `MCPConfig` file:\n\n```python\nfrom fastmcp import Client\n\nconfig = {\n    \"mcpServers\": {\n        \"local\": {\"command\": \"python\", \"args\": [\"local_server.py\"]},\n        \"remote\": {\"url\": \"https:\/\/example.com\/mcp\"},\n    }\n}\n\nclient_config = Client(config)\n```\n\n<Tip>\n  For more control over connection details (like headers for SSE, environment variables for Stdio), you can instantiate the specific `ClientTransport` class yourself and pass it to the `Client`. See the [Transports](\/clients\/transports) page for details.\n<\/Tip>\n\n### Multi-Server Clients\n\n<VersionBadge version=\"2.4.0\" \/>\n\nFastMCP supports creating clients that connect to multiple MCP servers through a single client interface using a standard MCP configuration format (`MCPConfig`). This configuration approach makes it easy to connect to multiple specialized servers or create composable systems with a simple, declarative syntax.\n\n<Note>\n  The MCP configuration format follows an emerging standard and may evolve as the specification matures. FastMCP will strive to maintain compatibility with future versions, but be aware that field names or structure might change.\n<\/Note>\n\nWhen you create a client with an `MCPConfig` containing multiple servers:\n\n1. FastMCP creates a composite client that internally mounts all servers using their config names as prefixes\n2. Tools and resources from each server are accessible with appropriate prefixes in the format `servername_toolname` and `protocol:\/\/servername\/resource\/path`\n3. You interact with this as a single unified client, with requests automatically routed to the appropriate server\n\n```python\nfrom fastmcp import Client\n\n# Create a standard MCP configuration with multiple servers\nconfig = {\n    \"mcpServers\": {\n        # A remote HTTP server\n        \"weather\": {\n            \"url\": \"https:\/\/weather-api.example.com\/mcp\",\n            \"transport\": \"streamable-http\"\n        },\n        # A local server running via stdio\n        \"assistant\": {\n            \"command\": \"python\",\n            \"args\": [\".\/my_assistant_server.py\"],\n            \"env\": {\"DEBUG\": \"true\"}\n        }\n    }\n}\n\n# Create a client that connects to both servers\nclient = Client(config)\n\nasync def main():\n    async with client:\n        # Access tools from different servers with prefixes\n        weather_data = await client.call_tool(\"weather_get_forecast\", {\"city\": \"London\"})\n        response = await client.call_tool(\"assistant_answer_question\", {\"question\": \"What's the capital of France?\"})\n        \n        # Access resources with prefixed URIs\n        weather_icons = await client.read_resource(\"weather:\/\/weather\/icons\/sunny\")\n        templates = await client.read_resource(\"resource:\/\/assistant\/templates\/list\")\n        \n        print(f\"Weather: {weather_data}\")\n        print(f\"Assistant: {response}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nIf your configuration has only a single server, FastMCP will create a direct client to that server without any prefixing.\n\n## Client Usage\n\n### Connection Lifecycle\n\nThe client operates asynchronously and must be used within an `async with` block. This context manager handles establishing the connection, initializing the MCP session, and cleaning up resources upon exit.\n\n```python\nimport asyncio\nfrom fastmcp import Client\n\nclient = Client(\"my_mcp_server.py\") # Assumes my_mcp_server.py exists\n\nasync def main():\n    # Connection is established here\n    async with client:\n        print(f\"Client connected: {client.is_connected()}\")\n\n        # Make MCP calls within the context\n        tools = await client.list_tools()\n        print(f\"Available tools: {tools}\")\n\n        if any(tool.name == \"greet\" for tool in tools):\n            result = await client.call_tool(\"greet\", {\"name\": \"World\"})\n            print(f\"Greet result: {result}\")\n\n    # Connection is closed automatically here\n    print(f\"Client connected: {client.is_connected()}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nYou can make multiple calls to the server within the same `async with` block using the established session.\n\n### Client Methods\n\nThe `Client` provides methods corresponding to standard MCP requests:\n\n<Warning>\n  The standard client methods return user-friendly representations that may change as the protocol evolves. For consistent access to the complete data structure, use the `*_mcp` methods described later.\n<\/Warning>\n\n#### Tool Operations\n\n* **`list_tools()`**: Retrieves a list of tools available on the server.\n  ```python\n  tools = await client.list_tools()\n  # tools -> list[mcp.types.Tool]\n  ```\n* **`call_tool(name: str, arguments: dict[str, Any] | None = None, timeout: float | None = None, progress_handler: ProgressHandler | None = None)`**: Executes a tool on the server.\n  ```python\n  result = await client.call_tool(\"add\", {\"a\": 5, \"b\": 3})\n  # result -> list[mcp.types.TextContent | mcp.types.ImageContent | ...]\n  print(result[0].text) # Assuming TextContent, e.g., '8'\n\n  # With timeout (aborts if execution takes longer than 2 seconds)\n  result = await client.call_tool(\"long_running_task\", {\"param\": \"value\"}, timeout=2.0)\n\n  # With progress handler (to track execution progress)\n  result = await client.call_tool(\n      \"long_running_task\",\n      {\"param\": \"value\"},\n      progress_handler=my_progress_handler\n  )\n  ```\n  * Arguments are passed as a dictionary. FastMCP servers automatically handle JSON string parsing for complex types if needed.\n  * Returns a list of content objects (usually `TextContent` or `ImageContent`).\n  * The optional `timeout` parameter limits the maximum execution time (in seconds) for this specific call, overriding any client-level timeout.\n  * The optional `progress_handler` parameter receives progress updates during execution, overriding any client-level progress handler.\n\n#### Resource Operations\n\n* **`list_resources()`**: Retrieves a list of static resources.\n  ```python\n  resources = await client.list_resources()\n  # resources -> list[mcp.types.Resource]\n  ```\n* **`list_resource_templates()`**: Retrieves a list of resource templates.\n  ```python\n  templates = await client.list_resource_templates()\n  # templates -> list[mcp.types.ResourceTemplate]\n  ```\n* **`read_resource(uri: str | AnyUrl)`**: Reads the content of a resource or a resolved template.\n  ```python\n  # Read a static resource\n  readme_content = await client.read_resource(\"file:\/\/\/path\/to\/README.md\")\n  # readme_content -> list[mcp.types.TextResourceContents | mcp.types.BlobResourceContents]\n  print(readme_content[0].text) # Assuming text\n\n  # Read a resource generated from a template\n  weather_content = await client.read_resource(\"data:\/\/weather\/london\")\n  print(weather_content[0].text) # Assuming text JSON\n  ```\n\n#### Prompt Operations\n\n* **`list_prompts()`**: Retrieves available prompt templates.\n* **`get_prompt(name: str, arguments: dict[str, Any] | None = None)`**: Retrieves a rendered prompt message list.\n\n### Raw MCP Protocol Objects\n\n<VersionBadge version=\"2.2.7\" \/>\n\nThe FastMCP client attempts to provide a \"friendly\" interface to the MCP protocol, but sometimes you may need access to the raw MCP protocol objects. Each of the main client methods that returns data has a corresponding `*_mcp` method that returns the raw MCP protocol objects directly.\n\n<Warning>\n  The standard client methods (without `_mcp`) return user-friendly representations of MCP data, while `*_mcp` methods will always return the complete MCP protocol objects. As the protocol evolves, changes to these user-friendly representations may occur and could potentially be breaking. If you need consistent, stable access to the full data structure, prefer using the `*_mcp` methods.\n<\/Warning>\n\n```python\n# Standard method - returns just the list of tools\ntools = await client.list_tools()\n# tools -> list[mcp.types.Tool]\n\n# Raw MCP method - returns the full protocol object\nresult = await client.list_tools_mcp()\n# result -> mcp.types.ListToolsResult\ntools = result.tools\n```\n\nAvailable raw MCP methods:\n\n* **`list_tools_mcp()`**: Returns `mcp.types.ListToolsResult`\n* **`call_tool_mcp(name, arguments)`**: Returns `mcp.types.CallToolResult`\n* **`list_resources_mcp()`**: Returns `mcp.types.ListResourcesResult`\n* **`list_resource_templates_mcp()`**: Returns `mcp.types.ListResourceTemplatesResult`\n* **`read_resource_mcp(uri)`**: Returns `mcp.types.ReadResourceResult`\n* **`list_prompts_mcp()`**: Returns `mcp.types.ListPromptsResult`\n* **`get_prompt_mcp(name, arguments)`**: Returns `mcp.types.GetPromptResult`\n* **`complete_mcp(ref, argument)`**: Returns `mcp.types.CompleteResult`\n\nThese methods are especially useful for debugging or when you need to access metadata or fields that aren't exposed by the simplified methods.\n\n### Additional Features\n\n#### Pinging the server\n\nThe client can be used to ping the server to verify connectivity.\n\n```python\nasync with client:\n    await client.ping()\n    print(\"Server is reachable\")\n```\n\n#### Timeouts\n\n<VersionBadge version=\"2.3.4\" \/>\n\nYou can control request timeouts at both the client level and individual request level:\n\n```python\nfrom fastmcp import Client\nfrom fastmcp.exceptions import McpError\n\n# Client with a global 5-second timeout for all requests\nclient = Client(\n    my_mcp_server,\n    timeout=5.0  # Default timeout in seconds\n)\n\nasync with client:\n    # This uses the global 5-second timeout\n    result1 = await client.call_tool(\"quick_task\", {\"param\": \"value\"})\n    \n    # This specifies a 10-second timeout for this specific call\n    result2 = await client.call_tool(\"slow_task\", {\"param\": \"value\"}, timeout=10.0)\n    \n    try:\n        # This will likely timeout\n        result3 = await client.call_tool(\"medium_task\", {\"param\": \"value\"}, timeout=0.01)\n    except McpError as e:\n        # Handle timeout error\n        print(f\"The task timed out: {e}\")\n```\n\n<Warning>\n  Timeout behavior varies between transport types:\n\n  * With **SSE** transport, the per-request (tool call) timeout **always** takes precedence, regardless of which is lower.\n  * With **HTTP** transport, the **lower** of the two timeouts (client or tool call) takes precedence.\n\n  For consistent behavior across all transports, we recommend explicitly setting timeouts at the individual tool call level when needed, rather than relying on client-level timeouts.\n<\/Warning>\n\n#### Error Handling\n\nWhen a `call_tool` request results in an error on the server (e.g., the tool function raised an exception), the `client.call_tool()` method will raise a `fastmcp.client.ClientError`.\n\n```python\nasync def safe_call_tool():\n    async with client:\n        try:\n            # Assume 'divide' tool exists and might raise ZeroDivisionError\n            result = await client.call_tool(\"divide\", {\"a\": 10, \"b\": 0})\n            print(f\"Result: {result}\")\n        except ClientError as e:\n            print(f\"Tool call failed: {e}\")\n        except ConnectionError as e:\n            print(f\"Connection failed: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n# Example Output if division by zero occurs:\n# Tool call failed: Division by zero is not allowed.\n```\n\nOther errors, like connection failures, will raise standard Python exceptions (e.g., `ConnectionError`, `TimeoutError`).\n\n<Tip>\n  The client transport often has its own error-handling mechanisms, so you can not always trap errors like those raised by `call_tool` outside of the `async with` block. Instead, you can use `call_tool_mcp()` to get the raw `mcp.types.CallToolResult` object and handle errors yourself by checking its `isError` attribute.\n<\/Tip>\n\n\n# Client Transports\nSource: https:\/\/gofastmcp.com\/clients\/transports\n\nUnderstand the different ways FastMCP Clients can connect to servers.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.0.0\" \/>\n\nThe FastMCP `Client` relies on a `ClientTransport` object to handle the specifics of connecting to and communicating with an MCP server. FastMCP provides several built-in transport implementations for common connection methods.\n\nWhile the `Client` often infers the correct transport automatically (see [Client Overview](\/clients\/client#transport-inference)), you can also instantiate transports explicitly for more control.\n\n<Tip>\n  Clients are lightweight objects, so don't hesitate to create new ones as needed. However, be mindful of the context management - each time you open a client context (`async with client:`), a new connection or process starts. For best performance, keep client contexts open while performing multiple operations rather than repeatedly opening and closing them.\n<\/Tip>\n\n## Choosing a Transport\n\nChoose the transport that best fits your use case:\n\n* **Connecting to Remote\/Persistent Servers:** Use `StreamableHttpTransport` (recommended, default for HTTP URLs) or `SSETransport` (legacy option) for web-based deployments.\n\n* **Local Development\/Testing:** Use `FastMCPTransport` for in-memory, same-process testing of your FastMCP servers.\n\n* **Running Local Servers:** Use `UvxStdioTransport` (Python\/uv) or `NpxStdioTransport` (Node\/npm) if you need to run MCP servers as packaged tools.\n\n## Network Transports\n\nThese transports connect to servers running over a network, typically long-running services accessible via URLs.\n\n### Streamable HTTP\n\n<VersionBadge version=\"2.3.0\" \/>\n\nStreamable HTTP is the recommended transport for web-based deployments, providing efficient bidirectional communication over HTTP.\n\n#### Overview\n\n* **Class:** `fastmcp.client.transports.StreamableHttpTransport`\n* **Inferred From:** URLs starting with `http:\/\/` or `https:\/\/` (default for HTTP URLs since v2.3.0) that do not contain `\/sse\/` in the path\n* **Server Compatibility:** Works with FastMCP servers running in `streamable-http` mode\n\n#### Basic Usage\n\nThe simplest way to use Streamable HTTP is to let the transport be inferred from a URL:\n\n```python\nfrom fastmcp import Client\nimport asyncio\n\n# The Client automatically uses StreamableHttpTransport for HTTP URLs\nclient = Client(\"https:\/\/example.com\/mcp\")\n\nasync def main():\n    async with client:\n        tools = await client.list_tools()\n        print(f\"Available tools: {tools}\")\n\nasyncio.run(main())\n```\n\nYou can also explicitly instantiate the transport:\n\n```python\nfrom fastmcp.client.transports import StreamableHttpTransport\n\ntransport = StreamableHttpTransport(url=\"https:\/\/example.com\/mcp\")\nclient = Client(transport)\n```\n\n#### Authentication with Headers\n\nFor servers requiring authentication:\n\n```python\nfrom fastmcp import Client\nfrom fastmcp.client.transports import StreamableHttpTransport\n\n# Create transport with authentication headers\ntransport = StreamableHttpTransport(\n    url=\"https:\/\/example.com\/mcp\",\n    headers={\"Authorization\": \"Bearer your-token-here\"}\n)\n\nclient = Client(transport)\n```\n\n### SSE (Server-Sent Events)\n\n<VersionBadge version=\"2.0.0\" \/>\n\nServer-Sent Events (SSE) is a transport that allows servers to push data to clients over HTTP connections. While still supported, Streamable HTTP is now the recommended transport for new web-based deployments.\n\n#### Overview\n\n* **Class:** `fastmcp.client.transports.SSETransport`\n* **Inferred From:** HTTP URLs containing `\/sse\/` in the path\n* **Server Compatibility:** Works with FastMCP servers running in `sse` mode\n\n#### Basic Usage\n\nThe simplest way to use SSE is to let the transport be inferred from a URL with `\/sse\/` in the path:\n\n```python\nfrom fastmcp import Client\nimport asyncio\n\n# The Client automatically uses SSETransport for URLs containing \/sse\/ in the path\nclient = Client(\"https:\/\/example.com\/sse\")\n\nasync def main():\n    async with client:\n        tools = await client.list_tools()\n        print(f\"Available tools: {tools}\")\n\nasyncio.run(main())\n```\n\nYou can also explicitly instantiate the transport for URLs that do not contain `\/sse\/` in the path or for more control:\n\n```python\nfrom fastmcp.client.transports import SSETransport\n\ntransport = SSETransport(url=\"https:\/\/example.com\/sse\")\nclient = Client(transport)\n```\n\n#### Authentication with Headers\n\nSSE transport also supports custom headers for authentication:\n\n```python\nfrom fastmcp import Client\nfrom fastmcp.client.transports import SSETransport\n\n# Create SSE transport with authentication headers\ntransport = SSETransport(\n    url=\"https:\/\/example.com\/sse\",\n    headers={\"Authorization\": \"Bearer your-token-here\"}\n)\n\nclient = Client(transport)\n```\n\n#### When to Use SSE vs. Streamable HTTP\n\n* **Use Streamable HTTP when:**\n  * Setting up new deployments (recommended default)\n  * You need bidirectional streaming\n  * You're connecting to FastMCP servers running in `streamable-http` mode\n\n* **Use SSE when:**\n  * Connecting to legacy FastMCP servers running in `sse` mode\n  * Working with infrastructure optimized for Server-Sent Events\n\n## Local Transports\n\nThese transports manage an MCP server running as a subprocess, communicating with it via standard input (stdin) and standard output (stdout). This is the standard mechanism used by clients like Claude Desktop.\n\n### Python Stdio\n\n* **Class:** `fastmcp.client.transports.PythonStdioTransport`\n* **Inferred From:** Paths to `.py` files\n* **Use Case:** Running a Python-based MCP server script in a subprocess\n\nThis is the most common way to interact with local FastMCP servers during development or when integrating with tools that expect to launch a server script.\n\n```python\nfrom fastmcp import Client\nfrom fastmcp.client.transports import PythonStdioTransport\n\nserver_script = \"my_mcp_server.py\" # Path to your server script\n\n# Option 1: Inferred transport\nclient = Client(server_script)\n\n# Option 2: Explicit transport with custom configuration\ntransport = PythonStdioTransport(\n    script_path=server_script,\n    python_cmd=\"\/usr\/bin\/python3.11\", # Optional: specify Python interpreter\n    # args=[\"--some-server-arg\"],      # Optional: pass arguments to the script\n    # env={\"MY_VAR\": \"value\"},         # Optional: set environment variables\n)\nclient = Client(transport)\n\nasync def main():\n    async with client:\n        tools = await client.list_tools()\n        print(f\"Connected via Python Stdio, found tools: {tools}\")\n\nasyncio.run(main())\n```\n\n<Warning>\n  The server script must include logic to start the MCP server and listen on stdio, typically via `mcp.run()` or `fastmcp.server.run()`. The Client only launches the script; it doesn't inject the server logic.\n<\/Warning>\n\n### Node.js Stdio\n\n* **Class:** `fastmcp.client.transports.NodeStdioTransport`\n* **Inferred From:** Paths to `.js` files\n* **Use Case:** Running a Node.js-based MCP server script in a subprocess\n\nSimilar to the Python transport, but for JavaScript servers.\n\n```python\nfrom fastmcp import Client\nfrom fastmcp.client.transports import NodeStdioTransport\n\nnode_server_script = \"my_mcp_server.js\" # Path to your Node.js server script\n\n# Option 1: Inferred transport\nclient = Client(node_server_script)\n\n# Option 2: Explicit transport\ntransport = NodeStdioTransport(\n    script_path=node_server_script,\n    node_cmd=\"node\" # Optional: specify path to Node executable\n)\nclient = Client(transport)\n\nasync def main():\n    async with client:\n        tools = await client.list_tools()\n        print(f\"Connected via Node.js Stdio, found tools: {tools}\")\n\nasyncio.run(main())\n```\n\n### UVX Stdio (Experimental)\n\n* **Class:** `fastmcp.client.transports.UvxStdioTransport`\n* **Inferred From:** Not automatically inferred\n* **Use Case:** Running an MCP server packaged as a Python tool using [`uvx`](https:\/\/docs.astral.sh\/uv\/reference\/cli\/#uvx)\n\nThis is useful for executing MCP servers distributed as command-line tools or packages without installing them into your environment.\n\n```python\nfrom fastmcp import Client\nfrom fastmcp.client.transports import UvxStdioTransport\n\n# Run a hypothetical 'cloud-analyzer-mcp' tool via uvx\ntransport = UvxStdioTransport(\n    tool_name=\"cloud-analyzer-mcp\",\n    # from_package=\"cloud-analyzer-cli\", # Optional: specify package if tool name differs\n    # with_packages=[\"boto3\", \"requests\"] # Optional: add dependencies\n)\nclient = Client(transport)\n\nasync def main():\n    async with client:\n        result = await client.call_tool(\"analyze_bucket\", {\"name\": \"my-data\"})\n        print(f\"Analysis result: {result}\")\n\nasyncio.run(main())\n```\n\n### NPX Stdio (Experimental)\n\n* **Class:** `fastmcp.client.transports.NpxStdioTransport`\n* **Inferred From:** Not automatically inferred\n* **Use Case:** Running an MCP server packaged as an NPM package using `npx`\n\nSimilar to `UvxStdioTransport`, but for the Node.js ecosystem.\n\n```python\nfrom fastmcp import Client\nfrom fastmcp.client.transports import NpxStdioTransport\n\n# Run an MCP server from an NPM package\ntransport = NpxStdioTransport(\n    package=\"mcp-server-package\",\n    # args=[\"--port\", \"stdio\"] # Optional: pass arguments to the package\n)\nclient = Client(transport)\n\nasync def main():\n    async with client:\n        result = await client.call_tool(\"get_npm_data\", {})\n        print(f\"Result: {result}\")\n\nasyncio.run(main())\n```\n\n## In-Memory Transports\n\n### FastMCP Transport\n\n* **Class:** `fastmcp.client.transports.FastMCPTransport`\n* **Inferred From:** An instance of `fastmcp.server.FastMCP` or a **FastMCP 1.0 server** (`mcp.server.fastmcp.FastMCP`)\n* **Use Case:** Connecting directly to a FastMCP server instance in the same Python process\n\nThis is extremely useful for testing your FastMCP servers.\n\n```python\nfrom fastmcp import FastMCP, Client\nimport asyncio\n\n# 1. Create your FastMCP server instance\nserver = FastMCP(name=\"InMemoryServer\")\n\n@server.tool()\ndef ping(): \n    return \"pong\"\n\n# 2. Create a client pointing directly to the server instance\nclient = Client(server)  # Transport is automatically inferred\n\nasync def main():\n    async with client:\n        result = await client.call_tool(\"ping\")\n        print(f\"In-memory call result: {result}\")\n\nasyncio.run(main())\n```\n\nCommunication happens through efficient in-memory queues, making it very fast and ideal for unit testing.\n\n## Configuration-Based Transports\n\n### MCPConfig Transport\n\n<VersionBadge version=\"2.4.0\" \/>\n\n* **Class:** `fastmcp.client.transports.MCPConfigTransport`\n* **Inferred From:** An instance of `MCPConfig` or a dictionary matching the MCPConfig schema\n* **Use Case:** Connecting to one or more MCP servers defined in a configuration object\n\nMCPConfig follows an emerging standard for MCP server configuration but is subject to change as the specification evolves. The standard supports both local servers (running via stdio) and remote servers (accessed via HTTP).\n\n```python\nfrom fastmcp import Client\n\n# Configuration for multiple MCP servers (both local and remote)\nconfig = {\n    \"mcpServers\": {\n        # Remote HTTP server\n        \"weather\": {\n            \"url\": \"https:\/\/weather-api.example.com\/mcp\",\n            \"transport\": \"streamable-http\"\n        },\n        # Local stdio server\n        \"assistant\": {\n            \"command\": \"python\",\n            \"args\": [\".\/assistant_server.py\"],\n            \"env\": {\"DEBUG\": \"true\"}\n        },\n        # Another remote server\n        \"calendar\": {\n            \"url\": \"https:\/\/calendar-api.example.com\/mcp\",\n            \"transport\": \"streamable-http\"\n        }\n    }\n}\n\n# Create a transport from the config (happens automatically with Client)\nclient = Client(config)\n\nasync def main():\n    async with client:\n        # Tools are accessible with server name prefixes\n        weather = await client.call_tool(\"weather_get_forecast\", {\"city\": \"London\"})\n        answer = await client.call_tool(\"assistant_answer_question\", {\"query\": \"What is MCP?\"})\n        events = await client.call_tool(\"calendar_list_events\", {\"date\": \"2023-06-01\"})\n        \n        # Resources use prefixed URI paths\n        icons = await client.read_resource(\"weather:\/\/weather\/icons\/sunny\")\n        docs = await client.read_resource(\"resource:\/\/assistant\/docs\/mcp\")\n\nasyncio.run(main())\n```\n\nIf your configuration has only a single server, the client will connect directly to that server without any prefixing. This makes it convenient to switch between single and multi-server configurations without changing your client code.\n\n<Note>\n  The MCPConfig format is an emerging standard for MCP server configuration and may change as the MCP ecosystem evolves. While FastMCP aims to maintain compatibility with future versions, be aware that field names or structure might change.\n<\/Note>\n\n\n# Integrating FastMCP in ASGI Applications\nSource: https:\/\/gofastmcp.com\/deployment\/asgi\n\nIntegrate FastMCP servers into existing Starlette, FastAPI, or other ASGI applications\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nWhile FastMCP provides standalone server capabilities, you can also integrate your FastMCP server into existing web applications. This approach is useful for:\n\n* Adding MCP functionality to an existing website or API\n* Mounting MCP servers under specific URL paths\n* Combining multiple services in a single application\n* Leveraging existing authentication and middleware\n\nPlease note that all FastMCP servers have a `run()` method that can be used to start the server. This guide focuses on integration with broader ASGI frameworks.\n\n## ASGI Server\n\nFastMCP servers can be created as [Starlette](https:\/\/www.starlette.io\/) ASGI apps for straightforward hosting or integration into existing applications.\n\nThe first step is to obtain a Starlette application instance from your FastMCP server using the `http_app()` method:\n\n<Tip>\n  The `http_app()` method is new in FastMCP 2.3.2. In older versions, use `sse_app()` for SSE transport or `streamable_http_app()` for Streamable HTTP transport.\n<\/Tip>\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.tool()\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\n# Get a Starlette app instance for Streamable HTTP transport (recommended)\nhttp_app = mcp.http_app()\n\n# For legacy SSE transport (deprecated)\nsse_app = mcp.http_app(transport=\"sse\")\n```\n\nBoth approaches return a Starlette application that can be integrated with other ASGI-compatible web frameworks.\n\nThe returned app stores the `FastMCP` instance on `app.state.fastmcp_server`, so you\ncan access it from custom middleware or routes via `request.app.state.fastmcp_server`.\n\nThe MCP server's endpoint is mounted at the root path `\/mcp` for Streamable HTTP transport, and `\/sse` for SSE transport, though you can change these paths by passing a `path` argument to the `http_app()` method:\n\n```python\n# For Streamable HTTP transport\nhttp_app = mcp.http_app(path=\"\/custom-mcp-path\")\n\n# For SSE transport (deprecated)\nsse_app = mcp.http_app(path=\"\/custom-sse-path\", transport=\"sse\")\n```\n\n### Running the Server\n\nTo run the FastMCP server, you can use the `uvicorn` ASGI server:\n\n```python\nfrom fastmcp import FastMCP\nimport uvicorn\n\nmcp = FastMCP(\"MyServer\")\n\nhttp_app = mcp.http_app()\n\nif __name__ == \"__main__\":\n    uvicorn.run(http_app, host=\"0.0.0.0\", port=8000)\n```\n\nOr, from the command line:\n\n```bash\nuvicorn path.to.your.app:http_app --host 0.0.0.0 --port 8000\n```\n\n### Custom Middleware\n\n<VersionBadge version=\"2.3.2\" \/>\n\nYou can add custom Starlette middleware to your FastMCP ASGI apps by passing a list of middleware instances to the app creation methods:\n\n```python\nfrom fastmcp import FastMCP\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.cors import CORSMiddleware\n\n# Create your FastMCP server\nmcp = FastMCP(\"MyServer\")\n\n# Define custom middleware\ncustom_middleware = [\n    Middleware(CORSMiddleware, allow_origins=[\"*\"]),\n]\n\n# Create ASGI app with custom middleware\nhttp_app = mcp.http_app(middleware=custom_middleware)\n```\n\n## Starlette Integration\n\n<VersionBadge version=\"2.3.1\" \/>\n\nYou can mount your FastMCP server in another Starlette application:\n\n```python\nfrom fastmcp import FastMCP\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\n\n# Create your FastMCP server as well as any tools, resources, etc.\nmcp = FastMCP(\"MyServer\")\n\n# Create the ASGI app\nmcp_app = mcp.http_app(path='\/mcp')\n\n# Create a Starlette app and mount the MCP server\napp = Starlette(\n    routes=[\n        Mount(\"\/mcp-server\", app=mcp_app),\n        # Add other routes as needed\n    ],\n    lifespan=mcp_app.lifespan,\n)\n```\n\nThe MCP endpoint will be available at `\/mcp-server\/mcp` of the resulting Starlette app.\n\n<Warning>\n  For Streamable HTTP transport, you **must** pass the lifespan context from the FastMCP app to the resulting Starlette app, as nested lifespans are not recognized. Otherwise, the FastMCP server's session manager will not be properly initialized.\n<\/Warning>\n\n### Nested Mounts\n\nYou can create complex routing structures by nesting mounts:\n\n```python\nfrom fastmcp import FastMCP\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\n\n# Create your FastMCP server as well as any tools, resources, etc.\nmcp = FastMCP(\"MyServer\")\n\n# Create the ASGI app\nmcp_app = mcp.http_app(path='\/mcp')\n\n# Create nested application structure\ninner_app = Starlette(routes=[Mount(\"\/inner\", app=mcp_app)])\napp = Starlette(\n    routes=[Mount(\"\/outer\", app=inner_app)],\n    lifespan=mcp_app.lifespan,\n)\n```\n\nIn this setup, the MCP server is accessible at the `\/outer\/inner\/mcp` path of the resulting Starlette app.\n\n<Warning>\n  For Streamable HTTP transport, you **must** pass the lifespan context from the FastMCP app to the *outer* Starlette app, as nested lifespans are not recognized. Otherwise, the FastMCP server's session manager will not be properly initialized.\n<\/Warning>\n\n## FastAPI Integration\n\n<VersionBadge version=\"2.3.1\" \/>\n\nFastAPI is built on Starlette, so you can mount your FastMCP server in a similar way:\n\n```python\nfrom fastmcp import FastMCP\nfrom fastapi import FastAPI\nfrom starlette.routing import Mount\n\n# Create your FastMCP server as well as any tools, resources, etc.\nmcp = FastMCP(\"MyServer\")\n\n# Create the ASGI app\nmcp_app = mcp.http_app(path='\/mcp')\n\n# Create a FastAPI app and mount the MCP server\napp = FastAPI(lifespan=mcp_app.lifespan)\napp.mount(\"\/mcp-server\", mcp_app)\n```\n\nThe MCP endpoint will be available at `\/mcp-server\/mcp` of the resulting FastAPI app.\n\n<Warning>\n  For Streamable HTTP transport, you **must** pass the lifespan context from the FastMCP app to the resulting FastAPI app, as nested lifespans are not recognized. Otherwise, the FastMCP server's session manager will not be properly initialized.\n<\/Warning>\n\n## Custom Routes\n\nIn addition to adding your FastMCP server to an existing ASGI app, you can also add custom web routes to your FastMCP server, which will be exposed alongside the MCP endpoint. To do so, use the `@custom_route` decorator. Note that this is less flexible than using a full ASGI framework, but can be useful for adding simple endpoints like health checks to your standalone server.\n\n```python\nfrom fastmcp import FastMCP\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.custom_route(\"\/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -> PlainTextResponse:\n    return PlainTextResponse(\"OK\")\n```\n\nThese routes will be included in the FastMCP app when mounted in your web application.\n\n\n# Authentication\nSource: https:\/\/gofastmcp.com\/deployment\/authentication\n\nSecure your FastMCP server with authentication.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.2.7\" \/>\n\nThis document will cover how to implement authentication for your FastMCP servers.\n\nFastMCP leverages the OAuth 2.0 support provided by the underlying Model Context Protocol (MCP) SDK.\n\nFor now, refer to the [MCP Server Authentication documentation](\/servers\/fastmcp#authentication) for initial details and the [official MCP SDK documentation](https:\/\/modelcontextprotocol.io\/specification\/2025-03-26\/basic\/authorization) for more.\n\n\n# FastMCP CLI\nSource: https:\/\/gofastmcp.com\/deployment\/cli\n\nLearn how to use the FastMCP command-line interface\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nFastMCP provides a command-line interface (CLI) that makes it easy to run, develop, and install your MCP servers. The CLI is automatically installed when you install FastMCP.\n\n```bash\nfastmcp --help\n```\n\n## Commands Overview\n\n| Command   | Purpose                                         | Dependency Management                                                                                             |\n| --------- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |\n| `run`     | Run a FastMCP server directly                   | Uses your current environment; you are responsible for ensuring all dependencies are available                    |\n| `dev`     | Run a server with the MCP Inspector for testing | Creates an isolated environment; dependencies must be explicitly specified with `--with` and\/or `--with-editable` |\n| `install` | Install a server in the Claude desktop app      | Creates an isolated environment; dependencies must be explicitly specified with `--with` and\/or `--with-editable` |\n| `version` | Display version information                     | N\/A                                                                                                               |\n\n## Command Details\n\n### `run`\n\nRun a FastMCP server directly or proxy a remote server.\n\n```bash\nfastmcp run server.py\n```\n\n<Tip>\n  This command runs the server directly in your current Python environment. You are responsible for ensuring all dependencies are available.\n<\/Tip>\n\n#### Options\n\n| Option    | Flag                | Description                                                      |\n| --------- | ------------------- | ---------------------------------------------------------------- |\n| Transport | `--transport`, `-t` | Transport protocol to use (`stdio`, `streamable-http`, or `sse`) |\n| Host      | `--host`            | Host to bind to when using http transport (default: 127.0.0.1)   |\n| Port      | `--port`, `-p`      | Port to bind to when using http transport (default: 8000)        |\n| Log Level | `--log-level`, `-l` | Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)                |\n\n#### Server Specification\n\n<VersionBadge version=\"2.3.5\" \/>\n\nThe server can be specified in three ways:\n\n1. `server.py` - imports the module and looks for a FastMCP object named `mcp`, `server`, or `app`. Errors if no such object is found.\n2. `server.py:custom_name` - imports and uses the specified server object\n3. `http:\/\/server-url\/path` or `https:\/\/server-url\/path` - connects to a remote server and creates a proxy\n\n<Tip>\n  When using `fastmcp run` with a local file, it **ignores** the `if __name__ == \"__main__\"` block entirely. Instead, it finds your server object and calls its `run()` method directly with the transport options you specify. This means you can use `fastmcp run` to override the transport specified in your code.\n<\/Tip>\n\nFor example, if your code contains:\n\n```python\n# server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.tool()\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    # This is ignored when using `fastmcp run`!\n    mcp.run(transport=\"stdio\")\n```\n\nYou can run it with Streamable HTTP transport regardless of what's in the `__main__` block:\n\n```bash\nfastmcp run server.py --transport streamable-http --port 8000\n```\n\n**Examples**\n\n```bash\n# Run a local server with Streamable HTTP transport on a custom port\nfastmcp run server.py --transport streamable-http --port 8000\n\n# Connect to a remote server and proxy as a stdio server\nfastmcp run https:\/\/example.com\/mcp-server\n\n# Connect to a remote server with specified log level\nfastmcp run https:\/\/example.com\/mcp-server --log-level DEBUG\n```\n\n### `dev`\n\nRun a MCP server with the [MCP Inspector](https:\/\/github.com\/modelcontextprotocol\/inspector) for testing.\n\n```bash\nfastmcp dev server.py\n```\n\n<Tip>\n  This command runs your server in an isolated environment. All dependencies must be explicitly specified using the `--with` and\/or `--with-editable` options.\n<\/Tip>\n\n<Warning>\n  The `dev` command is a shortcut for testing a server over STDIO only. When the Inspector launches, you may need to:\n\n  1. Select \"STDIO\" from the transport dropdown\n  2. Connect manually\n\n  This command does not support HTTP testing. To test a server over HTTP:\n\n  1. Start your server manually with HTTP transport using either:\n     ```bash\n     fastmcp run server.py --transport streamable-http\n     ```\n     or\n     ```bash\n     python server.py  # Assuming your __main__ block sets HTTP transport\n     ```\n  2. Open the MCP Inspector separately and connect to your running server\n<\/Warning>\n\n#### Options\n\n| Option              | Flag                    | Description                                                     |\n| ------------------- | ----------------------- | --------------------------------------------------------------- |\n| Editable Package    | `--with-editable`, `-e` | Directory containing pyproject.toml to install in editable mode |\n| Additional Packages | `--with`                | Additional packages to install (can be used multiple times)     |\n| Inspector Version   | `--inspector-version`   | Version of the MCP Inspector to use                             |\n| UI Port             | `--ui-port`             | Port for the MCP Inspector UI                                   |\n| Server Port         | `--server-port`         | Port for the MCP Inspector Proxy server                         |\n\n**Example**\n\n```bash\n# Run dev server with editable mode and additional packages\nfastmcp dev server.py -e . --with pandas --with matplotlib\n```\n\n### `install`\n\nInstall a MCP server in the Claude desktop app.\n\n```bash\nfastmcp install server.py\n```\n\n<Tip>\n  This command installs your server in an isolated environment. All dependencies must be explicitly specified using the `--with` and\/or `--with-editable` options.\n<\/Tip>\n\n<Warning>\n  The `install` command currently only sets up servers for STDIO transport. When installed in the Claude desktop app, your server will be run using STDIO regardless of any transport configuration in your code.\n<\/Warning>\n\n#### Options\n\n| Option                | Flag                    | Description                                                            |\n| --------------------- | ----------------------- | ---------------------------------------------------------------------- |\n| Server Name           | `--name`, `-n`          | Custom name for the server                                             |\n| Editable Package      | `--with-editable`, `-e` | Directory containing pyproject.toml to install in editable mode        |\n| Additional Packages   | `--with`                | Additional packages to install (can be used multiple times)            |\n| Environment Variables | `--env-var`, `-v`       | Environment variables in KEY=VALUE format (can be used multiple times) |\n| Environment File      | `--env-file`, `-f`      | Load environment variables from a .env file                            |\n\n**Example**\n\n```bash\n# Install server with custom name, dependencies, and environment variables\nfastmcp install server.py -n \"My Analysis Server\" -e . --with pandas --env-var API_KEY=12345\n```\n\n### `version`\n\nDisplay version information about FastMCP and related components.\n\n```bash\nfastmcp version\n```\n\n\n# Running Your FastMCP Server\nSource: https:\/\/gofastmcp.com\/deployment\/running-server\n\nLearn how to run and deploy your FastMCP server using various transport protocols like STDIO, Streamable HTTP, and SSE.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nFastMCP servers can be run in different ways depending on your application's needs, from local command-line tools to persistent web services. This guide covers the primary methods for running your server, focusing on the available transport protocols: STDIO, Streamable HTTP, and SSE.\n\n## The `run()` Method\n\nFastMCP servers can be run directly from Python by calling the `run()` method on a `FastMCP` instance.\n\n<Tip>\n  For maximum compatibility, it's best practice to place the `run()` call within an `if __name__ == \"__main__\":` block. This ensures the server starts only when the script is executed directly, not when imported as a module.\n<\/Tip>\n\n```python {9-10} my_server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"MyServer\")\n\n@mcp.tool()\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\nYou can now run this MCP server by executing `python my_server.py`.\n\nMCP servers can be run with a variety of different transport options, depending on your application's requirements. The `run()` method can take a `transport` argument and other transport-specific keyword arguments to configure how the server operates.\n\n## The FastMCP CLI\n\nFastMCP also provides a command-line interface for running servers without modifying the source code. After installing FastMCP, you can run your server directly from the command line:\n\n```bash\nfastmcp run server.py\n```\n\n<Tip>\n  **Important**: When using `fastmcp run`, it **ignores** the `if __name__ == \"__main__\"` block entirely. Instead, it looks for a FastMCP object named `mcp`, `server`, or `app` and calls its `run()` method directly with the transport options you specify.\n\n  This means you can use `fastmcp run` to override the transport specified in your code, which is particularly useful for testing or changing deployment methods without modifying the code.\n<\/Tip>\n\nYou can specify transport options and other configuration:\n\n```bash\nfastmcp run server.py --transport sse --port 9000\n```\n\nFor development and testing, you can use the `dev` command to run your server with the MCP Inspector:\n\n```bash\nfastmcp dev server.py\n```\n\nSee the [CLI documentation](\/deployment\/cli) for detailed information about all available commands and options.\n\n## Transport Options\n\nBelow is a comparison of available transport options to help you choose the right one for your needs:\n\n| Transport           | Use Cases                                                                            | Recommendation                                                |\n| ------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------- |\n| **STDIO**           | Local tools, command-line scripts, and integrations with clients like Claude Desktop | Best for local tools and when clients manage server processes |\n| **Streamable HTTP** | Web-based deployments, microservices, exposing MCP over a network                    | Recommended choice for web-based deployments                  |\n| **SSE**             | Existing web-based deployments that rely on SSE                                      | Deprecated - prefer Streamable HTTP for new projects          |\n\n### STDIO\n\nThe STDIO transport is the default and most widely compatible option for local MCP server execution. It is ideal for local tools, command-line integrations, and clients like Claude Desktop. However, it has the disadvantage of having to run the MCP code locally, which can introduce security concerns with third-party servers.\n\nSTDIO is the default transport, so you don't need to specify it when calling `run()`. However, you can specify it explicitly to make your intent clear:\n\n```python {6}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"stdio\")\n```\n\nWhen using Stdio transport, you will typically *not* run the server yourself as a separate process. Rather, your *clients* will spin up a new server process for each session. As such, no additional configuration is required.\n\n### Streamable HTTP\n\n<VersionBadge version=\"2.3.0\" \/>\n\nStreamable HTTP is a modern, efficient transport for exposing your MCP server via HTTP. It is the recommended transport for web-based deployments.\n\nTo run a server using Streamable HTTP, you can use the `run()` method with the `transport` argument set to `\"streamable-http\"`. This will start a Uvicorn server on the default host (`127.0.0.1`), port (`8000`), and path (`\/mcp`).\n\n<CodeGroup>\n  ```python {6} server.py\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  if __name__ == \"__main__\":\n      mcp.run(transport=\"streamable-http\")\n  ```\n\n  ```python {5} client.py\n  import asyncio\n  from fastmcp import Client\n\n  async def example():\n      async with Client(\"http:\/\/127.0.0.1:8000\/mcp\") as client:\n          await client.ping()\n\n  if __name__ == \"__main__\":\n      asyncio.run(example())\n  ```\n<\/CodeGroup>\n\nTo customize the host, port, path, or log level, provide appropriate keyword arguments to the `run()` method.\n\n<CodeGroup>\n  ```python {8-11} server.py\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  if __name__ == \"__main__\":\n      mcp.run(\n          transport=\"streamable-http\",\n          host=\"127.0.0.1\",\n          port=4200,\n          path=\"\/my-custom-path\",\n          log_level=\"debug\",\n      )\n  ```\n\n  ```python {5} client.py\n  import asyncio\n  from fastmcp import Client\n\n  async def example():\n      async with Client(\"http:\/\/127.0.0.1:4200\/my-custom-path\") as client:\n          await client.ping()\n\n  if __name__ == \"__main__\":\n      asyncio.run(example())\n  ```\n<\/CodeGroup>\n\n### SSE\n\n<Warning>\n  The SSE transport is deprecated and may be removed in a future version.\n  New applications should use Streamable HTTP transport instead.\n<\/Warning>\n\nServer-Sent Events (SSE) is an HTTP-based protocol for server-to-client streaming. While FastMCP still supports SSE, it is deprecated and Streamable HTTP is preferred for new projects.\n\nTo run a server using SSE, you can use the `run()` method with the `transport` argument set to `\"sse\"`. This will start a Uvicorn server on the default host (`127.0.0.1`), port (`8000`), and with default SSE path (`\/sse`) and message path (`\/messages\/`).\n\n<CodeGroup>\n  ```python {6} server.py\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  if __name__ == \"__main__\":\n      mcp.run(transport=\"sse\")\n  ```\n\n  ```python {3,7} client.py\n  import asyncio\n  from fastmcp import Client\n  from fastmcp.client.transports import SSETransport\n\n  async def example():\n      async with Client(\n          transport=SSETransport(\"http:\/\/127.0.0.1:8000\/sse\")\n      ) as client:\n          await client.ping()\n\n  if __name__ == \"__main__\":\n      asyncio.run(example())\n  ```\n<\/CodeGroup>\n\n<Tip>\n  Notice that the client in the above example uses an explicit `SSETransport` to connect to the server. FastMCP will attempt to infer the appropriate transport from the provided configuration, but HTTP URLs are assumed to be Streamable HTTP (as of FastMCP 2.3.0).\n<\/Tip>\n\nTo customize the host, port, or log level, provide appropriate keyword arguments to the `run()` method. You can also adjust the SSE path (which clients should connect to) and the message POST endpoint (which clients use to send subsequent messages).\n\n<CodeGroup>\n  ```python {8-12} server.py\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  if __name__ == \"__main__\":\n      mcp.run(\n          transport=\"sse\",\n          host=\"127.0.0.1\",\n          port=4200,\n          log_level=\"debug\",\n          path=\"\/my-custom-sse-path\",\n      )\n  ```\n\n  ```python {7} client.py\n  import asyncio\n  from fastmcp import Client\n  from fastmcp.client.transports import SSETransport\n\n  async def example():\n      async with Client(\n          transport=SSETransport(\"http:\/\/127.0.0.1:4200\/my-custom-sse-path\")\n      ) as client:\n          await client.ping()\n\n  if __name__ == \"__main__\":\n      asyncio.run(example())\n  ```\n<\/CodeGroup>\n\n## Async Usage\n\nFastMCP provides both synchronous and asynchronous APIs for running your server. The `run()` method seen in previous examples is a synchronous method that internally uses `anyio.run()` to run the asynchronous server. For applications that are already running in an async context, FastMCP provides the `run_async()` method.\n\n```python {10-12}\nfrom fastmcp import FastMCP\nimport asyncio\n\nmcp = FastMCP(name=\"MyServer\")\n\n@mcp.tool()\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nasync def main():\n    # Use run_async() in async contexts\n    await mcp.run_async(transport=\"streamable-http\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n<Warning>\n  The `run()` method cannot be called from inside an async function because it already creates its own async event loop internally. If you attempt to call `run()` from inside an async function, you'll get an error about the event loop already running.\n\n  Always use `run_async()` inside async functions and `run()` in synchronous contexts.\n<\/Warning>\n\nBoth `run()` and `run_async()` accept the same transport arguments, so all the examples above apply to both methods.\n\n## Custom Routes\n\nYou can also add custom web routes to your FastMCP server, which will be exposed alongside the MCP endpoint. To do so, use the `@custom_route` decorator. Note that this is less flexible than using a full ASGI framework, but can be useful for adding simple endpoints like health checks to your standalone server.\n\n```python\nfrom fastmcp import FastMCP\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.custom_route(\"\/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -> PlainTextResponse:\n    return PlainTextResponse(\"OK\")\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n\n# Installation\nSource: https:\/\/gofastmcp.com\/getting-started\/installation\n\n\n\n## Install FastMCP\n\nWe recommend using [uv](https:\/\/docs.astral.sh\/uv\/getting-started\/installation\/) to install and manage FastMCP.\n\nIf you plan to use FastMCP in your project, you can add it as a dependency with:\n\n```bash\nuv add fastmcp\n```\n\nAlternatively, you can install it directly with `pip` or `uv pip`:\n\n<CodeGroup>\n  ```bash uv\n  uv pip install fastmcp\n  ```\n\n  ```bash pip\n  pip install fastmcp\n  ```\n<\/CodeGroup>\n\n### Verify Installation\n\nTo verify that FastMCP is installed correctly, you can run the following command:\n\n```bash\nfastmcp version\n```\n\nYou should see output like the following:\n\n```bash\n$ fastmcp version\n\nFastMCP version:   0.4.2.dev41+ga077727.d20250410\nMCP version:                                1.6.0\nPython version:                            3.12.2\nPlatform:            macOS-15.3.1-arm64-arm-64bit\nFastMCP root path:            ~\/Developer\/fastmcp\n```\n\n## Upgrading from the Official MCP SDK\n\nUpgrading from the official MCP SDK's FastMCP 1.0 to FastMCP 2.0 is generally straightforward. The core server API is highly compatible, and in many cases, changing your import statement from `from mcp.server.fastmcp import FastMCP` to `from fastmcp import FastMCP` will be sufficient.\n\n```python {1-5}\n# Before\n# from mcp.server.fastmcp import FastMCP\n\n# After\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"My MCP Server\")\n```\n\n<Warning>\n  Prior to `fastmcp==2.3.0` and `mcp==1.8.0`, the 2.x API always mirrored the 1.0 API. However, as the projects diverge, this can not be guaranteed. You may see deprecation warnings if you attempt to use 1.0 APIs in FastMCP 2.x. Please refer to this documentation for details on new capabilities.\n<\/Warning>\n\n## Versioning and Breaking Changes\n\nWhile we make every effort not to introduce backwards-incompatible changes to our public APIs and behavior, FastMCP exists in a rapidly evolving MCP landscape. We're committed to bringing the most cutting-edge features to our users, which occasionally necessitates changes to existing functionality.\n\nAs a practice, breaking changes will only occur on minor version changes (e.g., 2.3.x to 2.4.0). A minor version change indicates either:\n\n* A significant new feature set that warrants a new minor version\n* Introducing breaking changes that may affect behavior on upgrade\n\nFor users concerned about stability in production environments, we recommend pinning FastMCP to a specific version in your dependencies.\n\nWhenever possible, FastMCP will issue deprecation warnings when users attempt to use APIs that are either deprecated or destined for future removal. These warnings will be maintained for at least 1 minor version release, and may be maintained longer.\n\nNote that the \"public API\" includes the core functionality of the `FastMCP` server and its methods. It does not include private methods or objects that are stored as private attributes, as we do not expect users to rely on those implementation details.\n\n## Installing for Development\n\nIf you plan to contribute to FastMCP, you should begin by cloning the repository and using uv to install all dependencies (development dependencies are installed automatically):\n\n```bash\ngit clone https:\/\/github.com\/jlowin\/fastmcp.git\ncd fastmcp\nuv sync\n```\n\nThis will install all dependencies, including ones for development, and create a virtual environment, which you can activate and use as normal.\n\n### Unit Tests\n\nFastMCP has a comprehensive unit test suite, and all PR's must introduce and pass appropriate tests. To run the tests, use pytest:\n\n```bash\npytest\n```\n\n### Pre-Commit Hooks\n\nFastMCP uses pre-commit to manage code quality, including formatting, linting, and type-safety. All PRs must pass the pre-commit hooks, which are run as a part of the CI process. To install the pre-commit hooks, run:\n\n```bash\nuv run pre-commit install\n```\n\nAlternatively, to run pre-commit manually at any time, use:\n\n```bash\npre-commit run --all-files\n```\n\n\n# Quickstart\nSource: https:\/\/gofastmcp.com\/getting-started\/quickstart\n\n\n\nWelcome! This guide will help you quickly set up FastMCP and run your first MCP server.\n\nIf you haven't already installed FastMCP, follow the [installation instructions](\/getting-started\/installation).\n\n## Creating a FastMCP Server\n\nA FastMCP server is a collection of tools, resources, and other MCP components. To create a server, start by instantiating the `FastMCP` class.\n\nCreate a new file called `my_server.py` and add the following code:\n\n```python my_server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"My MCP Server\")\n```\n\nThat's it! You've created a FastMCP server, albeit a very boring one. Let's add a tool to make it more interesting.\n\n## Adding a Tool\n\nTo add a tool that returns a simple greeting, write a function and decorate it with `@mcp.tool` to register it with the server:\n\n```python my_server.py {5-7}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"My MCP Server\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n## Testing the Server\n\nTo test the server, create a FastMCP client and point it at the server object.\n\n```python my_server.py {1-2, 10-17}\nimport asyncio\nfrom fastmcp import FastMCP, Client\n\nmcp = FastMCP(\"My MCP Server\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nclient = Client(mcp)\n\nasync def call_tool(name: str):\n    async with client:\n        result = await client.call_tool(\"greet\", {\"name\": name})\n        print(result)\n\nasyncio.run(call_tool(\"Ford\"))\n```\n\nThere are a few things to note here:\n\n* Clients are asynchronous, so we need to use `asyncio.run` to run the client.\n* We must enter a client context (`async with client:`) before using the client. You can make multiple client calls within the same context.\n\n## Running the server\n\nIn order to run the server with Python, we need to add a `run` statement to the `__main__` block of the server file.\n\n```python my_server.py {9-10}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"My MCP Server\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\nThis lets us run the server with `python my_server.py`, using the default `stdio` transport, which is the standard way to expose an MCP server to a client.\n\n<Tip>\n  Why do we need the `if __name__ == \"__main__\":` block?\n\n  Within the FastMCP ecosystem, this line may be unnecessary. However, including it ensures that your FastMCP server runs for all users and clients in a consistent way and is therefore recommended as best practice.\n<\/Tip>\n\n### Interacting with the Python server\n\nNow that the server can be executed with `python my_server.py`, we can interact with it like any other MCP server.\n\nIn a new file, create a client and point it at the server file:\n\n```python my_client.py\nimport asyncio\nfrom fastmcp import Client\n\nclient = Client(\"my_server.py\")\n\nasync def call_tool(name: str):\n    async with client:\n        result = await client.call_tool(\"greet\", {\"name\": name})\n        print(result)\n\nasyncio.run(call_tool(\"Ford\"))\n```\n\n### Using the FastMCP CLI\n\nTo have FastMCP run the server for us, we can use the `fastmcp run` command. This will start the server and keep it running until it is stopped. By default, it will use the `stdio` transport, which is a simple text-based protocol for interacting with the server.\n\n```bash\nfastmcp run my_server.py:mcp\n```\n\nNote that FastMCP *does not* require the `__main__` block in the server file, and will ignore it if it is present. Instead, it looks for the server object provided in the CLI command (here, `mcp`). If no server object is provided, `fastmcp run` will automatically search for servers called \"mcp\", \"app\", or \"server\" in the file.\n\n<Tip>\n  We pointed our client at the server file, which is recognized as a Python MCP server and executed with `python my_server.py` by default. This executes the `__main__` block of the server file. There are other ways to run the server, which are described in the [server configuration](\/servers\/fastmcp#running-the-server) guide.\n<\/Tip>\n\n\n# Welcome to FastMCP 2.0!\nSource: https:\/\/gofastmcp.com\/getting-started\/welcome\n\nThe fast, Pythonic way to build MCP servers and clients.\n\nThe [Model Context Protocol](https:\/\/modelcontextprotocol.io\/) (MCP) is a new, standardized way to provide context and tools to your LLMs, and FastMCP makes building MCP servers and clients simple and intuitive. Create tools, expose resources, define prompts, and more with clean, Pythonic code:\n\n```python {1, 3, 5, 11}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"Demo \")\n\n@mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n## FastMCP and the Official MCP SDK\n\nFastMCP is the standard framework for building MCP servers and clients. FastMCP 1.0 was incorporated into the [official MCP Python SDK](https:\/\/github.com\/modelcontextprotocol\/python-sdk).\n\n**This is FastMCP 2.0,** the [actively maintained version](https:\/\/github.com\/jlowin\/fastmcp) that significantly expands on 1.0's basic server-building capabilities by introducing full client support, server composition, OpenAPI\/FastAPI integration, remote server proxying, built-in testing tools, and more.\n\nFastMCP 2.0 is the complete toolkit for modern AI applications. Ready to upgrade or get started? Follow the [installation instructions](\/getting-started\/installation), which include specific steps for upgrading from the official MCP SDK.\n\n## What is MCP?\n\nThe Model Context Protocol lets you build servers that expose data and functionality to LLM applications in a secure, standardized way. It is often described as \"the USB-C port for AI\", providing a uniform way to connect LLMs to resources they can use. It may be easier to think of it as an API, but specifically designed for LLM interactions. MCP servers can:\n\n* Expose data through `Resources` (think of these sort of like GET endpoints; they are used to load information into the LLM's context)\n* Provide functionality through `Tools` (sort of like POST endpoints; they are used to execute code or otherwise produce a side effect)\n* Define interaction patterns through `Prompts` (reusable templates for LLM interactions)\n* And more!\n\nThere is a low-level Python SDK available for implementing the protocol directly, but FastMCP aims to make that easier by providing a high-level, Pythonic interface.\n\n## Why FastMCP?\n\nThe MCP protocol is powerful but implementing it involves a lot of boilerplate - server setup, protocol handlers, content types, error management. FastMCP handles all the complex protocol details and server management, so you can focus on building great tools. It's designed to be high-level and Pythonic; in most cases, decorating a function is all you need.\n\nWhile the core server concepts of FastMCP 1.0 laid the groundwork and were contributed to the official MCP SDK, FastMCP 2.0 (this project) is the actively developed successor, adding significant enhancements and entirely new capabilities like a powerful client library, server proxying, composition patterns, and much more.\n\nFastMCP aims to be:\n\n **Fast**: High-level interface means less code and faster development\n\n **Simple**: Build MCP servers with minimal boilerplate\n\n **Pythonic**: Feels natural to Python developers\n\n **Complete**: FastMCP aims to provide a full implementation of the core MCP specification\n\n## `llms.txt`\n\nThis documentation is also available in [llms.txt format](https:\/\/llmstxt.org\/), which is a simple markdown standard that LLMs can consume easily.\n\nThere are two ways to access the LLM-friendly documentation:\n\n* [`llms.txt`](https:\/\/gofastmcp.com\/llms.txt) is essentially a sitemap, listing all the pages in the documentation.\n* [`llms-full.txt`](https:\/\/gofastmcp.com\/llms-full.txt) contains the entire documentation. Note this may exceed the context window of your LLM.\n\n\n# Contrib Modules\nSource: https:\/\/gofastmcp.com\/patterns\/contrib\n\nCommunity-contributed modules extending FastMCP\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.2.1\" \/>\n\nFastMCP includes a `contrib` package that holds community-contributed modules. These modules extend FastMCP's functionality but aren't officially maintained by the core team.\n\nContrib modules provide additional features, integrations, or patterns that complement the core FastMCP library. They offer a way for the community to share useful extensions while keeping the core library focused and maintainable.\n\nThe available modules can be viewed in the [contrib directory](https:\/\/github.com\/jlowin\/fastmcp\/tree\/main\/src\/contrib).\n\n## Usage\n\nTo use a contrib module, import it from the `fastmcp.contrib` package:\n\n```python\nfrom fastmcp.contrib import my_module\n```\n\n## Important Considerations\n\n* **Stability**: Modules in `contrib` may have different testing requirements or stability guarantees compared to the core library.\n* **Compatibility**: Changes to core FastMCP might break modules in `contrib` without explicit warnings in the main changelog.\n* **Dependencies**: Contrib modules may have additional dependencies not required by the core library. These dependencies are typically documented in the module's README or separate requirements files.\n\n## Contributing\n\nWe welcome contributions to the `contrib` package! If you have a module that extends FastMCP in a useful way, consider contributing it:\n\n1. Create a new directory in `src\/fastmcp\/contrib\/` for your module\n2. Add proper tests for your module in `tests\/contrib\/`\n3. Include comprehensive documentation in a README.md file, including usage and examples, as well as any additional dependencies or installation instructions\n4. Submit a pull request\n\nThe ideal contrib module:\n\n* Solves a specific use case or integration need\n* Follows FastMCP coding standards\n* Includes thorough documentation and examples\n* Has comprehensive tests\n* Specifies any additional dependencies\n\n\n# Decorating Methods\nSource: https:\/\/gofastmcp.com\/patterns\/decorating-methods\n\nProperly use instance methods, class methods, and static methods with FastMCP decorators.\n\nFastMCP's decorator system is designed to work with functions, but you may see unexpected behavior if you try to decorate an instance or class method. This guide explains the correct approach for using methods with all FastMCP decorators (`@tool()`, `@resource()`, and `@prompt()`).\n\n## Why Are Methods Hard?\n\nWhen you apply a FastMCP decorator like `@tool()`, `@resource()`, or `@prompt()` to a method, the decorator captures the function at decoration time. For instance methods and class methods, this poses a challenge because:\n\n1. For instance methods: The decorator gets the unbound method before any instance exists\n2. For class methods: The decorator gets the function before it's bound to the class\n\nThis means directly decorating these methods doesn't work as expected. In practice, the LLM would see parameters like `self` or `cls` that it cannot provide values for.\n\n## Recommended Patterns\n\n### Instance Methods\n\n**Don't do this** (it doesn't work properly):\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    @mcp.tool()  # This won't work correctly\n    def add(self, x, y):\n        return x + y\n    \n    @mcp.resource(\"resource:\/\/{param}\")  # This won't work correctly\n    def get_resource(self, param: str):\n        return f\"Resource data for {param}\"\n```\n\nWhen the decorator is applied this way, it captures the unbound method. When the LLM later tries to use this component, it will see `self` as a required parameter, but it won't know what to provide for it, causing errors or unexpected behavior.\n\n**Do this instead**:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    def add(self, x, y):\n        return x + y\n    \n    def get_resource(self, param: str):\n        return f\"Resource data for {param}\"\n\n# Create an instance first, then add the bound methods\nobj = MyClass()\nmcp.add_tool(obj.add)\nmcp.add_resource_fn(obj.get_resource, uri=\"resource:\/\/{param}\")  # For resources or templates\n\n# Note: FastMCP provides add_resource() for adding Resource objects directly and\n# add_resource_fn() for adding functions that generate resources or templates\n\n# Now you can call it without 'self' showing up as a parameter\nawait mcp.call_tool('add', {'x': 1, 'y': 2})  # Returns 3\n```\n\nThis approach works because:\n\n1. You first create an instance of the class (`obj`)\n2. When you access the method through the instance (`obj.add`), Python creates a bound method where `self` is already set to that instance\n3. When you register this bound method, the system sees a callable that only expects the appropriate parameters, not `self`\n\n### Class Methods\n\nSimilar to instance methods, decorating class methods directly doesn't work properly:\n\n**Don't do this**:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    @classmethod\n    @mcp.tool()  # This won't work correctly\n    def from_string(cls, s):\n        return cls(s)\n```\n\nThe problem here is that the FastMCP decorator is applied before the `@classmethod` decorator (Python applies decorators bottom-to-top). So it captures the function before it's transformed into a class method, leading to incorrect behavior.\n\n**Do this instead**:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    @classmethod\n    def from_string(cls, s):\n        return cls(s)\n\n# Add the class method after the class is defined\nmcp.add_tool(MyClass.from_string)\n```\n\nThis works because:\n\n1. The `@classmethod` decorator is applied properly during class definition\n2. When you access `MyClass.from_string`, Python provides a special method object that automatically binds the class to the `cls` parameter\n3. When registered, only the appropriate parameters are exposed to the LLM, hiding the implementation detail of the `cls` parameter\n\n### Static Methods\n\nUnlike instance and class methods, static methods work fine with FastMCP decorators:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    @staticmethod\n    @mcp.tool()  # This works!\n    def utility(x, y):\n        return x + y\n    \n    @staticmethod\n    @mcp.resource(\"resource:\/\/data\")  # This works too!\n    def get_data():\n        return \"Static resource data\"\n```\n\nThis approach works because:\n\n1. The `@staticmethod` decorator is applied first (executed last), transforming the method into a regular function\n2. When the FastMCP decorator is applied, it's capturing what is effectively just a regular function\n3. A static method doesn't have any binding requirements - it doesn't receive a `self` or `cls` parameter\n\nAlternatively, you can use the same pattern as the other methods:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass MyClass:\n    @staticmethod\n    def utility(x, y):\n        return x + y\n\n# This also works\nmcp.add_tool(MyClass.utility)\n```\n\nThis works for the same reason - a static method is essentially just a function in a class namespace.\n\n## Additional Patterns\n\n### Creating Components at Class Initialization\n\nYou can automatically register instance methods when creating an object:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass ComponentProvider:\n    def __init__(self, mcp_instance):\n        # Register methods\n        mcp_instance.add_tool(self.tool_method)\n        mcp_instance.add_resource_fn(self.resource_method, uri=\"resource:\/\/data\")\n    \n    def tool_method(self, x):\n        return x * 2\n    \n    def resource_method(self):\n        return \"Resource data\"\n\n# The methods are automatically registered when creating the instance\nprovider = ComponentProvider(mcp)\n```\n\nThis pattern is useful when:\n\n* You want to encapsulate registration logic within the class itself\n* You have multiple related components that should be registered together\n* You want to ensure that methods are always properly registered when creating an instance\n\nThe class automatically registers its methods during initialization, ensuring they're properly bound to the instance before registration.\n\n## Summary\n\nWhile FastMCP's decorator pattern works seamlessly with regular functions and static methods, for instance methods and class methods, you should add them after creating the instance or class. This ensures that the methods are properly bound before being registered.\n\nThese patterns apply to all FastMCP decorators and registration methods:\n\n* `@tool()` and `add_tool()`\n* `@resource()` and `add_resource_fn()`\n* `@prompt()` and `add_prompt()`\n\nUnderstanding these patterns allows you to effectively organize your components into classes while maintaining proper method binding, giving you the benefits of object-oriented design without sacrificing the simplicity of FastMCP's decorator system.\n\n\n# HTTP Requests\nSource: https:\/\/gofastmcp.com\/patterns\/http-requests\n\nAccessing and using HTTP requests in FastMCP servers\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.2.11\" \/>\n\n## Overview\n\nWhen running FastMCP as a web server, your MCP tools, resources, and prompts might need to access the underlying HTTP request information, such as headers, client IP, or query parameters.\n\nFastMCP provides a clean way to access HTTP request information through a dependency function.\n\n## Accessing HTTP Requests\n\nThe recommended way to access the current HTTP request is through the `get_http_request()` dependency function:\n\n```python {2, 3, 11}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.dependencies import get_http_request\nfrom starlette.requests import Request\n\nmcp = FastMCP(name=\"HTTPRequestDemo\")\n\n@mcp.tool()\nasync def user_agent_info() -> dict:\n    \"\"\"Return information about the user agent.\"\"\"\n    # Get the HTTP request\n    request: Request = get_http_request()\n    \n    # Access request data\n    user_agent = request.headers.get(\"user-agent\", \"Unknown\")\n    client_ip = request.client.host if request.client else \"Unknown\"\n    \n    return {\n        \"user_agent\": user_agent,\n        \"client_ip\": client_ip,\n        \"path\": request.url.path,\n    }\n```\n\nThis approach works anywhere within a request's execution flow, not just within your MCP function. It's useful when:\n\n1. You need access to HTTP information in helper functions\n2. You're calling nested functions that need HTTP request data\n3. You're working with middleware or other request processing code\n\n## Important Notes\n\n* HTTP requests are only available when FastMCP is running as part of a web application\n* Accessing the HTTP request outside of a web request context will raise a `RuntimeError`\n* The `get_http_request()` function returns a standard [Starlette Request](https:\/\/www.starlette.io\/requests\/) object\n\n## Common Use Cases\n\n### Accessing Request Headers\n\n```python\nfrom fastmcp.server.dependencies import get_http_request\n\n@mcp.tool()\nasync def get_auth_info() -> dict:\n    \"\"\"Get authentication information from request headers.\"\"\"\n    request = get_http_request()\n    \n    # Get authorization header\n    auth_header = request.headers.get(\"authorization\", \"\")\n    \n    # Check for Bearer token\n    is_bearer = auth_header.startswith(\"Bearer \")\n    \n    return {\n        \"has_auth\": bool(auth_header),\n        \"auth_type\": \"Bearer\" if is_bearer else \"Other\" if auth_header else \"None\"\n    }\n```\n\n\n# Testing MCP Servers\nSource: https:\/\/gofastmcp.com\/patterns\/testing\n\nLearn how to test your FastMCP servers effectively\n\nTesting your MCP servers thoroughly is essential for ensuring they work correctly when deployed. FastMCP makes this easy through a variety of testing patterns.\n\n## In-Memory Testing\n\nThe most efficient way to test an MCP server is to pass your FastMCP server instance directly to a Client. This enables in-memory testing without having to start a separate server process, which is particularly useful because managing an MCP server programmatically can be challenging.\n\nHere is an example of using a `Client` to test a server with pytest:\n\n```python\nimport pytest\nfrom fastmcp import FastMCP, Client\n\n@pytest.fixture\ndef mcp_server():\n    server = FastMCP(\"TestServer\")\n    \n    @server.tool()\n    def greet(name: str) -> str:\n        return f\"Hello, {name}!\"\n        \n    return server\n\nasync def test_tool_functionality(mcp_server):\n    # Pass the server directly to the Client constructor\n    async with Client(mcp_server) as client:\n        result = await client.call_tool(\"greet\", {\"name\": \"World\"})\n        assert result[0].text == \"Hello, World!\"\n```\n\nThis pattern creates a direct connection between the client and server, allowing you to test your server's functionality efficiently.\n\n\n# Server Composition\nSource: https:\/\/gofastmcp.com\/servers\/composition\n\nCombine multiple FastMCP servers into a single, larger application using mounting and importing.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.2.0\" \/>\n\nAs your MCP applications grow, you might want to organize your tools, resources, and prompts into logical modules or reuse existing server components. FastMCP supports composition through two methods:\n\n* **`import_server`**: For a one-time copy of components with prefixing (static composition).\n* **`mount`**: For creating a live link where the main server delegates requests to the subserver (dynamic composition).\n\n## Why Compose Servers?\n\n* **Modularity**: Break down large applications into smaller, focused servers (e.g., a `WeatherServer`, a `DatabaseServer`, a `CalendarServer`).\n* **Reusability**: Create common utility servers (e.g., a `TextProcessingServer`) and mount them wherever needed.\n* **Teamwork**: Different teams can work on separate FastMCP servers that are later combined.\n* **Organization**: Keep related functionality grouped together logically.\n\n### Importing vs Mounting\n\nThe choice of importing or mounting depends on your use case and requirements.\n\n| Feature              | Importing                          | Mounting                                   |\n| -------------------- | ---------------------------------- | ------------------------------------------ |\n| **Method**           | `FastMCP.import_server()`          | `FastMCP.mount()`                          |\n| **Composition Type** | One-time copy (static)             | Live link (dynamic)                        |\n| **Updates**          | Changes to subserver NOT reflected | Changes to subserver immediately reflected |\n| **Best For**         | Bundling finalized components      | Modular runtime composition                |\n\n### Proxy Servers\n\nFastMCP supports [MCP proxying](\/patterns\/proxy), which allows you to mirror a local or remote server in a local FastMCP instance. Proxies are fully compatible with both importing and mounting.\n\n<VersionBadge version=\"2.4.0\" \/>\n\nYou can also create proxies from configuration dictionaries that follow the MCPConfig schema, which is useful for quickly connecting to one or more remote servers. See the [Proxy Servers documentation](\/servers\/proxy#configuration-based-proxies) for details on configuration-based proxying. Note that MCPConfig follows an emerging standard and its format may evolve over time.\n\n## Importing (Static Composition)\n\nThe `import_server()` method copies all components (tools, resources, templates, prompts) from one `FastMCP` instance (the *subserver*) into another (the *main server*). A `prefix` is added to avoid naming conflicts.\n\n```python\nfrom fastmcp import FastMCP\nimport asyncio\n\n# Define subservers\nweather_mcp = FastMCP(name=\"WeatherService\")\n\n@weather_mcp.tool()\ndef get_forecast(city: str) -> dict:\n    \"\"\"Get weather forecast.\"\"\"\n    return {\"city\": city, \"forecast\": \"Sunny\"}\n\n@weather_mcp.resource(\"data:\/\/cities\/supported\")\ndef list_supported_cities() -> list[str]:\n    \"\"\"List cities with weather support.\"\"\"\n    return [\"London\", \"Paris\", \"Tokyo\"]\n\n# Define main server\nmain_mcp = FastMCP(name=\"MainApp\")\n\n# Import subserver\nasync def setup():\n    await main_mcp.import_server(\"weather\", weather_mcp)\n\n# Result: main_mcp now contains prefixed components:\n# - Tool: \"weather_get_forecast\"\n# - Resource: \"data:\/\/weather\/cities\/supported\" \n\nif __name__ == \"__main__\":\n    asyncio.run(setup())\n    main_mcp.run()\n```\n\n### How Importing Works\n\nWhen you call `await main_mcp.import_server(prefix, subserver)`:\n\n1. **Tools**: All tools from `subserver` are added to `main_mcp` with names prefixed using `{prefix}_`.\n   * `subserver.tool(name=\"my_tool\")` becomes `main_mcp.tool(name=\"{prefix}_my_tool\")`.\n2. **Resources**: All resources are added with URIs prefixed in the format `protocol:\/\/{prefix}\/path`.\n   * `subserver.resource(uri=\"data:\/\/info\")` becomes `main_mcp.resource(uri=\"data:\/\/{prefix}\/info\")`.\n3. **Resource Templates**: Templates are prefixed similarly to resources.\n   * `subserver.resource(uri=\"data:\/\/{id}\")` becomes `main_mcp.resource(uri=\"data:\/\/{prefix}\/{id}\")`.\n4. **Prompts**: All prompts are added with names prefixed using `{prefix}_`.\n   * `subserver.prompt(name=\"my_prompt\")` becomes `main_mcp.prompt(name=\"{prefix}_my_prompt\")`.\n\nNote that `import_server` performs a **one-time copy** of components. Changes made to the `subserver` *after* importing **will not** be reflected in `main_mcp`. The `subserver`'s `lifespan` context is also **not** executed by the main server.\n\n## Mounting (Live Linking)\n\nThe `mount()` method creates a **live link** between the `main_mcp` server and the `subserver`. Instead of copying components, requests for components matching the `prefix` are **delegated** to the `subserver` at runtime.\n\n```python\nimport asyncio\nfrom fastmcp import FastMCP, Client\n\n# Define subserver\ndynamic_mcp = FastMCP(name=\"DynamicService\")\n\n@dynamic_mcp.tool()\ndef initial_tool():\n    \"\"\"Initial tool demonstration.\"\"\"\n    return \"Initial Tool Exists\"\n\n# Mount subserver (synchronous operation)\nmain_mcp = FastMCP(name=\"MainAppLive\")\nmain_mcp.mount(\"dynamic\", dynamic_mcp)\n\n# Add a tool AFTER mounting - it will be accessible through main_mcp\n@dynamic_mcp.tool()\ndef added_later():\n    \"\"\"Tool added after mounting.\"\"\"\n    return \"Tool Added Dynamically!\"\n\n# Testing access to mounted tools\nasync def test_dynamic_mount():\n    tools = await main_mcp.get_tools()\n    print(\"Available tools:\", list(tools.keys()))\n    # Shows: ['dynamic_initial_tool', 'dynamic_added_later']\n    \n    async with Client(main_mcp) as client:\n        result = await client.call_tool(\"dynamic_added_later\")\n        print(\"Result:\", result[0].text)\n        # Shows: \"Tool Added Dynamically!\"\n\nif __name__ == \"__main__\":\n    asyncio.run(test_dynamic_mount())\n```\n\n### How Mounting Works\n\nWhen mounting is configured:\n\n1. **Live Link**: The parent server establishes a connection to the mounted server.\n2. **Dynamic Updates**: Changes to the mounted server are immediately reflected when accessed through the parent.\n3. **Prefixed Access**: The parent server uses prefixes to route requests to the mounted server.\n4. **Delegation**: Requests for components matching the prefix are delegated to the mounted server at runtime.\n\nThe same prefixing rules apply as with `import_server` for naming tools, resources, templates, and prompts.\n\n### Direct vs. Proxy Mounting\n\n<VersionBadge version=\"2.2.7\" \/>\n\nFastMCP supports two mounting modes:\n\n1. **Direct Mounting** (default): The parent server directly accesses the mounted server's objects in memory.\n   * No client lifecycle events occur on the mounted server\n   * The mounted server's lifespan context is not executed\n   * Communication is handled through direct method calls\n2. **Proxy Mounting**: The parent server treats the mounted server as a separate entity and communicates with it through a client interface.\n   * Full client lifecycle events occur on the mounted server\n   * The mounted server's lifespan is executed when a client connects\n   * Communication happens via an in-memory Client transport\n\n```python\n# Direct mounting (default when no custom lifespan)\nmain_mcp.mount(\"api\", api_server)\n\n# Proxy mounting (preserves full client lifecycle)\nmain_mcp.mount(\"api\", api_server, as_proxy=True)\n```\n\nFastMCP automatically uses proxy mounting when the mounted server has a custom lifespan, but you can override this behavior with the `as_proxy` parameter.\n\n#### Interaction with Proxy Servers\n\nWhen using `FastMCP.as_proxy()` to create a proxy server, mounting that server will always use proxy mounting:\n\n```python\n# Create a proxy for a remote server\nremote_proxy = FastMCP.as_proxy(Client(\"http:\/\/example.com\/mcp\"))\n\n# Mount the proxy (always uses proxy mounting)\nmain_server.mount(\"remote\", remote_proxy)\n```\n\n## Resource Prefix Formats\n\n<VersionBadge version=\"2.4.0\" \/>\n\nWhen mounting or importing servers, resource URIs are usually prefixed to avoid naming conflicts. FastMCP supports two different formats for resource prefixes:\n\n### Path Format (Default)\n\nIn path format, prefixes are added to the path component of the URI:\n\n```\nresource:\/\/prefix\/path\/to\/resource\n```\n\nThis is the default format since FastMCP 2.4. This format is recommended because it avoids issues with URI protocol restrictions (like underscores not being allowed in protocol names).\n\n### Protocol Format (Legacy)\n\nIn protocol format, prefixes are added as part of the protocol:\n\n```\nprefix+resource:\/\/path\/to\/resource\n```\n\nThis was the default format in FastMCP before 2.4. While still supported, it's not recommended for new code as it can cause problems with prefix names that aren't valid in URI protocols.\n\n### Configuring the Prefix Format\n\nYou can configure the prefix format globally in code:\n\n```python\nimport fastmcp\nfastmcp.settings.settings.resource_prefix_format = \"protocol\" \n```\n\nOr via environment variable:\n\n```bash\nFASTMCP_RESOURCE_PREFIX_FORMAT=protocol\n```\n\nOr per-server:\n\n```python\nfrom fastmcp import FastMCP\n\n# Create a server that uses legacy protocol format\nserver = FastMCP(\"LegacyServer\", resource_prefix_format=\"protocol\")\n\n# Create a server that uses new path format\nserver = FastMCP(\"NewServer\", resource_prefix_format=\"path\")\n```\n\nWhen mounting or importing servers, the prefix format of the parent server is used.\n\n\n# MCP Context\nSource: https:\/\/gofastmcp.com\/servers\/context\n\nAccess MCP capabilities like logging, progress, and resources within your MCP objects.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nWhen defining FastMCP [tools](\/servers\/tools), [resources](\/servers\/resources), resource templates, or [prompts](\/servers\/prompts), your functions might need to interact with the underlying MCP session or access server capabilities. FastMCP provides the `Context` object for this purpose.\n\n## What Is Context?\n\nThe `Context` object provides a clean interface to access MCP features within your functions, including:\n\n* **Logging**: Send debug, info, warning, and error messages back to the client\n* **Progress Reporting**: Update the client on the progress of long-running operations\n* **Resource Access**: Read data from resources registered with the server\n* **LLM Sampling**: Request the client's LLM to generate text based on provided messages\n* **Request Information**: Access metadata about the current request\n* **Server Access**: When needed, access the underlying FastMCP server instance\n\n## Accessing the Context\n\n### Via Dependency Injection\n\nTo use the context object within any of your functions, simply add a parameter to your function signature and type-hint it as `Context`. FastMCP will automatically inject the context instance when your function is called.\n\n**Key Points:**\n\n* The parameter name (e.g., `ctx`, `context`) doesn't matter, only the type hint `Context` is important.\n* The context parameter can be placed anywhere in your function's signature; it will not be exposed to MCP clients as a valid parameter.\n* The context is optional - functions that don't need it can omit the parameter entirely.\n* Context methods are async, so your function usually needs to be async as well.\n* The type hint can be a union (`Context | None`) or use `Annotated[]` and it will still work properly.\n* Context is only available during a request; attempting to use context methods outside a request will raise errors. If you need to debug or call your context methods outside of a request, you can type your variable as `Context | None=None` to avoid missing argument errors.\n\n#### Tools\n\n```python\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"ContextDemo\")\n\n@mcp.tool()\nasync def process_file(file_uri: str, ctx: Context) -> str:\n    \"\"\"Processes a file, using context for logging and resource access.\"\"\"\n    # Context is available as the ctx parameter\n    return \"Processed file\"\n```\n\n#### Resources and Templates\n\n<VersionBadge version=\"2.2.5\" \/>\n\n```python\n@mcp.resource(\"resource:\/\/user-data\")\nasync def get_user_data(ctx: Context) -> dict:\n    \"\"\"Fetch personalized user data based on the request context.\"\"\"\n    # Context is available as the ctx parameter\n    return {\"user_id\": \"example\"}\n\n@mcp.resource(\"resource:\/\/users\/{user_id}\/profile\")\nasync def get_user_profile(user_id: str, ctx: Context) -> dict:\n    \"\"\"Fetch user profile with context-aware logging.\"\"\"\n    # Context is available as the ctx parameter\n    return {\"id\": user_id}\n```\n\n#### Prompts\n\n<VersionBadge version=\"2.2.5\" \/>\n\n```python\n@mcp.prompt()\nasync def data_analysis_request(dataset: str, ctx: Context) -> str:\n    \"\"\"Generate a request to analyze data with contextual information.\"\"\"\n    # Context is available as the ctx parameter\n    return f\"Please analyze the following dataset: {dataset}\"\n```\n\n### Via Dependency Function\n\n<VersionBadge version=\"2.2.11\" \/>\n\nWhile the simplest way to access context is through function parameter injection as shown above, there are cases where you need to access the context in code that may not be easy to modify to accept a context parameter, or that is nested deeper within your function calls.\n\nFastMCP provides dependency functions that allow you to retrieve the active context from anywhere within a server request's execution flow:\n\n```python {2,9}\nfrom fastmcp import FastMCP, Context\nfrom fastmcp.server.dependencies import get_context\n\nmcp = FastMCP(name=\"DependencyDemo\")\n\n# Utility function that needs context but doesn't receive it as a parameter\nasync def process_data(data: list[float]) -> dict:\n    # Get the active context - only works when called within a request\n    ctx = get_context()    \n    await ctx.info(f\"Processing {len(data)} data points\")\n    \n@mcp.tool()\nasync def analyze_dataset(dataset_name: str) -> dict:\n    # Call utility function that uses context internally\n    data = load_data(dataset_name)\n    await process_data(data)\n```\n\n**Important Notes:**\n\n* The `get_context` function should only be used within the context of a server request. Calling it outside of a request will raise a `RuntimeError`.\n* The `get_context` function is server-only and should not be used in client code.\n\n## Context Capabilities\n\n### Logging\n\nSend log messages back to the MCP client. This is useful for debugging and providing visibility into function execution during a request.\n\n```python\n@mcp.tool()\nasync def analyze_data(data: list[float], ctx: Context) -> dict:\n    \"\"\"Analyze numerical data with logging.\"\"\"\n    await ctx.debug(\"Starting analysis of numerical data\")\n    await ctx.info(f\"Analyzing {len(data)} data points\")\n    \n    try:\n        result = sum(data) \/ len(data)\n        await ctx.info(f\"Analysis complete, average: {result}\")\n        return {\"average\": result, \"count\": len(data)}\n    except ZeroDivisionError:\n        await ctx.warning(\"Empty data list provided\")\n        return {\"error\": \"Empty data list\"}\n    except Exception as e:\n        await ctx.error(f\"Analysis failed: {str(e)}\")\n        raise\n```\n\n**Available Logging Methods:**\n\n* **`ctx.debug(message: str)`**: Low-level details useful for debugging\n* **`ctx.info(message: str)`**: General information about execution\n* **`ctx.warning(message: str)`**: Potential issues that didn't prevent execution\n* **`ctx.error(message: str)`**: Errors that occurred during execution\n* **`ctx.log(level: Literal[\"debug\", \"info\", \"warning\", \"error\"], message: str, logger_name: str | None = None)`**: Generic log method supporting custom logger names\n\n### Progress Reporting\n\nFor long-running operations, notify the client about the progress. This allows clients to display progress indicators and provide a better user experience.\n\n```python\n@mcp.tool()\nasync def process_items(items: list[str], ctx: Context) -> dict:\n    \"\"\"Process a list of items with progress updates.\"\"\"\n    total = len(items)\n    results = []\n    \n    for i, item in enumerate(items):\n        # Report progress as percentage\n        await ctx.report_progress(progress=i, total=total)\n        \n        # Process the item (simulated with a sleep)\n        await asyncio.sleep(0.1)\n        results.append(item.upper())\n    \n    # Report 100% completion\n    await ctx.report_progress(progress=total, total=total)\n    \n    return {\"processed\": len(results), \"results\": results}\n```\n\n**Method signature:**\n\n* **`ctx.report_progress(progress: float, total: float | None = None)`**\n  * `progress`: Current progress value (e.g., 24)\n  * `total`: Optional total value (e.g., 100). If provided, clients may interpret this as a percentage.\n\nProgress reporting requires the client to have sent a `progressToken` in the initial request. If the client doesn't support progress reporting, these calls will have no effect.\n\n### Resource Access\n\nRead data from resources registered with your FastMCP server. This allows functions to access files, configuration, or dynamically generated content.\n\n```python\n@mcp.tool()\nasync def summarize_document(document_uri: str, ctx: Context) -> str:\n    \"\"\"Summarize a document by its resource URI.\"\"\"\n    # Read the document content\n    content_list = await ctx.read_resource(document_uri)\n    \n    if not content_list:\n        return \"Document is empty\"\n    \n    document_text = content_list[0].content\n    \n    # Example: Generate a simple summary (length-based)\n    words = document_text.split()\n    total_words = len(words)\n    \n    await ctx.info(f\"Document has {total_words} words\")\n    \n    # Return a simple summary\n    if total_words > 100:\n        summary = \" \".join(words[:100]) + \"...\"\n        return f\"Summary ({total_words} words total): {summary}\"\n    else:\n        return f\"Full document ({total_words} words): {document_text}\"\n```\n\n**Method signature:**\n\n* **`ctx.read_resource(uri: str | AnyUrl) -> list[ReadResourceContents]`**\n  * `uri`: The resource URI to read\n  * Returns a list of resource content parts (usually containing just one item)\n\nThe returned content is typically accessed via `content_list[0].content` and can be text or binary data depending on the resource.\n\n### LLM Sampling\n\n<VersionBadge version=\"2.0.0\" \/>\n\nRequest the client's LLM to generate text based on provided messages. This is useful when your function needs to leverage the LLM's capabilities to process data or generate responses.\n\n```python\n@mcp.tool()\nasync def analyze_sentiment(text: str, ctx: Context) -> dict:\n    \"\"\"Analyze the sentiment of a text using the client's LLM.\"\"\"\n    # Create a sampling prompt asking for sentiment analysis\n    prompt = f\"Analyze the sentiment of the following text as positive, negative, or neutral. Just output a single word - 'positive', 'negative', or 'neutral'. Text to analyze: {text}\"\n    \n    # Send the sampling request to the client's LLM (provide a hint for the model you want to use)\n    response = await ctx.sample(prompt, model_preferences=\"claude-3-sonnet\")\n    \n    # Process the LLM's response\n    sentiment = response.text.strip().lower()\n    \n    # Map to standard sentiment values\n    if \"positive\" in sentiment:\n        sentiment = \"positive\"\n    elif \"negative\" in sentiment:\n        sentiment = \"negative\"\n    else:\n        sentiment = \"neutral\"\n    \n    return {\"text\": text, \"sentiment\": sentiment}\n```\n\n**Method signature:**\n\n* **`ctx.sample(messages: str | list[str | SamplingMessage], system_prompt: str | None = None, temperature: float | None = None, max_tokens: int | None = None, model_preferences: ModelPreferences | str | list[str] | None = None) -> TextContent | ImageContent`**\n  * `messages`: A string or list of strings\/message objects to send to the LLM\n  * `system_prompt`: Optional system prompt to guide the LLM's behavior\n  * `temperature`: Optional sampling temperature (controls randomness)\n  * `max_tokens`: Optional maximum number of tokens to generate (defaults to 512)\n  * `model_preferences`: Optional model selection preferences (e.g., a model hint string, list of hints, or a ModelPreferences object)\n  * Returns the LLM's response as TextContent or ImageContent\n\nWhen providing a simple string, it's treated as a user message. For more complex scenarios, you can provide a list of messages with different roles.\n\n````python\n@mcp.tool()\nasync def generate_example(concept: str, ctx: Context) -> str:\n    \"\"\"Generate a Python code example for a given concept.\"\"\"\n    # Using a system prompt and a user message\n    response = await ctx.sample(\n        messages=f\"Write a simple Python code example demonstrating '{concept}'.\",\n        system_prompt=\"You are an expert Python programmer. Provide concise, working code examples without explanations.\",\n        temperature=0.7,\n        max_tokens=300\n    )\n    \n    code_example = response.text\n    return f\"```python\\n{code_example}\\n```\"\n````\n\nSee [Client Sampling](\/clients\/client#llm-sampling) for more details on how clients handle these requests.\n\n### Request Information\n\nAccess metadata about the current request and client.\n\n```python\n@mcp.tool()\nasync def request_info(ctx: Context) -> dict:\n    \"\"\"Return information about the current request.\"\"\"\n    return {\n        \"request_id\": ctx.request_id,\n        \"client_id\": ctx.client_id or \"Unknown client\"\n    }\n```\n\n**Available Properties:**\n\n* **`ctx.request_id -> str`**: Get the unique ID for the current MCP request\n* **`ctx.client_id -> str | None`**: Get the ID of the client making the request, if provided during initialization\n\n### Advanced Access\n\n#### FastMCP Server and Sessions\n\n```python\n@mcp.tool()\nasync def advanced_tool(ctx: Context) -> str:\n    \"\"\"Demonstrate advanced context access.\"\"\"\n    # Access the FastMCP server instance\n    server_name = ctx.fastmcp.name\n    \n    # Low-level session access (rarely needed)\n    session = ctx.session\n    request_context = ctx.request_context\n    \n    return f\"Server: {server_name}\"\n```\n\n#### HTTP Requests\n\n<VersionBadge version=\"2.2.7\" \/>\n\n<Warning>\n  The `ctx.get_http_request()` method is deprecated and will be removed in a future version.\n  Please use the `get_http_request()` dependency function instead.\n  See the [HTTP Requests pattern](\/patterns\/http-requests) for more details.\n<\/Warning>\n\nFor web applications, you can access the underlying HTTP request:\n\n```python\n@mcp.tool()\nasync def handle_web_request(ctx: Context) -> dict:\n    \"\"\"Access HTTP request information from the Starlette request.\"\"\"\n    request = ctx.get_http_request()\n    \n    # Access HTTP headers, query parameters, etc.\n    user_agent = request.headers.get(\"user-agent\", \"Unknown\")\n    client_ip = request.client.host if request.client else \"Unknown\"\n    \n    return {\n        \"user_agent\": user_agent,\n        \"client_ip\": client_ip,\n        \"path\": request.url.path,\n    }\n```\n\n#### Advanced Properties Reference\n\n* **`ctx.fastmcp -> FastMCP`**: Access the server instance the context belongs to\n* **`ctx.session`**: Access the raw `mcp.server.session.ServerSession` object\n* **`ctx.request_context`**: Access the raw `mcp.shared.context.RequestContext` object\n\n<Warning>\n  Direct use of `session` or `request_context` requires understanding the low-level MCP Python SDK and may be less stable than using the methods provided directly on the `Context` object.\n<\/Warning>\n\n\n# The FastMCP Server\nSource: https:\/\/gofastmcp.com\/servers\/fastmcp\n\nLearn about the core FastMCP server class and how to run it.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nThe central piece of a FastMCP application is the `FastMCP` server class. This class acts as the main container for your application's tools, resources, and prompts, and manages communication with MCP clients.\n\n## Creating a Server\n\nInstantiating a server is straightforward. You typically provide a name for your server, which helps identify it in client applications or logs.\n\n```python\nfrom fastmcp import FastMCP\n\n# Create a basic server instance\nmcp = FastMCP(name=\"MyAssistantServer\")\n\n# You can also add instructions for how to interact with the server\nmcp_with_instructions = FastMCP(\n    name=\"HelpfulAssistant\",\n    instructions=\"\"\"\n        This server provides data analysis tools.\n        Call get_average() to analyze numerical data.\n        \"\"\"\n)\n```\n\nThe `FastMCP` constructor accepts several arguments:\n\n* `name`: (Optional) A human-readable name for your server. Defaults to \"FastMCP\".\n* `instructions`: (Optional) Description of how to interact with this server. These instructions help clients understand the server's purpose and available functionality.\n* `lifespan`: (Optional) An async context manager function for server startup and shutdown logic.\n* `tags`: (Optional) A set of strings to tag the server itself.\n* `**settings`: Keyword arguments corresponding to additional `ServerSettings` configuration\n\n## Components\n\nFastMCP servers expose several types of components to the client:\n\n### Tools\n\nTools are functions that the client can call to perform actions or access external systems.\n\n```python\n@mcp.tool()\ndef multiply(a: float, b: float) -> float:\n    \"\"\"Multiplies two numbers together.\"\"\"\n    return a * b\n```\n\nSee [Tools](\/servers\/tools) for detailed documentation.\n\n### Resources\n\nResources expose data sources that the client can read.\n\n```python\n@mcp.resource(\"data:\/\/config\")\ndef get_config() -> dict:\n    \"\"\"Provides the application configuration.\"\"\"\n    return {\"theme\": \"dark\", \"version\": \"1.0\"}\n```\n\nSee [Resources & Templates](\/servers\/resources) for detailed documentation.\n\n### Resource Templates\n\nResource templates are parameterized resources that allow the client to request specific data.\n\n```python\n@mcp.resource(\"users:\/\/{user_id}\/profile\")\ndef get_user_profile(user_id: int) -> dict:\n    \"\"\"Retrieves a user's profile by ID.\"\"\"\n    # The {user_id} in the URI is extracted and passed to this function\n    return {\"id\": user_id, \"name\": f\"User {user_id}\", \"status\": \"active\"}\n```\n\nSee [Resources & Templates](\/servers\/resources) for detailed documentation.\n\n### Prompts\n\nPrompts are reusable message templates for guiding the LLM.\n\n```python\n@mcp.prompt()\ndef analyze_data(data_points: list[float]) -> str:\n    \"\"\"Creates a prompt asking for analysis of numerical data.\"\"\"\n    formatted_data = \", \".join(str(point) for point in data_points)\n    return f\"Please analyze these data points: {formatted_data}\"\n```\n\nSee [Prompts](\/servers\/prompts) for detailed documentation.\n\n## Running the Server\n\nFastMCP servers need a transport mechanism to communicate with clients. You typically start your server by calling the `mcp.run()` method on your `FastMCP` instance, often within an `if __name__ == \"__main__\":` block in your main server script. This pattern ensures compatibility with various MCP clients.\n\n```python\n# my_server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"MyServer\")\n\n@mcp.tool()\ndef greet(name: str) -> str:\n    \"\"\"Greet a user by name.\"\"\"\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    # This runs the server, defaulting to STDIO transport\n    mcp.run()\n    \n    # To use a different transport, e.g., HTTP:\n    # mcp.run(transport=\"streamable-http\", host=\"127.0.0.1\", port=9000)\n```\n\nFastMCP supports several transport options:\n\n* STDIO (default, for local tools)\n* Streamable HTTP (recommended for web services)\n* SSE (legacy web transport, deprecated)\n\nThe server can also be run using the FastMCP CLI.\n\nFor detailed information on each transport, how to configure them (host, port, paths), and when to use which, please refer to the [**Running Your FastMCP Server**](\/deployment\/running-server) guide.\n\n## Composing Servers\n\n<VersionBadge version=\"2.2.0\" \/>\n\nFastMCP supports composing multiple servers together using `import_server` (static copy) and `mount` (live link). This allows you to organize large applications into modular components or reuse existing servers.\n\nSee the [Server Composition](\/patterns\/composition) guide for full details, best practices, and examples.\n\n```python\n# Example: Importing a subserver\nfrom fastmcp import FastMCP\nimport asyncio\n\nmain = FastMCP(name=\"Main\")\nsub = FastMCP(name=\"Sub\")\n\n@sub.tool()\ndef hello(): \n    return \"hi\"\n\n# Mount directly\nmain.mount(\"sub\", sub)\n```\n\n## Proxying Servers\n\n<VersionBadge version=\"2.0.0\" \/>\n\nFastMCP can act as a proxy for any MCP server (local or remote) using `FastMCP.as_proxy`, letting you bridge transports or add a frontend to existing servers. For example, you can expose a remote SSE server locally via stdio, or vice versa.\n\nSee the [Proxying Servers](\/patterns\/proxy) guide for details and advanced usage.\n\n```python\nfrom fastmcp import FastMCP, Client\n\nbackend = Client(\"http:\/\/example.com\/mcp\/sse\")\nproxy = FastMCP.as_proxy(backend, name=\"ProxyServer\")\n# Now use the proxy like any FastMCP server\n```\n\n## Server Configuration\n\nServer behavior, like transport settings (host, port for SSE) and how duplicate components are handled, can be configured via `ServerSettings`. These settings can be passed during `FastMCP` initialization, set via environment variables (prefixed with `FASTMCP_SERVER_`), or loaded from a `.env` file.\n\n```python\nfrom fastmcp import FastMCP\n\n# Configure during initialization\nmcp = FastMCP(\n    name=\"ConfiguredServer\",\n    port=8080, # Directly maps to ServerSettings\n    on_duplicate_tools=\"error\" # Set duplicate handling\n)\n\n# Settings are accessible via mcp.settings\nprint(mcp.settings.port) # Output: 8080\nprint(mcp.settings.on_duplicate_tools) # Output: \"error\"\n```\n\n### Key Configuration Options\n\n* **`host`**: Host address for SSE transport (default: \"127.0.0.1\")\n* **`port`**: Port number for SSE transport (default: 8000)\n* **`log_level`**: Logging level (default: \"INFO\")\n* **`on_duplicate_tools`**: How to handle duplicate tool registrations\n* **`on_duplicate_resources`**: How to handle duplicate resource registrations\n* **`on_duplicate_prompts`**: How to handle duplicate prompt registrations\n\nAll of these can be configured directly as parameters when creating the `FastMCP` instance.\n\n### Custom Tool Serialization\n\n<VersionBadge version=\"2.2.7\" \/>\n\nBy default, FastMCP serializes tool return values to JSON when they need to be converted to text. You can customize this behavior by providing a `tool_serializer` function when creating your server:\n\n```python\nimport yaml\nfrom fastmcp import FastMCP\n\n# Define a custom serializer that formats dictionaries as YAML\ndef yaml_serializer(data):\n    return yaml.dump(data, sort_keys=False)\n\n# Create a server with the custom serializer\nmcp = FastMCP(name=\"MyServer\", tool_serializer=yaml_serializer)\n\n@mcp.tool()\ndef get_config():\n    \"\"\"Returns configuration in YAML format.\"\"\"\n    return {\"api_key\": \"abc123\", \"debug\": True, \"rate_limit\": 100}\n```\n\nThe serializer function takes any data object and returns a string representation. This is applied to **all non-string return values** from your tools. Tools that already return strings bypass the serializer.\n\nThis customization is useful when you want to:\n\n* Format data in a specific way (like YAML or custom formats)\n* Control specific serialization options (like indentation or sorting)\n* Add metadata or transform data before sending it to clients\n\n<Tip>\n  If the serializer function raises an exception, the tool will fall back to the default JSON serialization to avoid breaking the server.\n<\/Tip>\n\n## Authentication\n\n<VersionBadge version=\"2.2.7\" \/>\n\nFastMCP supports OAuth 2.0 authentication, allowing servers to protect their tools and resources. This is configured by providing an `auth_server_provider` and `auth` settings during `FastMCP` initialization.\n\n```python\nfrom fastmcp import FastMCP\nfrom mcp.server.auth.settings import AuthSettings #, ... other auth imports\n# from your_auth_implementation import MyOAuthServerProvider # Placeholder\n\n# Create a server with authentication (conceptual example)\n# mcp = FastMCP(\n#     name=\"SecureApp\",\n#     auth_server_provider=MyOAuthServerProvider(),\n#     auth=AuthSettings(\n#         issuer_url=\"https:\/\/myapp.com\",\n#         # ... other OAuth settings ...\n#         required_scopes=[\"myscope\"],\n#     ),\n# )\n```\n\nDue to the low-level nature of the current MCP SDK's auth provider interface, detailed implementation is beyond a quick example. Refer to the [MCP SDK documentation](https:\/\/modelcontextprotocol.io\/specification\/2025-03-26\/basic\/authorization) for specifics on implementing an `OAuthAuthorizationServerProvider`. FastMCP integrates with this by passing the provider and settings to the underlying MCP server.\n\nA dedicated [Authentication guide](\/deployment\/authentication) will cover this in more detail once higher-level abstractions are available in FastMCP.\n\n\n# OpenAPI Integration\nSource: https:\/\/gofastmcp.com\/servers\/openapi\n\nGenerate MCP servers from OpenAPI specs and FastAPI apps\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.0.0\" \/>\n\nFastMCP can automatically generate an MCP server from an OpenAPI specification or FastAPI app. Instead of manually creating tools and resources, you provide an OpenAPI spec and FastMCP intelligently converts your API endpoints into the appropriate MCP components.\n\n## Quick Start\n\nTo convert an OpenAPI specification to an MCP server, you can use the `FastMCP.from_openapi` class method. This method takes an OpenAPI specification and an async HTTPX client that can be used to make requests to the API, and returns an MCP server.\n\nHere's an example:\n\n```python {11-15}\nimport httpx\nfrom fastmcp import FastMCP\n\n# Create an HTTP client for your API\nclient = httpx.AsyncClient(base_url=\"https:\/\/api.example.com\")\n\n# Load your OpenAPI spec \nopenapi_spec = httpx.get(\"https:\/\/api.example.com\/openapi.json\").json()\n\n# Create the MCP server\nmcp = FastMCP.from_openapi(\n    openapi_spec=openapi_spec,\n    client=client,\n    name=\"My API Server\"\n)\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\nThat's it! Your entire API is now available as an MCP server. Clients can discover and interact with your API endpoints through the MCP protocol, with full schema validation and type safety.\n\n## Route Mapping\n\nFastMCP analyzes your API specification and automatically creates MCP components based on HTTP semantics and REST conventions. By default, the following rules are used to determine what MCP component to create for each route:\n\n| OpenAPI Route                          | Example           | MCP Component         |\n| -------------------------------------- | ----------------- | --------------------- |\n| `GET` with path params                 | `GET \/users\/{id}` | **Resource Template** |\n| `GET` without path params              | `GET \/stats`      | **Resource**          |\n| `POST`, `PUT`, `PATCH`, `DELETE`, etc. | `POST \/users`     | **Tool**              |\n\n### Custom Route Maps\n\n<VersionBadge version=\"2.5.0\" \/>\n\nFastMCP uses an ordered list of `RouteMap` objects to determine how to map OpenAPI routes to various MCP component types.\n\nEach `RouteMap` specifies a combination of methods, patterns, and tags, as well as a corresponding MCP component type. Each OpenAPI route is checked against each `RouteMap` in order, and the first one that matches every criteria is used to determine its converted MCP type. A special type, `EXCLUDE`, can be used to exclude routes from the MCP server entirely.\n\n* **Methods**: HTTP methods to match (e.g. `[\"GET\", \"POST\"]` or `\"*\"` for all)\n* **Pattern**: Regex pattern to match the route path (e.g. `r\"^\/users\/.*\"` or `r\".*\"` for all)\n* **Tags**: A set of OpenAPI tags that must all be present. An empty set (`{}`) means no tag filtering, so the route matches regardless of its tags.\n* **MCP type**: What MCP component type to create (`TOOL`, `RESOURCE`, `RESOURCE_TEMPLATE`, or `EXCLUDE`)\n\nTo illustrate this in practice, here are FastMCP's default route mappings as a list of `RouteMap` objects:\n\n```python\nfrom fastmcp.server.openapi import RouteMap, MCPType\n\nDEFAULT_ROUTE_MAPPINGS = [\n\n    # GET with path parameters  ResourceTemplate\n    RouteMap(\n        methods=[\"GET\"], \n        pattern=r\".*\\{.*\\}.*\", \n        mcp_type=MCPType.RESOURCE_TEMPLATE\n    ),\n\n    # GET without path parameters  Resource\n    RouteMap(\n        methods=[\"GET\"], \n        pattern=r\".*\", \n        mcp_type=MCPType.RESOURCE\n    ),\n\n    # All other methods  Tool\n    RouteMap(\n        methods=[\"*\"], \n        pattern=r\".*\", \n        mcp_type=MCPType.TOOL\n    ),\n]\n```\n\n### Custom Route Maps\n\nWhen creating your FastMCP server, you can customize routing behavior by providing your own list of `RouteMap` objects. Your custom maps are processed before the default route maps, and routes will be assigned to the first matching custom map.\n\nFor example, the following simple rule will treat every OpenAPI route as a tool:\n\n```python {7}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.openapi import RouteMap, MCPType\n\nmcp = FastMCP.from_openapi(\n    ...,\n    route_maps=[\n        RouteMap(mcp_type=MCPType.TOOL),\n    ],\n)\n```\n\nHere is a more complete example that uses custom route maps to convert all `GET` endpoints under `\/analytics\/` to tools while excluding all admin endpoints and all routes tagged \"internal\". All other routes will be handled by the default rules:\n\n```python\nfrom fastmcp import FastMCP\nfrom fastmcp.server.openapi import RouteMap, MCPType\n\nmcp = FastMCP.from_openapi(\n    ...,\n    route_maps=[\n\n        # Analytics `GET` endpoints are tools\n        RouteMap(\n            methods=[\"GET\"], \n            pattern=r\"^\/analytics\/.*\", \n            mcp_type=MCPType.TOOL,\n        ),\n\n        # Exclude all admin endpoints\n        RouteMap(\n            pattern=r\"^\/admin\/.*\", \n            mcp_type=MCPType.EXCLUDE,\n        ),\n\n        # Exclude all routes tagged \"internal\"\n        RouteMap(\n            tags={\"internal\"},\n            mcp_type=MCPType.EXCLUDE,\n        ),\n    ],\n)\n```\n\n<Tip>\n  The default route maps are always applied after your custom maps, so you do not have to create route maps for every possible route.\n<\/Tip>\n\n### Excluding Routes\n\nTo exclude routes from the MCP server, use a route map to assign them to `MCPType.EXCLUDE`.\n\nYou can use this to remove sensitive or internal routes by targeting them specifically:\n\n```python {7,8}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.openapi import RouteMap, MCPType\n\nmcp = FastMCP.from_openapi(\n    ...,\n    route_maps=[\n        RouteMap(pattern=r\"^\/admin\/.*\", mcp_type=MCPType.EXCLUDE),\n        RouteMap(tags={\"internal\"}, mcp_type=MCPType.EXCLUDE),\n    ],\n)\n```\n\nOr you can use a catch-all rule to exclude everything that your maps don't handle explicitly:\n\n```python {10}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.openapi import RouteMap, MCPType\n\nmcp = FastMCP.from_openapi(\n    ...,\n    route_maps=[\n        # custom mapping logic goes here\n        ...,\n        # exclude all remaining routes\n        RouteMap(mcp_type=MCPType.EXCLUDE),\n    ],\n)\n```\n\n<Tip>\n  Using a catch-all exclusion rule will prevent the default route mappings from being applied, since it will match every remaining route. This is useful if you want to explicitly allow-list certain routes.\n<\/Tip>\n\n### Advanced Route Mapping\n\n<VersionBadge version=\"2.5.0\" \/>\n\nFor advanced use cases that require more complex logic, you can provide a `route_map_fn` callable. After the route map logic is applied, this function is called on each matched route and its assigned MCP component type. It can optionally return a different component type to override the mapped assignment. If it returns `None`, the assigned type is used.\n\nIn addition to more precise targeting of methods, patterns, and tags, this function can access any additional OpenAPI metadata about the route.\n\n<Tip>\n  The `route_map_fn` **is** called on routes that matched `MCPType.EXCLUDE` in your custom maps, giving you an opportunity to override the exclusion.\n<\/Tip>\n\n```python\nfrom fastmcp import FastMCP\nfrom fastmcp.server.openapi import RouteMap, MCPType, HTTPRoute\n\ndef custom_route_mapper(route: HTTPRoute, mcp_type: MCPType) -> MCPType | None:\n    \"\"\"Advanced route type mapping.\"\"\"\n    # Convert all admin routes to tools regardless of HTTP method\n    if \"\/admin\/\" in route.path:\n        return MCPType.TOOL\n\n    elif \"internal\" in route.tags:\n        return MCPType.EXCLUDE\n    \n    # Convert user detail routes to templates even if they're POST\n    elif route.path.startswith(\"\/users\/\") and route.method == \"POST\":\n        return MCPType.RESOURCE_TEMPLATE\n    \n    # Use defaults for all other routes\n    return None\n\nmcp = FastMCP.from_openapi(\n    ...,\n    route_map_fn=custom_route_mapper,\n)\n```\n\n## Customizing MCP Components\n\n<VersionBadge version=\"2.5.0\" \/>\n\nBy default, FastMCP creates MCP components using a variety of metadata from the OpenAPI spec, such as incorporating the OpenAPI description into the MCP component description.\n\nAt times you may want to modify those MCP components in a variety of ways, such as adding LLM-specific instructions or tags. For fine-grained customization, you can provide a `mcp_component_fn` when creating the MCP server. After each MCP component has been created, this function is called on it and has the opportunity to modify it in-place.\n\n<Tip>\n  Your `mcp_component_fn` is expected to modify the component in-place, not to return a new component. The result of the function is ignored.\n<\/Tip>\n\n```python {27}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.openapi import (\n    HTTPRoute, \n    OpenAPITool, \n    OpenAPIResource, \n    OpenAPIResourceTemplate,\n)\n\ndef customize_components(\n    route: HTTPRoute, \n    component: OpenAPITool | OpenAPIResource | OpenAPIResourceTemplate,\n) -> None:\n    \n    # Add custom tags to all components\n    component.tags.add(\"openapi\")\n    \n    # Customize based on component type\n    if isinstance(component, OpenAPITool):\n        component.description = f\" {component.description} (via API)\"\n    \n    if isinstance(component, OpenAPIResource):\n        component.description = f\" {component.description}\"\n        component.tags.add(\"data\")\n\nmcp = FastMCP.from_openapi(\n    ...,\n    mcp_component_fn=customize_components,\n)\n```\n\n## Request Parameter Handling\n\nFastMCP intelligently handles different types of parameters in OpenAPI requests:\n\n### Query Parameters\n\nBy default, FastMCP only includes query parameters that have non-empty values. Parameters with `None` values or empty strings are automatically filtered out.\n\n```python\n# When calling this tool...\nawait client.call_tool(\"search_products\", {\n    \"category\": \"electronics\",  #  Included\n    \"min_price\": 100,           #  Included  \n    \"max_price\": None,          #  Excluded\n    \"brand\": \"\",                #  Excluded\n})\n\n# The HTTP request will be: GET \/products?category=electronics&min_price=100\n```\n\n### Path Parameters\n\nPath parameters are typically required by REST APIs. FastMCP:\n\n* Filters out `None` values\n* Validates that all required path parameters are provided\n* Raises clear errors for missing required parameters\n\n```python\n#  This works\nawait client.call_tool(\"get_user\", {\"user_id\": 123})\n\n#  This raises: \"Missing required path parameters: {'user_id'}\"\nawait client.call_tool(\"get_user\", {\"user_id\": None})\n```\n\n### Array Parameters\n\nFastMCP handles array parameters according to OpenAPI specifications:\n\n* **Query arrays**: Serialized based on the `explode` parameter (default: `True`)\n* **Path arrays**: Serialized as comma-separated values (OpenAPI 'simple' style)\n\n```python\n# Query array with explode=true (default)\n# ?tags=red&tags=blue&tags=green\n\n# Query array with explode=false  \n# ?tags=red,blue,green\n\n# Path array (always comma-separated)\n# \/items\/red,blue,green\n```\n\n### Headers\n\nHeader parameters are automatically converted to strings and included in the HTTP request.\n\n## Auth\n\nIf your API requires authentication, configure it on the HTTP client before creating the MCP server:\n\n```python\nimport httpx\nfrom fastmcp import FastMCP\n\n# Bearer token authentication\napi_client = httpx.AsyncClient(\n    base_url=\"https:\/\/api.example.com\",\n    headers={\"Authorization\": \"Bearer YOUR_TOKEN\"}\n)\n\n# Create MCP server with authenticated client\nmcp = FastMCP.from_openapi(..., client=api_client)\n```\n\n## Timeouts\n\nSet a timeout for all API requests:\n\n```python\nmcp = FastMCP.from_openapi(\n    openapi_spec=spec, \n    client=api_client,\n    timeout=30.0  # 30 second timeout for all requests\n)\n```\n\n## FastAPI Integration\n\n<VersionBadge version=\"2.0.0\" \/>\n\nFastMCP can directly convert FastAPI applications into MCP servers by extracting their OpenAPI specifications:\n\n<Tip>\n  FastMCP does *not* include FastAPI as a dependency; you must install it separately to use this integration.\n<\/Tip>\n\n```python\nfrom fastapi import FastAPI\nfrom fastmcp import FastMCP\n\n# Your FastAPI app\napp = FastAPI(title=\"My API\", version=\"1.0.0\")\n\n@app.get(\"\/items\", tags=[\"items\"])\ndef list_items():\n    return [{\"id\": 1, \"name\": \"Item 1\"}, {\"id\": 2, \"name\": \"Item 2\"}]\n\n@app.get(\"\/items\/{item_id}\", tags=[\"items\", \"detail\"])\ndef get_item(item_id: int):\n    return {\"id\": item_id, \"name\": f\"Item {item_id}\"}\n\n@app.post(\"\/items\", tags=[\"items\", \"create\"])\ndef create_item(name: str):\n    return {\"id\": 3, \"name\": name}\n\n# Convert FastAPI app to MCP server\nmcp = FastMCP.from_fastapi(app=app)\n\nif __name__ == \"__main__\":\n    mcp.run()  # Run as MCP server\n```\n\n<Warning>\n  FastMCP servers are not FastAPI apps, even when created from one. To learn how to deploy them as an ASGI app, see the [ASGI Integration](\/deployment\/asgi) documentation.\n<\/Warning>\n\n### FastAPI Configuration\n\nAll OpenAPI integration features work with FastAPI apps:\n\n```python\nfrom fastmcp.server.openapi import RouteMap, MCPType\n\n# Custom route mapping with FastAPI\nmcp = FastMCP.from_fastapi(\n    app=app,\n    name=\"My Custom Server\",\n    timeout=5.0,\n    route_maps=[\n        # Admin endpoints become tools\n        RouteMap(methods=\"*\", pattern=r\"^\/admin\/.*\", mcp_type=MCPType.TOOL),\n        # Internal endpoints are excluded\n        RouteMap(methods=\"*\", pattern=r\".*\", mcp_type=MCPType.EXCLUDE, tags={\"internal\"}),\n    ],\n    route_map_fn=my_route_mapper,\n    mcp_component_fn=my_component_customizer,\n)\n```\n\n### FastAPI Benefits\n\n* **Zero code duplication**: Reuse existing FastAPI endpoints\n* **Schema inheritance**: Pydantic models and validation are preserved\n* **ASGI transport**: Direct in-memory communication (no HTTP overhead)\n* **Full FastAPI features**: Dependencies, middleware, authentication all work\n\n\n# Prompts\nSource: https:\/\/gofastmcp.com\/servers\/prompts\n\nCreate reusable, parameterized prompt templates for MCP clients.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nPrompts are reusable message templates that help LLMs generate structured, purposeful responses. FastMCP simplifies defining these templates, primarily using the `@mcp.prompt` decorator.\n\n## What Are Prompts?\n\nPrompts provide parameterized message templates for LLMs. When a client requests a prompt:\n\n1. FastMCP finds the corresponding prompt definition.\n2. If it has parameters, they are validated against your function signature.\n3. Your function executes with the validated inputs.\n4. The generated message(s) are returned to the LLM to guide its response.\n\nThis allows you to define consistent, reusable templates that LLMs can use across different clients and contexts.\n\n## Prompts\n\n### The `@prompt` Decorator\n\nThe most common way to define a prompt is by decorating a Python function. The decorator uses the function name as the prompt's identifier.\n\n```python\nfrom fastmcp import FastMCP\nfrom fastmcp.prompts.prompt import Message, PromptMessage, TextContent\n\nmcp = FastMCP(name=\"PromptServer\")\n\n# Basic prompt returning a string (converted to user message automatically)\n@mcp.prompt()\ndef ask_about_topic(topic: str) -> str:\n    \"\"\"Generates a user message asking for an explanation of a topic.\"\"\"\n    return f\"Can you please explain the concept of '{topic}'?\"\n\n# Prompt returning a specific message type\n@mcp.prompt()\ndef generate_code_request(language: str, task_description: str) -> PromptMessage:\n    \"\"\"Generates a user message requesting code generation.\"\"\"\n    content = f\"Write a {language} function that performs the following task: {task_description}\"\n    return PromptMessage(role=\"user\", content=TextContent(type=\"text\", text=content))\n```\n\n**Key Concepts:**\n\n* **Name:** By default, the prompt name is taken from the function name.\n* **Parameters:** The function parameters define the inputs needed to generate the prompt.\n* **Inferred Metadata:** By default:\n  * Prompt Name: Taken from the function name (`ask_about_topic`).\n  * Prompt Description: Taken from the function's docstring.\n\n<Tip>\n  Functions with `*args` or `**kwargs` are not supported as prompts. This restriction exists because FastMCP needs to generate a complete parameter schema for the MCP protocol, which isn't possible with variable argument lists.\n<\/Tip>\n\n### Return Values\n\nFastMCP intelligently handles different return types from your prompt function:\n\n* **`str`**: Automatically converted to a single `PromptMessage`.\n* **`PromptMessage`**: Used directly as provided. (Note a more user-friendly `Message` constructor is available that can accept raw strings instead of `TextContent` objects.)\n* **`list[PromptMessage | str]`**: Used as a sequence of messages (a conversation).\n* **`Any`**: If the return type is not one of the above, the return value is attempted to be converted to a string and used as a `PromptMessage`.\n\n```python\nfrom fastmcp.prompts.prompt import Message\n\n@mcp.prompt()\ndef roleplay_scenario(character: str, situation: str) -> list[Message]:\n    \"\"\"Sets up a roleplaying scenario with initial messages.\"\"\"\n    return [\n        Message(f\"Let's roleplay. You are {character}. The situation is: {situation}\"),\n        Message(\"Okay, I understand. I am ready. What happens next?\", role=\"assistant\")\n    ]\n```\n\n### Type Annotations\n\nType annotations are important for prompts. They:\n\n1. Inform FastMCP about the expected types for each parameter.\n2. Allow validation of parameters received from clients.\n3. Are used to generate the prompt's schema for the MCP protocol.\n\n```python\nfrom pydantic import Field\nfrom typing import Literal, Optional\n\n@mcp.prompt()\ndef generate_content_request(\n    topic: str = Field(description=\"The main subject to cover\"),\n    format: Literal[\"blog\", \"email\", \"social\"] = \"blog\",\n    tone: str = \"professional\",\n    word_count: Optional[int] = None\n) -> str:\n    \"\"\"Create a request for generating content in a specific format.\"\"\"\n    prompt = f\"Please write a {format} post about {topic} in a {tone} tone.\"\n    \n    if word_count:\n        prompt += f\" It should be approximately {word_count} words long.\"\n        \n    return prompt\n```\n\n### Required vs. Optional Parameters\n\nParameters in your function signature are considered **required** unless they have a default value.\n\n```python\n@mcp.prompt()\ndef data_analysis_prompt(\n    data_uri: str,                        # Required - no default value\n    analysis_type: str = \"summary\",       # Optional - has default value\n    include_charts: bool = False          # Optional - has default value\n) -> str:\n    \"\"\"Creates a request to analyze data with specific parameters.\"\"\"\n    prompt = f\"Please perform a '{analysis_type}' analysis on the data found at {data_uri}.\"\n    if include_charts:\n        prompt += \" Include relevant charts and visualizations.\"\n    return prompt\n```\n\nIn this example, the client *must* provide `data_uri`. If `analysis_type` or `include_charts` are omitted, their default values will be used.\n\n### Prompt Metadata\n\nWhile FastMCP infers the name and description from your function, you can override these and add tags using arguments to the `@mcp.prompt` decorator:\n\n```python\n@mcp.prompt(\n    name=\"analyze_data_request\",          # Custom prompt name\n    description=\"Creates a request to analyze data with specific parameters\",  # Custom description\n    tags={\"analysis\", \"data\"}             # Optional categorization tags\n)\ndef data_analysis_prompt(\n    data_uri: str = Field(description=\"The URI of the resource containing the data.\"),\n    analysis_type: str = Field(default=\"summary\", description=\"Type of analysis.\")\n) -> str:\n    \"\"\"This docstring is ignored when description is provided.\"\"\"\n    return f\"Please perform a '{analysis_type}' analysis on the data found at {data_uri}.\"\n```\n\n* **`name`**: Sets the explicit prompt name exposed via MCP.\n* **`description`**: Provides the description exposed via MCP. If set, the function's docstring is ignored for this purpose.\n* **`tags`**: A set of strings used to categorize the prompt. Clients *might* use tags to filter or group available prompts.\n\n### Asynchronous Prompts\n\nFastMCP seamlessly supports both standard (`def`) and asynchronous (`async def`) functions as prompts.\n\n```python\n# Synchronous prompt\n@mcp.prompt()\ndef simple_question(question: str) -> str:\n    \"\"\"Generates a simple question to ask the LLM.\"\"\"\n    return f\"Question: {question}\"\n\n# Asynchronous prompt\n@mcp.prompt()\nasync def data_based_prompt(data_id: str) -> str:\n    \"\"\"Generates a prompt based on data that needs to be fetched.\"\"\"\n    # In a real scenario, you might fetch data from a database or API\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"https:\/\/api.example.com\/data\/{data_id}\") as response:\n            data = await response.json()\n            return f\"Analyze this data: {data['content']}\"\n```\n\nUse `async def` when your prompt function performs I\/O operations like network requests, database queries, file I\/O, or external service calls.\n\n### Accessing MCP Context\n\n<VersionBadge version=\"2.2.5\" \/>\n\nPrompts can access additional MCP information and features through the `Context` object. To access it, add a parameter to your prompt function with a type annotation of `Context`:\n\n```python {6}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"PromptServer\")\n\n@mcp.prompt()\nasync def generate_report_request(report_type: str, ctx: Context) -> str:\n    \"\"\"Generates a request for a report.\"\"\"\n    return f\"Please create a {report_type} report. Request ID: {ctx.request_id}\"\n```\n\nFor full documentation on the Context object and all its capabilities, see the [Context documentation](\/servers\/context).\n\n## Server Behavior\n\n### Duplicate Prompts\n\n<VersionBadge version=\"2.1.0\" \/>\n\nYou can configure how the FastMCP server handles attempts to register multiple prompts with the same name. Use the `on_duplicate_prompts` setting during `FastMCP` initialization.\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"PromptServer\",\n    on_duplicate_prompts=\"error\"  # Raise an error if a prompt name is duplicated\n)\n\n@mcp.prompt()\ndef greeting(): return \"Hello, how can I help you today?\"\n\n# This registration attempt will raise a ValueError because\n# \"greeting\" is already registered and the behavior is \"error\".\n# @mcp.prompt()\n# def greeting(): return \"Hi there! What can I do for you?\"\n```\n\nThe duplicate behavior options are:\n\n* `\"warn\"` (default): Logs a warning, and the new prompt replaces the old one.\n* `\"error\"`: Raises a `ValueError`, preventing the duplicate registration.\n* `\"replace\"`: Silently replaces the existing prompt with the new one.\n* `\"ignore\"`: Keeps the original prompt and ignores the new registration attempt.\n\n\n# Proxy Servers\nSource: https:\/\/gofastmcp.com\/servers\/proxy\n\nUse FastMCP to act as an intermediary or change transport for other MCP servers.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\n<VersionBadge version=\"2.0.0\" \/>\n\nFastMCP provides a powerful proxying capability that allows one FastMCP server instance to act as a frontend for another MCP server (which could be remote, running on a different transport, or even another FastMCP instance). This is achieved using the `FastMCP.as_proxy()` class method.\n\n`as_proxy()` accepts either an existing `Client` or any argument that can be passed to a `Client` as its `transport` parametersuch as another `FastMCP` instance, a URL to a remote server, or an MCP configuration dictionary.\n\n## What is Proxying?\n\nProxying means setting up a FastMCP server that doesn't implement its own tools or resources directly. Instead, when it receives a request (like `tools\/call` or `resources\/read`), it forwards that request to a *backend* MCP server, receives the response, and then relays that response back to the original client.\n\n```mermaid\nsequenceDiagram\n    participant ClientApp as Your Client (e.g., Claude Desktop)\n    participant FastMCPProxy as FastMCP Proxy Server\n    participant BackendServer as Backend MCP Server (e.g., remote SSE)\n\n    ClientApp->>FastMCPProxy: MCP Request (e.g. stdio)\n    Note over FastMCPProxy, BackendServer: Proxy forwards the request\n    FastMCPProxy->>BackendServer: MCP Request (e.g. sse)\n    BackendServer-->>FastMCPProxy: MCP Response (e.g. sse)\n    Note over ClientApp, FastMCPProxy: Proxy relays the response\n    FastMCPProxy-->>ClientApp: MCP Response (e.g. stdio)\n```\n\n### Use Cases\n\n* **Transport Bridging**: Expose a server running on one transport (e.g., a remote SSE server) via a different transport (e.g., local Stdio for Claude Desktop).\n* **Adding Functionality**: Insert a layer in front of an existing server to add caching, logging, authentication, or modify requests\/responses (though direct modification requires subclassing `FastMCPProxy`).\n* **Security Boundary**: Use the proxy as a controlled gateway to an internal server.\n* **Simplifying Client Configuration**: Provide a single, stable endpoint (the proxy) even if the backend server's location or transport changes.\n\n## Creating a Proxy\n\nThe easiest way to create a proxy is using the `FastMCP.as_proxy()` class method. This creates a standard FastMCP server that forwards requests to another MCP server.\n\n```python\nfrom fastmcp import FastMCP\n\n# Provide the backend in any form accepted by Client\nproxy_server = FastMCP.as_proxy(\n    \"backend_server.py\",  # Could also be a FastMCP instance, config dict, or a remote URL\n    name=\"MyProxyServer\"  # Optional settings for the proxy\n)\n\n# Or create the Client yourself for custom configuration\nbackend_client = Client(\"backend_server.py\")\nproxy_from_client = FastMCP.as_proxy(backend_client)\n```\n\n**How `as_proxy` Works:**\n\n1. It connects to the backend server using the provided client.\n2. It discovers all the tools, resources, resource templates, and prompts available on the backend server.\n3. It creates corresponding \"proxy\" components that forward requests to the backend.\n4. It returns a standard `FastMCP` server instance that can be used like any other.\n\n<Note>\n  Currently, proxying focuses primarily on exposing the major MCP objects (tools, resources, templates, and prompts). Some advanced MCP features like notifications and sampling are not fully supported in proxies in the current version. Support for these additional features may be added in future releases.\n<\/Note>\n\n### Bridging Transports\n\nA common use case is to bridge transports. For example, making a remote SSE server available locally via Stdio:\n\n```python\nfrom fastmcp import FastMCP\n\n# Target a remote SSE server directly by URL\nproxy = FastMCP.as_proxy(\"http:\/\/example.com\/mcp\/sse\", name=\"SSE to Stdio Proxy\")\n\n# The proxy can now be used with any transport\n# No special handling needed - it works like any FastMCP server\n```\n\n### In-Memory Proxies\n\nYou can also proxy an in-memory `FastMCP` instance, which is useful for adjusting the configuration or behavior of a server you don't completely control.\n\n```python\nfrom fastmcp import FastMCP\n\n# Original server\noriginal_server = FastMCP(name=\"Original\")\n\n@original_server.tool()\ndef tool_a() -> str: \n    return \"A\"\n\n# Create a proxy of the original server directly\nproxy = FastMCP.as_proxy(\n    original_server,\n    name=\"Proxy Server\"\n)\n\n# proxy is now a regular FastMCP server that forwards\n# requests to original_server\n```\n\n### Configuration-Based Proxies\n\n<VersionBadge version=\"2.4.0\" \/>\n\nYou can create a proxy directly from a configuration dictionary that follows the MCPConfig schema. This is useful for quickly setting up proxies to remote servers without manually configuring each connection detail.\n\n```python\nfrom fastmcp import FastMCP\n\n# Create a proxy directly from a config dictionary\nconfig = {\n    \"mcpServers\": {\n        \"default\": {  # For single server configs, 'default' is commonly used\n            \"url\": \"https:\/\/example.com\/mcp\",\n            \"transport\": \"streamable-http\"\n        }\n    }\n}\n\n# Create a proxy to the configured server\nproxy = FastMCP.as_proxy(config, name=\"Config-Based Proxy\")\n\n# Run the proxy with stdio transport for local access\nif __name__ == \"__main__\":\n    proxy.run()\n```\n\n<Note>\n  The MCPConfig format follows an emerging standard for MCP server configuration and may evolve as the specification matures. While FastMCP aims to maintain compatibility with future versions, be aware that field names or structure might change.\n<\/Note>\n\nYou can also use MCPConfig to create a proxy to multiple servers. When multiple servers are specified, they are automatically mounted with their config names as prefixes, providing a unified interface to all servers:\n\n```python\nfrom fastmcp import FastMCP\n\n# Multi-server configuration\nconfig = {\n    \"mcpServers\": {\n        \"weather\": {\n            \"url\": \"https:\/\/weather-api.example.com\/mcp\",\n            \"transport\": \"streamable-http\"\n        },\n        \"calendar\": {\n            \"url\": \"https:\/\/calendar-api.example.com\/mcp\",\n            \"transport\": \"streamable-http\"\n        }\n    }\n}\n\n# Create a proxy to multiple servers\ncomposite_proxy = FastMCP.as_proxy(config, name=\"Composite Proxy\")\n\n# Tools and resources are accessible with prefixes:\n# - weather_get_forecast, calendar_add_event \n# - weather:\/\/weather\/icons\/sunny, calendar:\/\/calendar\/events\/today\n```\n\n## `FastMCPProxy` Class\n\nInternally, `FastMCP.as_proxy()` uses the `FastMCPProxy` class. You generally don't need to interact with this class directly, but it's available if needed.\n\nUsing the class directly might be necessary for advanced scenarios, like subclassing `FastMCPProxy` to add custom logic before or after forwarding requests.\n\n\n# Resources & Templates\nSource: https:\/\/gofastmcp.com\/servers\/resources\n\nExpose data sources and dynamic content generators to your MCP client.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nResources represent data or files that an MCP client can read, and resource templates extend this concept by allowing clients to request dynamically generated resources based on parameters passed in the URI.\n\nFastMCP simplifies defining both static and dynamic resources, primarily using the `@mcp.resource` decorator.\n\n## What Are Resources?\n\nResources provide read-only access to data for the LLM or client application. When a client requests a resource URI:\n\n1. FastMCP finds the corresponding resource definition.\n2. If it's dynamic (defined by a function), the function is executed.\n3. The content (text, JSON, binary data) is returned to the client.\n\nThis allows LLMs to access files, database content, configuration, or dynamically generated information relevant to the conversation.\n\n## Resources\n\n### The `@resource` Decorator\n\nThe most common way to define a resource is by decorating a Python function. The decorator requires the resource's unique URI.\n\n```python\nimport json\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Basic dynamic resource returning a string\n@mcp.resource(\"resource:\/\/greeting\")\ndef get_greeting() -> str:\n    \"\"\"Provides a simple greeting message.\"\"\"\n    return \"Hello from FastMCP Resources!\"\n\n# Resource returning JSON data (dict is auto-serialized)\n@mcp.resource(\"data:\/\/config\")\ndef get_config() -> dict:\n    \"\"\"Provides application configuration as JSON.\"\"\"\n    return {\n        \"theme\": \"dark\",\n        \"version\": \"1.2.0\",\n        \"features\": [\"tools\", \"resources\"],\n    }\n```\n\n**Key Concepts:**\n\n* **URI:** The first argument to `@resource` is the unique URI (e.g., `\"resource:\/\/greeting\"`) clients use to request this data.\n* **Lazy Loading:** The decorated function (`get_greeting`, `get_config`) is only executed when a client specifically requests that resource URI via `resources\/read`.\n* **Inferred Metadata:** By default:\n  * Resource Name: Taken from the function name (`get_greeting`).\n  * Resource Description: Taken from the function's docstring.\n\n### Return Values\n\nFastMCP automatically converts your function's return value into the appropriate MCP resource content:\n\n* **`str`**: Sent as `TextResourceContents` (with `mime_type=\"text\/plain\"` by default).\n* **`dict`, `list`, `pydantic.BaseModel`**: Automatically serialized to a JSON string and sent as `TextResourceContents` (with `mime_type=\"application\/json\"` by default).\n* **`bytes`**: Base64 encoded and sent as `BlobResourceContents`. You should specify an appropriate `mime_type` (e.g., `\"image\/png\"`, `\"application\/octet-stream\"`).\n* **`None`**: Results in an empty resource content list being returned.\n\n### Resource Metadata\n\nYou can customize the resource's properties using arguments in the decorator:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Example specifying metadata\n@mcp.resource(\n    uri=\"data:\/\/app-status\",      # Explicit URI (required)\n    name=\"ApplicationStatus\",     # Custom name\n    description=\"Provides the current status of the application.\", # Custom description\n    mime_type=\"application\/json\", # Explicit MIME type\n    tags={\"monitoring\", \"status\"} # Categorization tags\n)\ndef get_application_status() -> dict:\n    \"\"\"Internal function description (ignored if description is provided above).\"\"\"\n    return {\"status\": \"ok\", \"uptime\": 12345, \"version\": mcp.settings.version} # Example usage\n```\n\n* **`uri`**: The unique identifier for the resource (required).\n* **`name`**: A human-readable name (defaults to function name).\n* **`description`**: Explanation of the resource (defaults to docstring).\n* **`mime_type`**: Specifies the content type (FastMCP often infers a default like `text\/plain` or `application\/json`, but explicit is better for non-text types).\n* **`tags`**: A set of strings for categorization, potentially used by clients for filtering.\n\n### Accessing MCP Context\n\n<VersionBadge version=\"2.2.5\" \/>\n\nResources and resource templates can access additional MCP information and features through the `Context` object. To access it, add a parameter to your resource function with a type annotation of `Context`:\n\n```python {6, 14}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"resource:\/\/system-status\")\nasync def get_system_status(ctx: Context) -> dict:\n    \"\"\"Provides system status information.\"\"\"\n    return {\n        \"status\": \"operational\",\n        \"request_id\": ctx.request_id\n    }\n\n@mcp.resource(\"resource:\/\/{name}\/details\")\nasync def get_details(name: str, ctx: Context) -> dict:\n    \"\"\"Get details for a specific name.\"\"\"\n    return {\n        \"name\": name,\n        \"accessed_at\": ctx.request_id\n    }\n```\n\nFor full documentation on the Context object and all its capabilities, see the [Context documentation](\/servers\/context).\n\n### Asynchronous Resources\n\nUse `async def` for resource functions that perform I\/O operations (e.g., reading from a database or network) to avoid blocking the server.\n\n```python\nimport aiofiles\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"file:\/\/\/app\/data\/important_log.txt\", mime_type=\"text\/plain\")\nasync def read_important_log() -> str:\n    \"\"\"Reads content from a specific log file asynchronously.\"\"\"\n    try:\n        async with aiofiles.open(\"\/app\/data\/important_log.txt\", mode=\"r\") as f:\n            content = await f.read()\n        return content\n    except FileNotFoundError:\n        return \"Log file not found.\"\n```\n\n### Resource Classes\n\nWhile `@mcp.resource` is ideal for dynamic content, you can directly register pre-defined resources (like static files or simple text) using `mcp.add_resource()` and concrete `Resource` subclasses.\n\n```python\nfrom pathlib import Path\nfrom fastmcp import FastMCP\nfrom fastmcp.resources import FileResource, TextResource, DirectoryResource\n\nmcp = FastMCP(name=\"DataServer\")\n\n# 1. Exposing a static file directly\nreadme_path = Path(\".\/README.md\").resolve()\nif readme_path.exists():\n    # Use a file:\/\/ URI scheme\n    readme_resource = FileResource(\n        uri=f\"file:\/\/{readme_path.as_posix()}\",\n        path=readme_path, # Path to the actual file\n        name=\"README File\",\n        description=\"The project's README.\",\n        mime_type=\"text\/markdown\",\n        tags={\"documentation\"}\n    )\n    mcp.add_resource(readme_resource)\n\n# 2. Exposing simple, predefined text\nnotice_resource = TextResource(\n    uri=\"resource:\/\/notice\",\n    name=\"Important Notice\",\n    text=\"System maintenance scheduled for Sunday.\",\n    tags={\"notification\"}\n)\nmcp.add_resource(notice_resource)\n\n# 3. Using a custom key different from the URI\nspecial_resource = TextResource(\n    uri=\"resource:\/\/common-notice\",\n    name=\"Special Notice\",\n    text=\"This is a special notice with a custom storage key.\",\n)\nmcp.add_resource(special_resource, key=\"resource:\/\/custom-key\")\n\n# 4. Exposing a directory listing\ndata_dir_path = Path(\".\/app_data\").resolve()\nif data_dir_path.is_dir():\n    data_listing_resource = DirectoryResource(\n        uri=\"resource:\/\/data-files\",\n        path=data_dir_path, # Path to the directory\n        name=\"Data Directory Listing\",\n        description=\"Lists files available in the data directory.\",\n        recursive=False # Set to True to list subdirectories\n    )\n    mcp.add_resource(data_listing_resource) # Returns JSON list of files\n```\n\n**Common Resource Classes:**\n\n* `TextResource`: For simple string content.\n* `BinaryResource`: For raw `bytes` content.\n* `FileResource`: Reads content from a local file path. Handles text\/binary modes and lazy reading.\n* `HttpResource`: Fetches content from an HTTP(S) URL (requires `httpx`).\n* `DirectoryResource`: Lists files in a local directory (returns JSON).\n* (`FunctionResource`: Internal class used by `@mcp.resource`).\n\nUse these when the content is static or sourced directly from a file\/URL, bypassing the need for a dedicated Python function.\n\n#### Custom Resource Keys\n\n<VersionBadge version=\"2.2.0\" \/>\n\nWhen adding resources directly with `mcp.add_resource()`, you can optionally provide a custom storage key:\n\n```python\n# Creating a resource with standard URI as the key\nresource = TextResource(uri=\"resource:\/\/data\")\nmcp.add_resource(resource)  # Will be stored and accessed using \"resource:\/\/data\"\n\n# Creating a resource with a custom key\nspecial_resource = TextResource(uri=\"resource:\/\/special-data\")\nmcp.add_resource(special_resource, key=\"internal:\/\/data-v2\")  # Will be stored and accessed using \"internal:\/\/data-v2\"\n```\n\nNote that this parameter is only available when using `add_resource()` directly and not through the `@resource` decorator, as URIs are provided explicitly when using the decorator.\n\n## Resource Templates\n\nResource Templates allow clients to request resources whose content depends on parameters embedded in the URI. Define a template using the **same `@mcp.resource` decorator**, but include `{parameter_name}` placeholders in the URI string and add corresponding arguments to your function signature.\n\nResource templates share most configuration options with regular resources (name, description, mime\\_type, tags), but add the ability to define URI parameters that map to function parameters.\n\nResource templates generate a new resource for each unique set of parameters, which means that resources can be dynamically created on-demand. For example, if the resource template `\"user:\/\/profile\/{name}\"` is registered, MCP clients could request `\"user:\/\/profile\/ford\"` or `\"user:\/\/profile\/marvin\"` to retrieve either of those two user profiles as resources, without having to register each resource individually.\n\n<Tip>\n  Functions with `*args` are not supported as resource templates. However, unlike tools and prompts, resource templates do support `**kwargs` because the URI template defines specific parameter names that will be collected and passed as keyword arguments.\n<\/Tip>\n\nHere is a complete example that shows how to define two resource templates:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Template URI includes {city} placeholder\n@mcp.resource(\"weather:\/\/{city}\/current\")\ndef get_weather(city: str) -> dict:\n    \"\"\"Provides weather information for a specific city.\"\"\"\n    # In a real implementation, this would call a weather API\n    # Here we're using simplified logic for example purposes\n    return {\n        \"city\": city.capitalize(),\n        \"temperature\": 22,\n        \"condition\": \"Sunny\",\n        \"unit\": \"celsius\"\n    }\n\n# Template with multiple parameters\n@mcp.resource(\"repos:\/\/{owner}\/{repo}\/info\")\ndef get_repo_info(owner: str, repo: str) -> dict:\n    \"\"\"Retrieves information about a GitHub repository.\"\"\"\n    # In a real implementation, this would call the GitHub API\n    return {\n        \"owner\": owner,\n        \"name\": repo,\n        \"full_name\": f\"{owner}\/{repo}\",\n        \"stars\": 120,\n        \"forks\": 48\n    }\n```\n\nWith these two templates defined, clients can request a variety of resources:\n\n* `weather:\/\/london\/current`  Returns weather for London\n* `weather:\/\/paris\/current`  Returns weather for Paris\n* `repos:\/\/jlowin\/fastmcp\/info`  Returns info about the jlowin\/fastmcp repository\n* `repos:\/\/prefecthq\/prefect\/info`  Returns info about the prefecthq\/prefect repository\n\n### Wildcard Parameters\n\n<VersionBadge version=\"2.2.4\" \/>\n\n<Tip>\n  Please note: FastMCP's support for wildcard parameters is an **extension** of the Model Context Protocol standard, which otherwise follows RFC 6570. Since all template processing happens in the FastMCP server, this should not cause any compatibility issues with other MCP implementations.\n<\/Tip>\n\nResource templates support wildcard parameters that can match multiple path segments. While standard parameters (`{param}`) only match a single path segment and don't cross \"\/\" boundaries, wildcard parameters (`{param*}`) can capture multiple segments including slashes. Wildcards capture all subsequent path segments *up until* the defined part of the URI template (whether literal or another parameter). This allows you to have multiple wildcard parameters in a single URI template.\n\n```python {15, 23}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n\n# Standard parameter only matches one segment\n@mcp.resource(\"files:\/\/{filename}\")\ndef get_file(filename: str) -> str:\n    \"\"\"Retrieves a file by name.\"\"\"\n    # Will only match files:\/\/<single-segment>\n    return f\"File content for: {filename}\"\n\n\n# Wildcard parameter can match multiple segments\n@mcp.resource(\"path:\/\/{filepath*}\")\ndef get_path_content(filepath: str) -> str:\n    \"\"\"Retrieves content at a specific path.\"\"\"\n    # Can match path:\/\/docs\/server\/resources.mdx\n    return f\"Content at path: {filepath}\"\n\n\n# Mixing standard and wildcard parameters\n@mcp.resource(\"repo:\/\/{owner}\/{path*}\/template.py\")\ndef get_template_file(owner: str, path: str) -> dict:\n    \"\"\"Retrieves a file from a specific repository and path, but \n    only if the resource ends with `template.py`\"\"\"\n    # Can match repo:\/\/jlowin\/fastmcp\/src\/resources\/template.py\n    return {\n        \"owner\": owner,\n        \"path\": path + \"\/template.py\",\n        \"content\": f\"File at {path}\/template.py in {owner}'s repository\"\n    }\n```\n\nWildcard parameters are useful when:\n\n* Working with file paths or hierarchical data\n* Creating APIs that need to capture variable-length path segments\n* Building URL-like patterns similar to REST APIs\n\nNote that like regular parameters, each wildcard parameter must still be a named parameter in your function signature, and all required function parameters must appear in the URI template.\n\n### Default Values\n\n<VersionBadge version=\"2.2.0\" \/>\n\nWhen creating resource templates, FastMCP enforces two rules for the relationship between URI template parameters and function parameters:\n\n1. **Required Function Parameters:** All function parameters without default values (required parameters) must appear in the URI template.\n2. **URI Parameters:** All URI template parameters must exist as function parameters.\n\nHowever, function parameters with default values don't need to be included in the URI template. When a client requests a resource, FastMCP will:\n\n* Extract parameter values from the URI for parameters included in the template\n* Use default values for any function parameters not in the URI template\n\nThis allows for flexible API designs. For example, a simple search template with optional parameters:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"search:\/\/{query}\")\ndef search_resources(query: str, max_results: int = 10, include_archived: bool = False) -> dict:\n    \"\"\"Search for resources matching the query string.\"\"\"\n    # Only 'query' is required in the URI, the other parameters use their defaults\n    results = perform_search(query, limit=max_results, archived=include_archived)\n    return {\n        \"query\": query,\n        \"max_results\": max_results,\n        \"include_archived\": include_archived,\n        \"results\": results\n    }\n```\n\nWith this template, clients can request `search:\/\/python` and the function will be called with `query=\"python\", max_results=10, include_archived=False`. MCP Developers can still call the underlying `search_resources` function directly with more specific parameters.\n\nAn even more powerful pattern is registering a single function with multiple URI templates, allowing different ways to access the same data:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Define a user lookup function that can be accessed by different identifiers\n@mcp.resource(\"users:\/\/email\/{email}\")\n@mcp.resource(\"users:\/\/name\/{name}\")\ndef lookup_user(name: str | None = None, email: str | None = None) -> dict:\n    \"\"\"Look up a user by either name or email.\"\"\"\n    if email:\n        return find_user_by_email(email) # pseudocode\n    elif name:\n        return find_user_by_name(name) # pseudocode\n    else:\n        return {\"error\": \"No lookup parameters provided\"}\n```\n\nNow an LLM or client can retrieve user information in two different ways:\n\n* `users:\/\/email\/alice@example.com`  Looks up user by email (with name=None)\n* `users:\/\/name\/Bob`  Looks up user by name (with email=None)\n\nIn this stacked decorator pattern:\n\n* The `name` parameter is only provided when using the `users:\/\/name\/{name}` template\n* The `email` parameter is only provided when using the `users:\/\/email\/{email}` template\n* Each parameter defaults to `None` when not included in the URI\n* The function logic handles whichever parameter is provided\n\nTemplates provide a powerful way to expose parameterized data access points following REST-like principles.\n\n## Error Handling\n\n<VersionBadge version=\"2.4.1\" \/>\n\nIf your resource function encounters an error, you can raise a standard Python exception (`ValueError`, `TypeError`, `FileNotFoundError`, custom exceptions, etc.) or a FastMCP `ResourceError`.\n\nBy default, all exceptions (including their details) are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately.\n\nIf you want to mask internal error details for security reasons, you can:\n\n1. Use the `mask_error_details=True` parameter when creating your `FastMCP` instance:\n\n```python\nmcp = FastMCP(name=\"SecureServer\", mask_error_details=True)\n```\n\n2. Or use `ResourceError` to explicitly control what error information is sent to clients:\n\n```python\nfrom fastmcp import FastMCP\nfrom fastmcp.exceptions import ResourceError\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"resource:\/\/safe-error\")\ndef fail_with_details() -> str:\n    \"\"\"This resource provides detailed error information.\"\"\"\n    # ResourceError contents are always sent back to clients,\n    # regardless of mask_error_details setting\n    raise ResourceError(\"Unable to retrieve data: file not found\")\n\n@mcp.resource(\"resource:\/\/masked-error\")\ndef fail_with_masked_details() -> str:\n    \"\"\"This resource masks internal error details when mask_error_details=True.\"\"\"\n    # This message would be masked if mask_error_details=True\n    raise ValueError(\"Sensitive internal file path: \/etc\/secrets.conf\")\n\n@mcp.resource(\"data:\/\/{id}\")\ndef get_data_by_id(id: str) -> dict:\n    \"\"\"Template resources also support the same error handling pattern.\"\"\"\n    if id == \"secure\":\n        raise ValueError(\"Cannot access secure data\")\n    elif id == \"missing\":\n        raise ResourceError(\"Data ID 'missing' not found in database\")\n    return {\"id\": id, \"value\": \"data\"}\n```\n\nWhen `mask_error_details=True`, only error messages from `ResourceError` will include details, other exceptions will be converted to a generic message.\n\n## Server Behavior\n\n### Duplicate Resources\n\n<VersionBadge version=\"2.1.0\" \/>\n\nYou can configure how the FastMCP server handles attempts to register multiple resources or templates with the same URI. Use the `on_duplicate_resources` setting during `FastMCP` initialization.\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"ResourceServer\",\n    on_duplicate_resources=\"error\" # Raise error on duplicates\n)\n\n@mcp.resource(\"data:\/\/config\")\ndef get_config_v1(): return {\"version\": 1}\n\n# This registration attempt will raise a ValueError because\n# \"data:\/\/config\" is already registered and the behavior is \"error\".\n# @mcp.resource(\"data:\/\/config\")\n# def get_config_v2(): return {\"version\": 2}\n```\n\nThe duplicate behavior options are:\n\n* `\"warn\"` (default): Logs a warning, and the new resource\/template replaces the old one.\n* `\"error\"`: Raises a `ValueError`, preventing the duplicate registration.\n* `\"replace\"`: Silently replaces the existing resource\/template with the new one.\n* `\"ignore\"`: Keeps the original resource\/template and ignores the new registration attempt.\n\n\n# Tools\nSource: https:\/\/gofastmcp.com\/servers\/tools\n\nExpose functions as executable capabilities for your MCP client.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <div className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:<\/span> \n                <span className=\"version-badge-version\">{version}<\/span>\n            <\/div>\n        <\/code>;\n};\n\nTools are the core building blocks that allow your LLM to interact with external systems, execute code, and access data that isn't in its training data. In FastMCP, tools are Python functions exposed to LLMs through the MCP protocol.\n\n## What Are Tools?\n\nTools in FastMCP transform regular Python functions into capabilities that LLMs can invoke during conversations. When an LLM decides to use a tool:\n\n1. It sends a request with parameters based on the tool's schema.\n2. FastMCP validates these parameters against your function's signature.\n3. Your function executes with the validated inputs.\n4. The result is returned to the LLM, which can use it in its response.\n\nThis allows LLMs to perform tasks like querying databases, calling APIs, making calculations, or accessing filesextending their capabilities beyond what's in their training data.\n\n## Tools\n\n### The `@tool` Decorator\n\nCreating a tool is as simple as decorating a Python function with `@mcp.tool()`:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"CalculatorServer\")\n\n@mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Adds two integer numbers together.\"\"\"\n    return a + b\n```\n\nWhen this tool is registered, FastMCP automatically:\n\n* Uses the function name (`add`) as the tool name.\n* Uses the function's docstring (`Adds two integer numbers...`) as the tool description.\n* Generates an input schema based on the function's parameters and type annotations.\n* Handles parameter validation and error reporting.\n\nThe way you define your Python function dictates how the tool appears and behaves for the LLM client.\n\n<Tip>\n  Functions with `*args` or `**kwargs` are not supported as tools. This restriction exists because FastMCP needs to generate a complete parameter schema for the MCP protocol, which isn't possible with variable argument lists.\n<\/Tip>\n\n### Parameters\n\n#### Annotations\n\nType annotations for parameters are essential for proper tool functionality. They:\n\n1. Inform the LLM about the expected data types for each parameter\n2. Enable FastMCP to validate input data from clients\n3. Generate accurate JSON schemas for the MCP protocol\n\nUse standard Python type annotations for parameters:\n\n```python\n@mcp.tool()\ndef analyze_text(\n    text: str,\n    max_tokens: int = 100,\n    language: str | None = None\n) -> dict:\n    \"\"\"Analyze the provided text.\"\"\"\n    # Implementation...\n```\n\n#### Parameter Metadata\n\nYou can provide additional metadata about parameters using Pydantic's `Field` class with `Annotated`. This approach is preferred as it's more modern and keeps type hints separate from validation rules:\n\n```python\nfrom typing import Annotated\nfrom pydantic import Field\n\n@mcp.tool()\ndef process_image(\n    image_url: Annotated[str, Field(description=\"URL of the image to process\")],\n    resize: Annotated[bool, Field(description=\"Whether to resize the image\")] = False,\n    width: Annotated[int, Field(description=\"Target width in pixels\", ge=1, le=2000)] = 800,\n    format: Annotated[\n        Literal[\"jpeg\", \"png\", \"webp\"], \n        Field(description=\"Output image format\")\n    ] = \"jpeg\"\n) -> dict:\n    \"\"\"Process an image with optional resizing.\"\"\"\n    # Implementation...\n```\n\nYou can also use the Field as a default value, though the Annotated approach is preferred:\n\n```python\n@mcp.tool()\ndef search_database(\n    query: str = Field(description=\"Search query string\"),\n    limit: int = Field(10, description=\"Maximum number of results\", ge=1, le=100)\n) -> list:\n    \"\"\"Search the database with the provided query.\"\"\"\n    # Implementation...\n```\n\nField provides several validation and documentation features:\n\n* `description`: Human-readable explanation of the parameter (shown to LLMs)\n* `ge`\/`gt`\/`le`\/`lt`: Greater\/less than (or equal) constraints\n* `min_length`\/`max_length`: String or collection length constraints\n* `pattern`: Regex pattern for string validation\n* `default`: Default value if parameter is omitted\n\n#### Supported Types\n\nFastMCP supports a wide range of type annotations, including all Pydantic types:\n\n| Type Annotation   | Example                                   | Description                                                                                     |\n| :---------------- | :---------------------------------------- | :---------------------------------------------------------------------------------------------- |\n| Basic types       | `int`, `float`, `str`, `bool`             | Simple scalar values - see [Built-in Types](#built-in-types)                                    |\n| Binary data       | `bytes`                                   | Binary content - see [Binary Data](#binary-data)                                                |\n| Date and Time     | `datetime`, `date`, `timedelta`           | Date and time objects - see [Date and Time Types](#date-and-time-types)                         |\n| Collection types  | `list[str]`, `dict[str, int]`, `set[int]` | Collections of items - see [Collection Types](#collection-types)                                |\n| Optional types    | `float \\| None`, `Optional[float]`        | Parameters that may be null\/omitted - see [Union and Optional Types](#union-and-optional-types) |\n| Union types       | `str \\| int`, `Union[str, int]`           | Parameters accepting multiple types - see [Union and Optional Types](#union-and-optional-types) |\n| Constrained types | `Literal[\"A\", \"B\"]`, `Enum`               | Parameters with specific allowed values - see [Constrained Types](#constrained-types)           |\n| Paths             | `Path`                                    | File system paths - see [Paths](#paths)                                                         |\n| UUIDs             | `UUID`                                    | Universally unique identifiers - see [UUIDs](#uuids)                                            |\n| Pydantic models   | `UserData`                                | Complex structured data - see [Pydantic Models](#pydantic-models)                               |\n\nFor additional type annotations not listed here, see the [Parameter Types](#parameter-types) section below for more detailed information and examples.\n\n#### Optional Arguments\n\nFastMCP follows Python's standard function parameter conventions. Parameters without default values are required, while those with default values are optional.\n\n```python\n@mcp.tool()\ndef search_products(\n    query: str,                   # Required - no default value\n    max_results: int = 10,        # Optional - has default value\n    sort_by: str = \"relevance\",   # Optional - has default value\n    category: str | None = None   # Optional - can be None\n) -> list[dict]:\n    \"\"\"Search the product catalog.\"\"\"\n    # Implementation...\n```\n\nIn this example, the LLM must provide a `query` parameter, while `max_results`, `sort_by`, and `category` will use their default values if not explicitly provided.\n\n### Metadata\n\nWhile FastMCP infers the name and description from your function, you can override these and add tags using arguments to the `@mcp.tool` decorator:\n\n```python\n@mcp.tool(\n    name=\"find_products\",           # Custom tool name for the LLM\n    description=\"Search the product catalog with optional category filtering.\", # Custom description\n    tags={\"catalog\", \"search\"}      # Optional tags for organization\/filtering\n)\ndef search_products_implementation(query: str, category: str | None = None) -> list[dict]:\n    \"\"\"Internal function description (ignored if description is provided above).\"\"\"\n    # Implementation...\n    print(f\"Searching for '{query}' in category '{category}'\")\n    return [{\"id\": 2, \"name\": \"Another Product\"}]\n```\n\n* **`name`**: Sets the explicit tool name exposed via MCP.\n* **`description`**: Provides the description exposed via MCP. If set, the function's docstring is ignored for this purpose.\n* **`tags`**: A set of strings used to categorize the tool. Clients *might* use tags to filter or group available tools.\n\n### Async Tools\n\nFastMCP seamlessly supports both standard (`def`) and asynchronous (`async def`) functions as tools.\n\n```python\n# Synchronous tool (suitable for CPU-bound or quick tasks)\n@mcp.tool()\ndef calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"Calculate the distance between two coordinates.\"\"\"\n    # Implementation...\n    return 42.5\n\n# Asynchronous tool (ideal for I\/O-bound operations)\n@mcp.tool()\nasync def fetch_weather(city: str) -> dict:\n    \"\"\"Retrieve current weather conditions for a city.\"\"\"\n    # Use 'async def' for operations involving network calls, file I\/O, etc.\n    # This prevents blocking the server while waiting for external operations.\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"https:\/\/api.example.com\/weather\/{city}\") as response:\n            # Check response status before returning\n            response.raise_for_status()\n            return await response.json()\n```\n\nUse `async def` when your tool needs to perform operations that might wait for external systems (network requests, database queries, file access) to keep your server responsive.\n\n### Return Values\n\nFastMCP automatically converts the value returned by your function into the appropriate MCP content format for the client:\n\n* **`str`**: Sent as `TextContent`.\n* **`dict`, `list`, Pydantic `BaseModel`**: Serialized to a JSON string and sent as `TextContent`.\n* **`bytes`**: Base64 encoded and sent as `BlobResourceContents` (often within an `EmbeddedResource`).\n* **`fastmcp.Image`**: A helper class for easily returning image data. Sent as `ImageContent`.\n* **`None`**: Results in an empty response (no content is sent back to the client).\n\nFastMCP will attempt to serialize other types to a string if possible.\n\n<Tip>\n  At this time, FastMCP responds only to your tool's return *value*, not its return *annotation*.\n<\/Tip>\n\n```python\nfrom fastmcp import FastMCP, Image\nimport io\ntry:\n    from PIL import Image as PILImage\nexcept ImportError:\n    raise ImportError(\"Please install the `pillow` library to run this example.\")\n\nmcp = FastMCP(\"Image Demo\")\n\n@mcp.tool()\ndef generate_image(width: int, height: int, color: str) -> Image:\n    \"\"\"Generates a solid color image.\"\"\"\n    # Create image using Pillow\n    img = PILImage.new(\"RGB\", (width, height), color=color)\n\n    # Save to a bytes buffer\n    buffer = io.BytesIO()\n    img.save(buffer, format=\"PNG\")\n    img_bytes = buffer.getvalue()\n\n    # Return using FastMCP's Image helper\n    return Image(data=img_bytes, format=\"png\")\n\n@mcp.tool()\ndef do_nothing() -> None:\n    \"\"\"This tool performs an action but returns no data.\"\"\"\n    print(\"Performing a side effect...\")\n    return None\n```\n\n### Error Handling\n\n<VersionBadge version=\"2.4.1\" \/>\n\nIf your tool encounters an error, you can raise a standard Python exception (`ValueError`, `TypeError`, `FileNotFoundError`, custom exceptions, etc.) or a FastMCP `ToolError`.\n\nBy default, all exceptions (including their details) are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately.\n\nIf you want to mask internal error details for security reasons, you can:\n\n1. Use the `mask_error_details=True` parameter when creating your `FastMCP` instance:\n\n```python\nmcp = FastMCP(name=\"SecureServer\", mask_error_details=True)\n```\n\n2. Or use `ToolError` to explicitly control what error information is sent to clients:\n\n```python\nfrom fastmcp import FastMCP\nfrom fastmcp.exceptions import ToolError\n\n@mcp.tool()\ndef divide(a: float, b: float) -> float:\n    \"\"\"Divide a by b.\"\"\"\n\n    if b == 0:\n        # Error messages from ToolError are always sent to clients,\n        # regardless of mask_error_details setting\n        raise ToolError(\"Division by zero is not allowed.\")\n    \n    # If mask_error_details=True, this message would be masked\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numbers.\")\n        \n    return a \/ b\n```\n\nWhen `mask_error_details=True`, only error messages from `ToolError` will include details, other exceptions will be converted to a generic message.\n\n### Annotations\n\n<VersionBadge version=\"2.2.7\" \/>\n\nFastMCP allows you to add specialized metadata to your tools through annotations. These annotations communicate how tools behave to client applications without consuming token context in LLM prompts.\n\nAnnotations serve several purposes in client applications:\n\n* Adding user-friendly titles for display purposes\n* Indicating whether tools modify data or systems\n* Describing the safety profile of tools (destructive vs. non-destructive)\n* Signaling if tools interact with external systems\n\nYou can add annotations to a tool using the `annotations` parameter in the `@mcp.tool()` decorator:\n\n```python\n@mcp.tool(\n    annotations={\n        \"title\": \"Calculate Sum\",\n        \"readOnlyHint\": True,\n        \"openWorldHint\": False\n    }\n)\ndef calculate_sum(a: float, b: float) -> float:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n```\n\nFastMCP supports these standard annotations:\n\n| Annotation        | Type    | Default | Purpose                                                                     |\n| :---------------- | :------ | :------ | :-------------------------------------------------------------------------- |\n| `title`           | string  | -       | Display name for user interfaces                                            |\n| `readOnlyHint`    | boolean | false   | Indicates if the tool only reads without making changes                     |\n| `destructiveHint` | boolean | true    | For non-readonly tools, signals if changes are destructive                  |\n| `idempotentHint`  | boolean | false   | Indicates if repeated identical calls have the same effect as a single call |\n| `openWorldHint`   | boolean | true    | Specifies if the tool interacts with external systems                       |\n\nRemember that annotations help make better user experiences but should be treated as advisory hints. They help client applications present appropriate UI elements and safety controls, but won't enforce security boundaries on their own. Always focus on making your annotations accurately represent what your tool actually does.\n\n## MCP Context\n\nTools can access MCP features like logging, reading resources, or reporting progress through the `Context` object. To use it, add a parameter to your tool function with the type hint `Context`.\n\n```python\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"ContextDemo\")\n\n@mcp.tool()\nasync def process_data(data_uri: str, ctx: Context) -> dict:\n    \"\"\"Process data from a resource with progress reporting.\"\"\"\n    await ctx.info(f\"Processing data from {data_uri}\")\n    \n    # Read a resource\n    resource = await ctx.read_resource(data_uri)\n    data = resource[0].content if resource else \"\"\n    \n    # Report progress\n    await ctx.report_progress(progress=50, total=100)\n    \n    # Example request to the client's LLM for help\n    summary = await ctx.sample(f\"Summarize this in 10 words: {data[:200]}\")\n    \n    await ctx.report_progress(progress=100, total=100)\n    return {\n        \"length\": len(data),\n        \"summary\": summary.text\n    }\n```\n\nThe Context object provides access to:\n\n* **Logging**: `ctx.debug()`, `ctx.info()`, `ctx.warning()`, `ctx.error()`\n* **Progress Reporting**: `ctx.report_progress(progress, total)`\n* **Resource Access**: `ctx.read_resource(uri)`\n* **LLM Sampling**: `ctx.sample(...)`\n* **Request Information**: `ctx.request_id`, `ctx.client_id`\n\nFor full documentation on the Context object and all its capabilities, see the [Context documentation](\/servers\/context).\n\n## Parameter Types\n\nFastMCP supports a wide variety of parameter types to give you flexibility when designing your tools.\n\nFastMCP generally supports all types that Pydantic supports as fields, including all Pydantic custom types. This means you can use any type that can be validated and parsed by Pydantic in your tool parameters.\n\nFastMCP supports **type coercion** when possible. This means that if a client sends data that doesn't match the expected type, FastMCP will attempt to convert it to the appropriate type. For example, if a client sends a string for a parameter annotated as `int`, FastMCP will attempt to convert it to an integer. If the conversion is not possible, FastMCP will return a validation error.\n\n### Built-in Types\n\nThe most common parameter types are Python's built-in scalar types:\n\n```python\n@mcp.tool()\ndef process_values(\n    name: str,             # Text data\n    count: int,            # Integer numbers\n    amount: float,         # Floating point numbers\n    enabled: bool          # Boolean values (True\/False)\n):\n    \"\"\"Process various value types.\"\"\"\n    # Implementation...\n```\n\nThese types provide clear expectations to the LLM about what values are acceptable and allow FastMCP to validate inputs properly. Even if a client provides a string like \"42\", it will be coerced to an integer for parameters annotated as `int`.\n\n### Date and Time Types\n\nFastMCP supports various date and time types from the `datetime` module:\n\n```python\nfrom datetime import datetime, date, timedelta\n\n@mcp.tool()\ndef process_date_time(\n    event_date: date,             # ISO format date string or date object\n    event_time: datetime,         # ISO format datetime string or datetime object\n    duration: timedelta = timedelta(hours=1)  # Integer seconds or timedelta\n) -> str:\n    \"\"\"Process date and time information.\"\"\"\n    # Types are automatically converted from strings\n    assert isinstance(event_date, date)  \n    assert isinstance(event_time, datetime)\n    assert isinstance(duration, timedelta)\n    \n    return f\"Event on {event_date} at {event_time} for {duration}\"\n```\n\n* `datetime` - Accepts ISO format strings (e.g., \"2023-04-15T14:30:00\")\n* `date` - Accepts ISO format date strings (e.g., \"2023-04-15\")\n* `timedelta` - Accepts integer seconds or timedelta objects\n\n### Collection Types\n\nFastMCP supports all standard Python collection types:\n\n```python\n@mcp.tool()\ndef analyze_data(\n    values: list[float],           # List of numbers\n    properties: dict[str, str],    # Dictionary with string keys and values\n    unique_ids: set[int],          # Set of unique integers\n    coordinates: tuple[float, float],  # Tuple with fixed structure\n    mixed_data: dict[str, list[int]] # Nested collections\n):\n    \"\"\"Analyze collections of data.\"\"\"\n    # Implementation...\n```\n\nAll collection types can be used as parameter annotations:\n\n* `list[T]` - Ordered sequence of items\n* `dict[K, V]` - Key-value mapping\n* `set[T]` - Unordered collection of unique items\n* `tuple[T1, T2, ...]` - Fixed-length sequence with potentially different types\n\nCollection types can be nested and combined to represent complex data structures. JSON strings that match the expected structure will be automatically parsed and converted to the appropriate Python collection type.\n\n### Union and Optional Types\n\nFor parameters that can accept multiple types or may be omitted:\n\n```python\n@mcp.tool()\ndef flexible_search(\n    query: str | int,              # Can be either string or integer\n    filters: dict[str, str] | None = None,  # Optional dictionary\n    sort_field: str | None = None  # Optional string\n):\n    \"\"\"Search with flexible parameter types.\"\"\"\n    # Implementation...\n```\n\nModern Python syntax (`str | int`) is preferred over older `Union[str, int]` forms. Similarly, `str | None` is preferred over `Optional[str]`.\n\n### Constrained Types\n\nWhen a parameter must be one of a predefined set of values, you can use either Literal types or Enums:\n\n#### Literals\n\nLiterals constrain parameters to a specific set of values:\n\n```python\nfrom typing import Literal\n\n@mcp.tool()\ndef sort_data(\n    data: list[float],\n    order: Literal[\"ascending\", \"descending\"] = \"ascending\",\n    algorithm: Literal[\"quicksort\", \"mergesort\", \"heapsort\"] = \"quicksort\"\n):\n    \"\"\"Sort data using specific options.\"\"\"\n    # Implementation...\n```\n\nLiteral types:\n\n* Specify exact allowable values directly in the type annotation\n* Help LLMs understand exactly which values are acceptable\n* Provide input validation (errors for invalid values)\n* Create clear schemas for clients\n\n#### Enums\n\nFor more structured sets of constrained values, use Python's Enum class:\n\n```python\nfrom enum import Enum\n\nclass Color(Enum):\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\n@mcp.tool()\ndef process_image(\n    image_path: str, \n    color_filter: Color = Color.RED\n):\n    \"\"\"Process an image with a color filter.\"\"\"\n    # Implementation...\n    # color_filter will be a Color enum member\n```\n\nWhen using Enum types:\n\n* Clients should provide the enum's value (e.g., \"red\"), not the enum member name (e.g., \"RED\")\n* FastMCP automatically coerces the string value into the appropriate Enum object\n* Your function receives the actual Enum member (e.g., `Color.RED`)\n* Validation errors are raised for values not in the enum\n\n### Binary Data\n\nThere are two approaches to handling binary data in tool parameters:\n\n#### Bytes\n\n```python\n@mcp.tool()\ndef process_binary(data: bytes):\n    \"\"\"Process binary data directly.\n    \n    The client can send a binary string, which will be \n    converted directly to bytes.\n    \"\"\"\n    # Implementation using binary data\n    data_length = len(data)\n    # ...\n```\n\nWhen you annotate a parameter as `bytes`, FastMCP will:\n\n* Convert raw strings directly to bytes\n* Validate that the input can be properly represented as bytes\n\nFastMCP does not automatically decode base64-encoded strings for bytes parameters. If you need to accept base64-encoded data, you should handle the decoding manually as shown below.\n\n#### Base64-encoded strings\n\n```python\nfrom typing import Annotated\nfrom pydantic import Field\n\n@mcp.tool()\ndef process_image_data(\n    image_data: Annotated[str, Field(description=\"Base64-encoded image data\")]\n):\n    \"\"\"Process an image from base64-encoded string.\n    \n    The client is expected to provide base64-encoded data as a string.\n    You'll need to decode it manually.\n    \"\"\"\n    # Manual base64 decoding\n    import base64\n    binary_data = base64.b64decode(image_data)\n    # Process binary_data...\n```\n\nThis approach is recommended when you expect to receive base64-encoded binary data from clients.\n\n### Paths\n\nThe `Path` type from the `pathlib` module can be used for file system paths:\n\n```python\nfrom pathlib import Path\n\n@mcp.tool()\ndef process_file(path: Path) -> str:\n    \"\"\"Process a file at the given path.\"\"\"\n    assert isinstance(path, Path)  # Path is properly converted\n    return f\"Processing file at {path}\"\n```\n\nWhen a client sends a string path, FastMCP automatically converts it to a `Path` object.\n\n### UUIDs\n\nThe `UUID` type from the `uuid` module can be used for unique identifiers:\n\n```python\nimport uuid\n\n@mcp.tool()\ndef process_item(\n    item_id: uuid.UUID  # String UUID or UUID object\n) -> str:\n    \"\"\"Process an item with the given UUID.\"\"\"\n    assert isinstance(item_id, uuid.UUID)  # Properly converted to UUID\n    return f\"Processing item {item_id}\"\n```\n\nWhen a client sends a string UUID (e.g., \"123e4567-e89b-12d3-a456-426614174000\"), FastMCP automatically converts it to a `UUID` object.\n\n### Pydantic Models\n\nFor complex, structured data with nested fields and validation, use Pydantic models:\n\n```python\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass User(BaseModel):\n    username: str\n    email: str = Field(description=\"User's email address\")\n    age: int | None = None\n    is_active: bool = True\n\n@mcp.tool()\ndef create_user(user: User):\n    \"\"\"Create a new user in the system.\"\"\"\n    # The input is automatically validated against the User model\n    # Even if provided as a JSON string or dict\n    # Implementation...\n```\n\nUsing Pydantic models provides:\n\n* Clear, self-documenting structure for complex inputs\n* Built-in data validation\n* Automatic generation of detailed JSON schemas for the LLM\n* Automatic conversion from dict\/JSON input\n\nClients can provide data for Pydantic model parameters as either:\n\n* A JSON object (string)\n* A dictionary with the appropriate structure\n* Nested parameters in the appropriate format\n\n### Pydantic Fields\n\nFastMCP supports robust parameter validation through Pydantic's `Field` class. This is especially useful to ensure that input values meet specific requirements beyond just their type.\n\nNote that fields can be used *outside* Pydantic models to provide metadata and validation constraints. The preferred approach is using `Annotated` with `Field`:\n\n```python\nfrom typing import Annotated\nfrom pydantic import Field\n\n@mcp.tool()\ndef analyze_metrics(\n    # Numbers with range constraints\n    count: Annotated[int, Field(ge=0, le=100)],         # 0 <= count <= 100\n    ratio: Annotated[float, Field(gt=0, lt=1.0)],       # 0 < ratio < 1.0\n    \n    # String with pattern and length constraints\n    user_id: Annotated[str, Field(\n        pattern=r\"^[A-Z]{2}\\d{4}$\",                     # Must match regex pattern\n        description=\"User ID in format XX0000\"\n    )],\n    \n    # String with length constraints\n    comment: Annotated[str, Field(min_length=3, max_length=500)] = \"\",\n    \n    # Numeric constraints\n    factor: Annotated[int, Field(multiple_of=5)] = 10,  # Must be multiple of 5\n):\n    \"\"\"Analyze metrics with validated parameters.\"\"\"\n    # Implementation...\n```\n\nYou can also use `Field` as a default value, though the `Annotated` approach is preferred:\n\n```python\n@mcp.tool()\ndef validate_data(\n    # Value constraints\n    age: int = Field(ge=0, lt=120),                     # 0 <= age < 120\n    \n    # String constraints\n    email: str = Field(pattern=r\"^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$\"),  # Email pattern\n    \n    # Collection constraints\n    tags: list[str] = Field(min_length=1, max_length=10)  # 1-10 tags\n):\n    \"\"\"Process data with field validations.\"\"\"\n    # Implementation...\n```\n\nCommon validation options include:\n\n| Validation                 | Type               | Description                                    |\n| :------------------------- | :----------------- | :--------------------------------------------- |\n| `ge`, `gt`                 | Number             | Greater than (or equal) constraint             |\n| `le`, `lt`                 | Number             | Less than (or equal) constraint                |\n| `multiple_of`              | Number             | Value must be a multiple of this number        |\n| `min_length`, `max_length` | String, List, etc. | Length constraints                             |\n| `pattern`                  | String             | Regular expression pattern constraint          |\n| `description`              | Any                | Human-readable description (appears in schema) |\n\nWhen a client sends invalid data, FastMCP will return a validation error explaining why the parameter failed validation.\n\n## Server Behavior\n\n### Duplicate Tools\n\n<VersionBadge version=\"2.1.0\" \/>\n\nYou can control how the FastMCP server behaves if you try to register multiple tools with the same name. This is configured using the `on_duplicate_tools` argument when creating the `FastMCP` instance.\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"StrictServer\",\n    # Configure behavior for duplicate tool names\n    on_duplicate_tools=\"error\"\n)\n\n@mcp.tool()\ndef my_tool(): return \"Version 1\"\n\n# This will now raise a ValueError because 'my_tool' already exists\n# and on_duplicate_tools is set to \"error\".\n# @mcp.tool()\n# def my_tool(): return \"Version 2\"\n```\n\nThe duplicate behavior options are:\n\n* `\"warn\"` (default): Logs a warning and the new tool replaces the old one.\n* `\"error\"`: Raises a `ValueError`, preventing the duplicate registration.\n* `\"replace\"`: Silently replaces the existing tool with the new one.\n* `\"ignore\"`: Keeps the original tool and ignores the new registration attempt.\n\n### Removing Tools\n\n<VersionBadge version=\"2.3.4\" \/>\n\nYou can dynamically remove tools from a server using the `remove_tool` method:\n\n```python\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DynamicToolServer\")\n\n@mcp.tool()\ndef calculate_sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\nmcp.remove_tool(\"calculate_sum\")\n```\n\n### Legacy JSON Parsing\n\n<VersionBadge version=\"2.2.10\" \/>\n\nFastMCP 1.0 and \\< 2.2.10 relied on a crutch that attempted to work around LLM limitations by automatically parsing stringified JSON in tool arguments (e.g., converting `\"[1,2,3]\"` to `[1,2,3]`). As of FastMCP 2.2.10, this behavior is disabled by default because it circumvents type validation and can lead to unexpected type coercion issues (e.g. parsing \"true\" as a bool and attempting to call a tool that expected a string, which would fail type validation).\n\nMost modern LLMs correctly format JSON, but if working with models that unnecessarily stringify JSON (as was the case with Claude Desktop in late 2024), you can re-enable this behavior on your server by setting the environment variable `FASTMCP_TOOL_ATTEMPT_PARSE_JSON_ARGS=1`.\n\nWe strongly recommend leaving this disabled unless necessary.\n\n",
    "uid" : "33344A46-932E-461B-AF32-71CCE2C16FCB",
    "name" : "GoFastMCP LLMs.txt",
    "keyword" : "pymcp"
  }
}