{
  "alfredsnippet" : {
    "snippet" : "You are a senior engineer helping me refactor a large in-progress branch into a small, reviewable stack of diffs (stacked PRs), using git-spice (`gsp` - see `~\/dotfiles\/.claude\/docs\/using-gsp.md` for more info about it). Your job: inspect the repo + my current branch, then propose and (if I choose) execute a restructuring into 2–N stacked branches with clean, reviewable changes.\n\nIMPORTANT BEHAVIOR\n- Do not ask me questions until AFTER you have inspected the repo and inferred as much as possible.\n- Prefer making reasonable assumptions and stating them explicitly, instead of asking early.\n- Only ask for input when there is genuine ambiguity you cannot resolve from repo context (e.g., multiple test entrypoints, unclear trunk branch, etc.).\n\nHARD CONSTRAINTS\n1) Do NOT mutate my current branch (no rebases, no new commits, no force pushes on it).\n2) Create NEW branch(es) for the stack.\n3) End state MUST be identical to the existing branch’s content (same final tree \/ file contents).\n4) The stack must be landable sequentially:\n   - Each diff\/branch should be valid if all preceding diffs are merged.\n   - Tests + functionality should work at every step of the stack (no “break main until later”).\n5) Keep the number of diffs reasonable. If there are tradeoffs, propose 2–3 different stack shapes.\n\nASSUMPTIONS \/ TOOLING\n- You can run shell commands in the repo.\n- You can use `git` and `gsp` (git-spice CLI) and standard Unix tools.\n- `gsp` (NOT `gs`) is the correct binary name in this environment.\n- Do not push anything unless I explicitly ask later.\n- Default trunk branch is likely `main` (or `master` \/ `develop`); infer it.\n\nWHAT I WILL PROVIDE (ONLY IF YOU NEED IT LATER)\n- If you can’t infer the correct test command(s), you’ll ask me after your inspection.\n- If there’s a special CI \/ presubmit flow I require, you’ll ask after inspection.\n\nYOUR TASKS (DO THESE IN ORDER)\n\nPHASE 0 — SAFETY + DISCOVERY (NO CHANGES YET)\nA) Capture the current branch name and HEAD:\n   - `git status -sb`\n   - `git rev-parse --abbrev-ref HEAD`\n   - `git rev-parse HEAD`\nB) Detect trunk branch + remote:\n   - Determine trunk from repo conventions:\n     * Check `origin\/HEAD`, common branches, recent merges.\n     * If unclear, list candidates and pick the best with justification.\n   - Run: `git remote -v`, `git branch -avv`, `git symbolic-ref refs\/remotes\/origin\/HEAD` (if available)\nC) Initialize gsp metadata (safe to do; doesn’t rewrite history):\n   - `gsp repo init` (or `gsp repo init --trunk=<trunk> --remote=origin` if you can infer trunk)\nD) Identify the divergence point and scope:\n   - `BASE=$(git merge-base <trunk> HEAD)`\n   - Summarize change size:\n     * `git diff --stat $BASE..HEAD`\n     * `git diff --name-status $BASE..HEAD`\n     * `git log --oneline --reverse $BASE..HEAD` (and `--decorate` if useful)\nE) Detect whether there are uncommitted changes:\n   - If yes, DO NOT commit them on the current branch.\n   - Plan to stash\/apply them safely to the new stack branch workflow.\n\nPHASE 1 — UNDERSTAND THE CHANGES (READ-ONLY ANALYSIS)\nProduce a structured analysis:\n1) High-level intent: what feature\/refactor\/etc. this branch is doing (infer from diffs, directories, commit msgs).\n2) Categorize changes into logical buckets such as:\n   - Pure refactors \/ renames \/ formatting\n   - New abstractions \/ APIs \/ plumbing\n   - Behavior changes \/ feature logic\n   - Tests\n   - Docs \/ configs \/ build rules\n3) Dependency graph between buckets (what must land before what).\n4) Identify “risk hotspots” (files with wide blast radius, complicated migrations).\n\nPHASE 2 — PROPOSE 2–3 STACK OPTIONS (DO NOT EXECUTE YET)\nGive me 2–3 alternative stack plans. For each plan include:\n- Number of diffs\/branches (target small but coherent; typically 3–6 unless the change is tiny).\n- Branch titles (reviewer-friendly), and a 1–3 sentence summary per diff.\n- Exact contents of each diff (what files\/areas move into which layer).\n- Why this plan is good (reviewability, minimal churn, bisectability, testability).\n- Risks\/tradeoffs (e.g., some changes hard to separate without temporary adapters).\n- A recommended plan and why.\n\nEach stack option MUST maintain “tests\/behavior working at every step.”\nIf that requires small incremental scaffolding (feature flags, adapters, temporary compatibility layers), propose them explicitly.\n\nPHASE 3 — AFTER I PICK A PLAN, EXECUTE THE RESTACK (WITHOUT TOUCHING CURRENT BRANCH)\nWhen I choose an option, implement it by creating a new stack of branches that reproduces the same final tree as my current branch.\n\nImplementation requirements:\nA) Create safety pointers (non-mutating):\n   - Create a backup ref to the original branch HEAD (e.g., `backup\/<branch>-<date>`).\nB) Create a new stack base branch off trunk:\n   - e.g., `stack\/<topic>\/01-...` from `<trunk>`\nC) Build the stack using the cleanest method available, preferring:\n   1) If existing commits already form clean layers: branch-at-commit + `gsp downstack track`.\n   2) Otherwise: cherry-pick or patch-apply from the original branch into new branches, splitting as needed:\n      - Use `git cherry-pick -n <commit>` and `git add -p` to split hunks into the right diff.\n      - Commit with clear messages.\n      - Create the next stacked branch using `gsp branch create <name>` once the previous diff is clean.\n   3) Avoid rewriting the original branch; all surgery happens on new branches only.\nD) Track the stack in gsp:\n   - `gsp branch track` for the first branch\n   - Create further branches with `gsp branch create ...`\n   - Validate with `gsp log short` \/ `gsp log long`\n\nPHASE 4 — ENSURE TESTS PASS AT EVERY LAYER\n1) Infer the best local test command(s) by inspecting:\n   - README, CONTRIBUTING, Makefile, package scripts, CI config (GitHub Actions, Buildkite, etc.)\n2) For each branch in the stack (bottom → top):\n   - run the inferred test command(s) (or a fast subset if repo is huge; justify)\n   - if something breaks mid-stack, fix it *within that layer* (add adapter\/shim, reorder commits) so each layer is green.\n3) If you cannot infer tests confidently, ask me ONLY after your inspection:\n   - Present 1–3 likely commands and ask which is authoritative.\n\nPHASE 5 — VERIFY FINAL STATE IDENTICAL TO ORIGINAL BRANCH\nYou MUST prove the top of the new stack matches the original branch content.\nUse multiple checks:\n- Tree equality:\n  - `git rev-parse <original_branch>^{tree}`\n  - `git rev-parse <new_top_branch>^{tree}`\n  - These must match.\n- Diff must be empty:\n  - `git diff --stat <original_branch>..<new_top_branch>` should be empty\n  - `git diff <original_branch>..<new_top_branch>` should be empty\n- Optional: `git range-diff` to sanity-check commit intent if relevant.\n\nPHASE 6 — FINAL OUTPUTS (WHAT YOU DELIVER TO ME)\n1) The final stack overview:\n   - `gsp log short` output + branch list in order\n2) For each diff\/branch:\n   - Title, summary, rationale, and “review notes” (what to focus on)\n   - Testing status (what you ran and result)\n3) Verification proof that the end state matches the original branch (tree hash + empty diff)\n4) Optional (DO NOT DO UNLESS I ASK): A suggested `gsp stack submit --fill --draft` plan for PR creation.\n\nGUARDRAILS \/ DO-NOTS\n- Do not rebase or amend commits on my current branch.\n- Do not force push anything.\n- Do not delete branches unless I explicitly tell you.\n- Don’t create tons of tiny commits; prefer one coherent commit per diff (or small handful) unless separation is essential.\n- Don’t leave the stack in a state where intermediate branches don’t build\/test.\n\nBEGIN NOW:\nStart with PHASE 0 and PHASE 1 (read-only). Then present 2–3 stack options (PHASE 2). Stop and wait for my choice before executing PHASE 3+.\n",
    "uid" : "8125E632-E110-49C6-8548-C0B917C6AE61",
    "name" : "Prompt: stacked-diff-ize",
    "keyword" : "stackeddiff"
  }
}