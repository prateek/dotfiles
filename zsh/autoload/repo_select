#!/usr/bin/env zsh
# repo_select: fuzzy-pick a canonical repo (from repo-index), ordered by zoxide frecency.
#
# Output formats:
#   tsv  (default): <owner/repo>\t<https_url>\t</abs/path>
#   path: </abs/path>
#   slug: <owner/repo>
#
# Requires: fzf, repo-index. (Optionally: zoxide for frecency ordering.)

function repo_select() {
  setopt localoptions pipefail no_aliases 2> /dev/null

  local format="tsv"
  local prompt="repo> "
  local query=""
  local filter=""
  local debug=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --format)
        format="${2:?missing --format value}"
        shift 2
        ;;
      --format=*)
        format="${1#*=}"
        shift
        ;;
      --prompt)
        prompt="${2:?missing --prompt value}"
        shift 2
        ;;
      --prompt=*)
        prompt="${1#*=}"
        shift
        ;;
      --query)
        query="${2:?missing --query value}"
        shift 2
        ;;
      --query=*)
        query="${1#*=}"
        shift
        ;;
      --filter)
        filter="${2:?missing --filter value}"
        shift 2
        ;;
      --filter=*)
        filter="${1#*=}"
        shift
        ;;
      --debug)
        debug=1
        shift
        ;;
      -h|--help)
        cat <<'EOF'
Usage:
  repo_select [--format tsv|path|slug] [--prompt STR] [--query STR] [--filter STR] [--debug]
EOF
        return 0
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "repo_select: unknown arg: $1" >&2
        return 2
        ;;
    esac
  done

  if ! command -v fzf >/dev/null 2>&1; then
    echo "repo_select: missing fzf" >&2
    return 127
  fi

  local repo_index_cmd="repo-index"
  if ! command -v "$repo_index_cmd" >/dev/null 2>&1; then
    if [[ -n "${DOTFILES:-}" && -x "$DOTFILES/bin/repo-index" ]]; then
      repo_index_cmd="$DOTFILES/bin/repo-index"
    elif [[ -x "$HOME/dotfiles/bin/repo-index" ]]; then
      repo_index_cmd="$HOME/dotfiles/bin/repo-index"
    else
      echo "repo_select: missing repo-index (expected in \$PATH or \$DOTFILES/bin)" >&2
      return 127
    fi
  fi

  local tsv
  tsv="$("$repo_index_cmd" --format tsv 2>/dev/null)" || return $?
  [[ -n "$tsv" ]] || return 1

  local tab=$'\t'
  local -a lines ordered remaining
  lines=("${(@f)tsv}")

  if command -v zoxide >/dev/null 2>&1 && [[ -z "${REPO_SELECT_NO_ZOXIDE:-}" ]]; then
    local github_root="${GHPATH:-$HOME/code/github.com}"
    local zoxide_limit="${REPO_SELECT_ZOXIDE_LIMIT:-5000}"
    if [[ "$zoxide_limit" != <-> ]]; then
      zoxide_limit=5000
    fi

    local -F t0 t1
    local debug_enabled=0
    if (( debug )) || [[ -n "${REPO_SELECT_DEBUG:-}" ]]; then
      debug_enabled=1
      t0="${EPOCHREALTIME:-$SECONDS}"
    fi

    local -A line_by_root seen
    local -a repo_roots exception_roots
    line_by_root=()
    repo_roots=()
    exception_roots=()

    local line repo_path root
    for line in "${lines[@]}"; do
      repo_path="${line##*$tab}"
      root="$repo_path"
      line_by_root[$root]="$line"
      repo_roots+=("$root")

      if [[ "$root" != "$github_root"/*/* ]]; then
        exception_roots+=("$root")
      fi
    done

    local -a scored scored_sorted zo_roots
    scored=()

    if [[ -d "$github_root" ]]; then
      scored+=("${(@f)$(zoxide query -ls --all --base-dir "$github_root" 2>/dev/null | head -n "$zoxide_limit" || true)}")
    fi

    local r
    for r in "${exception_roots[@]}"; do
      [[ -d "$r" ]] || continue
      scored+=("${(@f)$(zoxide query -ls --all --base-dir "$r" 2>/dev/null | head -n "$zoxide_limit" || true)}")
    done

    if (( ${#scored[@]} > 0 )); then
      scored_sorted=("${(@f)$(printf '%s\n' "${scored[@]}" | LC_ALL=C sort -nr)}")
      zo_roots=()
      seen=()

      local score zo_path owner repo
      local scored_line
      for scored_line in "${scored_sorted[@]}"; do
        score=""
        zo_path=""
        IFS=$' \t' read -r score zo_path <<<"$scored_line"
        [[ -n "$zo_path" ]] || continue

        root=""
        if [[ "$zo_path" == "$github_root"/*/*(|/*) ]]; then
          owner="${zo_path#$github_root/}"
          owner="${owner%%/*}"
          repo="${zo_path#$github_root/$owner/}"
          repo="${repo%%/*}"
          root="$github_root/$owner/$repo"
        else
          for r in "${exception_roots[@]}"; do
            if [[ "$zo_path" == "$r"(|/*) ]]; then
              root="$r"
              break
            fi
          done
        fi

        if [[ -n "$root" && -n "${line_by_root[$root]:-}" && -z "${seen[$root]:-}" ]]; then
          zo_roots+=("$root")
          seen[$root]=1
        fi
      done

      ordered=()
      remaining=()
      for r in "${zo_roots[@]}"; do
        ordered+=("${line_by_root[$r]}")
      done
      for r in "${repo_roots[@]}"; do
        if [[ -z "${seen[$r]:-}" ]]; then
          remaining+=("${line_by_root[$r]}")
        fi
      done

      lines=("${ordered[@]}" "${remaining[@]}")
    fi

    if (( debug_enabled )); then
      t1="${EPOCHREALTIME:-$SECONDS}"
      printf 'repo_select: zoxide-order: repos=%d scored_lines=%d limit=%s base=%s elapsed=%.3fs\n' \
        "${#lines[@]}" "${#scored[@]}" "$zoxide_limit" "$github_root" "$((t1 - t0))" >&2
    fi
  fi

  local -a fzf_args
  fzf_args=(
    --ansi
    --reverse
    --no-sort
    --prompt="$prompt"
    --delimiter=$'\t'
    --with-nth=1,3
  )
  if [[ -n "$query" ]]; then
    fzf_args+=(--query="$query")
  fi
  if [[ -n "$filter" ]]; then
    fzf_args+=(--filter="$filter")
  fi

  local selection
  if tty -s 2>/dev/null; then
    selection="$(printf '%s\n' "${lines[@]}" | fzf "${fzf_args[@]}" </dev/tty)" || return $?
  else
    selection="$(printf '%s\n' "${lines[@]}" | fzf "${fzf_args[@]}")" || return $?
  fi
  [[ -n "$selection" ]] || return 1

  local selected_slug selected_path
  selected_slug="${selection%%$tab*}"
  selected_path="${selection##*$tab}"

  # Feed selection into zoxide (best-effort).
  if command -v zoxide >/dev/null 2>&1 && [[ -n "$selected_path" ]]; then
    zoxide add "$selected_path" >/dev/null 2>&1 || true
  fi

  case "$format" in
    tsv)  print -r -- "$selection" ;;
    path) print -r -- "$selected_path" ;;
    slug) print -r -- "$selected_slug" ;;
    *)
      echo "repo_select: unknown format: $format" >&2
      return 2
      ;;
  esac
}

repo_select "$@"
