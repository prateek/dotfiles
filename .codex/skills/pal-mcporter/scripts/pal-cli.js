#!/usr/bin/env node
//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __exportAll = (all, symbols) => {
	let target = {};
	for (var name in all) {
		__defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	}
	if (symbols) {
		__defProp(target, Symbol.toStringTag, { value: "Module" });
	}
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let node_child_process = require("node:child_process");
let node_path = require("node:path");
node_path = __toESM(node_path);
let node_fs = require("node:fs");
node_fs = __toESM(node_fs);
let node_process = require("node:process");
node_process = __toESM(node_process);
let node_fs_promises = require("node:fs/promises");
node_fs_promises = __toESM(node_fs_promises);
let node_os = require("node:os");
node_os = __toESM(node_os);
let node_url = require("node:url");
let node_module = require("node:module");
let node_stream = require("node:stream");
let node_crypto = require("node:crypto");
node_crypto = __toESM(node_crypto);
let node_http = require("node:http");
node_http = __toESM(node_http);

//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/commander/lib/error.js
var require_error = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* CommanderError class
	*/
	var CommanderError = class extends Error {
		/**
		* Constructs the CommanderError class
		* @param {number} exitCode suggested exit code which could be used with process.exit
		* @param {string} code an id string representing the error
		* @param {string} message human-readable description of the error
		*/
		constructor(exitCode, code, message) {
			super(message);
			Error.captureStackTrace(this, this.constructor);
			this.name = this.constructor.name;
			this.code = code;
			this.exitCode = exitCode;
			this.nestedError = undefined;
		}
	};
	/**
	* InvalidArgumentError class
	*/
	var InvalidArgumentError = class extends CommanderError {
		/**
		* Constructs the InvalidArgumentError class
		* @param {string} [message] explanation of why argument is invalid
		*/
		constructor(message) {
			super(1, "commander.invalidArgument", message);
			Error.captureStackTrace(this, this.constructor);
			this.name = this.constructor.name;
		}
	};
	exports.CommanderError = CommanderError;
	exports.InvalidArgumentError = InvalidArgumentError;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/commander/lib/argument.js
var require_argument = /* @__PURE__ */ __commonJSMin(((exports) => {
	const { InvalidArgumentError } = require_error();
	var Argument = class {
		/**
		* Initialize a new command argument with the given name and description.
		* The default is that the argument is required, and you can explicitly
		* indicate this with <> around the name. Put [] around the name for an optional argument.
		*
		* @param {string} name
		* @param {string} [description]
		*/
		constructor(name, description) {
			this.description = description || "";
			this.variadic = false;
			this.parseArg = undefined;
			this.defaultValue = undefined;
			this.defaultValueDescription = undefined;
			this.argChoices = undefined;
			switch (name[0]) {
				case "<":
					this.required = true;
					this._name = name.slice(1, -1);
					break;
				case "[":
					this.required = false;
					this._name = name.slice(1, -1);
					break;
				default:
					this.required = true;
					this._name = name;
					break;
			}
			if (this._name.endsWith("...")) {
				this.variadic = true;
				this._name = this._name.slice(0, -3);
			}
		}
		/**
		* Return argument name.
		*
		* @return {string}
		*/
		name() {
			return this._name;
		}
		/**
		* @package
		*/
		_collectValue(value, previous) {
			if (previous === this.defaultValue || !Array.isArray(previous)) {
				return [value];
			}
			previous.push(value);
			return previous;
		}
		/**
		* Set the default value, and optionally supply the description to be displayed in the help.
		*
		* @param {*} value
		* @param {string} [description]
		* @return {Argument}
		*/
		default(value, description) {
			this.defaultValue = value;
			this.defaultValueDescription = description;
			return this;
		}
		/**
		* Set the custom handler for processing CLI command arguments into argument values.
		*
		* @param {Function} [fn]
		* @return {Argument}
		*/
		argParser(fn) {
			this.parseArg = fn;
			return this;
		}
		/**
		* Only allow argument value to be one of choices.
		*
		* @param {string[]} values
		* @return {Argument}
		*/
		choices(values) {
			this.argChoices = values.slice();
			this.parseArg = (arg, previous) => {
				if (!this.argChoices.includes(arg)) {
					throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
				}
				if (this.variadic) {
					return this._collectValue(arg, previous);
				}
				return arg;
			};
			return this;
		}
		/**
		* Make argument required.
		*
		* @returns {Argument}
		*/
		argRequired() {
			this.required = true;
			return this;
		}
		/**
		* Make argument optional.
		*
		* @returns {Argument}
		*/
		argOptional() {
			this.required = false;
			return this;
		}
	};
	/**
	* Takes an argument and returns its human readable equivalent for help usage.
	*
	* @param {Argument} arg
	* @return {string}
	* @private
	*/
	function humanReadableArgName(arg) {
		const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
		return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
	}
	exports.Argument = Argument;
	exports.humanReadableArgName = humanReadableArgName;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/commander/lib/help.js
var require_help = /* @__PURE__ */ __commonJSMin(((exports) => {
	const { humanReadableArgName } = require_argument();
	/**
	* TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
	* https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
	* @typedef { import("./argument.js").Argument } Argument
	* @typedef { import("./command.js").Command } Command
	* @typedef { import("./option.js").Option } Option
	*/
	var Help = class {
		constructor() {
			this.helpWidth = undefined;
			this.minWidthToWrap = 40;
			this.sortSubcommands = false;
			this.sortOptions = false;
			this.showGlobalOptions = false;
		}
		/**
		* prepareContext is called by Commander after applying overrides from `Command.configureHelp()`
		* and just before calling `formatHelp()`.
		*
		* Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.
		*
		* @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions
		*/
		prepareContext(contextOptions) {
			this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
		}
		/**
		* Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
		*
		* @param {Command} cmd
		* @returns {Command[]}
		*/
		visibleCommands(cmd) {
			const visibleCommands = cmd.commands.filter((cmd$1) => !cmd$1._hidden);
			const helpCommand = cmd._getHelpCommand();
			if (helpCommand && !helpCommand._hidden) {
				visibleCommands.push(helpCommand);
			}
			if (this.sortSubcommands) {
				visibleCommands.sort((a, b) => {
					return a.name().localeCompare(b.name());
				});
			}
			return visibleCommands;
		}
		/**
		* Compare options for sort.
		*
		* @param {Option} a
		* @param {Option} b
		* @returns {number}
		*/
		compareOptions(a, b) {
			const getSortKey = (option) => {
				return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
			};
			return getSortKey(a).localeCompare(getSortKey(b));
		}
		/**
		* Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
		*
		* @param {Command} cmd
		* @returns {Option[]}
		*/
		visibleOptions(cmd) {
			const visibleOptions = cmd.options.filter((option) => !option.hidden);
			const helpOption = cmd._getHelpOption();
			if (helpOption && !helpOption.hidden) {
				const removeShort = helpOption.short && cmd._findOption(helpOption.short);
				const removeLong = helpOption.long && cmd._findOption(helpOption.long);
				if (!removeShort && !removeLong) {
					visibleOptions.push(helpOption);
				} else if (helpOption.long && !removeLong) {
					visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
				} else if (helpOption.short && !removeShort) {
					visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
				}
			}
			if (this.sortOptions) {
				visibleOptions.sort(this.compareOptions);
			}
			return visibleOptions;
		}
		/**
		* Get an array of the visible global options. (Not including help.)
		*
		* @param {Command} cmd
		* @returns {Option[]}
		*/
		visibleGlobalOptions(cmd) {
			if (!this.showGlobalOptions) return [];
			const globalOptions = [];
			for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
				const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
				globalOptions.push(...visibleOptions);
			}
			if (this.sortOptions) {
				globalOptions.sort(this.compareOptions);
			}
			return globalOptions;
		}
		/**
		* Get an array of the arguments if any have a description.
		*
		* @param {Command} cmd
		* @returns {Argument[]}
		*/
		visibleArguments(cmd) {
			if (cmd._argsDescription) {
				cmd.registeredArguments.forEach((argument) => {
					argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
				});
			}
			if (cmd.registeredArguments.find((argument) => argument.description)) {
				return cmd.registeredArguments;
			}
			return [];
		}
		/**
		* Get the command term to show in the list of subcommands.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		subcommandTerm(cmd) {
			const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
			return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
		}
		/**
		* Get the option term to show in the list of options.
		*
		* @param {Option} option
		* @returns {string}
		*/
		optionTerm(option) {
			return option.flags;
		}
		/**
		* Get the argument term to show in the list of arguments.
		*
		* @param {Argument} argument
		* @returns {string}
		*/
		argumentTerm(argument) {
			return argument.name();
		}
		/**
		* Get the longest command term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestSubcommandTermLength(cmd, helper) {
			return helper.visibleCommands(cmd).reduce((max, command) => {
				return Math.max(max, this.displayWidth(helper.styleSubcommandTerm(helper.subcommandTerm(command))));
			}, 0);
		}
		/**
		* Get the longest option term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestOptionTermLength(cmd, helper) {
			return helper.visibleOptions(cmd).reduce((max, option) => {
				return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
			}, 0);
		}
		/**
		* Get the longest global option term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestGlobalOptionTermLength(cmd, helper) {
			return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
				return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
			}, 0);
		}
		/**
		* Get the longest argument term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestArgumentTermLength(cmd, helper) {
			return helper.visibleArguments(cmd).reduce((max, argument) => {
				return Math.max(max, this.displayWidth(helper.styleArgumentTerm(helper.argumentTerm(argument))));
			}, 0);
		}
		/**
		* Get the command usage to be displayed at the top of the built-in help.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		commandUsage(cmd) {
			let cmdName = cmd._name;
			if (cmd._aliases[0]) {
				cmdName = cmdName + "|" + cmd._aliases[0];
			}
			let ancestorCmdNames = "";
			for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
				ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
			}
			return ancestorCmdNames + cmdName + " " + cmd.usage();
		}
		/**
		* Get the description for the command.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		commandDescription(cmd) {
			return cmd.description();
		}
		/**
		* Get the subcommand summary to show in the list of subcommands.
		* (Fallback to description for backwards compatibility.)
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		subcommandDescription(cmd) {
			return cmd.summary() || cmd.description();
		}
		/**
		* Get the option description to show in the list of options.
		*
		* @param {Option} option
		* @return {string}
		*/
		optionDescription(option) {
			const extraInfo = [];
			if (option.argChoices) {
				extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
			}
			if (option.defaultValue !== undefined) {
				const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
				if (showDefault) {
					extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
				}
			}
			if (option.presetArg !== undefined && option.optional) {
				extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
			}
			if (option.envVar !== undefined) {
				extraInfo.push(`env: ${option.envVar}`);
			}
			if (extraInfo.length > 0) {
				const extraDescription = `(${extraInfo.join(", ")})`;
				if (option.description) {
					return `${option.description} ${extraDescription}`;
				}
				return extraDescription;
			}
			return option.description;
		}
		/**
		* Get the argument description to show in the list of arguments.
		*
		* @param {Argument} argument
		* @return {string}
		*/
		argumentDescription(argument) {
			const extraInfo = [];
			if (argument.argChoices) {
				extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
			}
			if (argument.defaultValue !== undefined) {
				extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
			}
			if (extraInfo.length > 0) {
				const extraDescription = `(${extraInfo.join(", ")})`;
				if (argument.description) {
					return `${argument.description} ${extraDescription}`;
				}
				return extraDescription;
			}
			return argument.description;
		}
		/**
		* Format a list of items, given a heading and an array of formatted items.
		*
		* @param {string} heading
		* @param {string[]} items
		* @param {Help} helper
		* @returns string[]
		*/
		formatItemList(heading, items, helper) {
			if (items.length === 0) return [];
			return [
				helper.styleTitle(heading),
				...items,
				""
			];
		}
		/**
		* Group items by their help group heading.
		*
		* @param {Command[] | Option[]} unsortedItems
		* @param {Command[] | Option[]} visibleItems
		* @param {Function} getGroup
		* @returns {Map<string, Command[] | Option[]>}
		*/
		groupItems(unsortedItems, visibleItems, getGroup) {
			const result = new Map();
			unsortedItems.forEach((item) => {
				const group = getGroup(item);
				if (!result.has(group)) result.set(group, []);
			});
			visibleItems.forEach((item) => {
				const group = getGroup(item);
				if (!result.has(group)) {
					result.set(group, []);
				}
				result.get(group).push(item);
			});
			return result;
		}
		/**
		* Generate the built-in help text.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {string}
		*/
		formatHelp(cmd, helper) {
			const termWidth = helper.padWidth(cmd, helper);
			const helpWidth = helper.helpWidth ?? 80;
			function callFormatItem(term, description) {
				return helper.formatItem(term, termWidth, description, helper);
			}
			let output = [`${helper.styleTitle("Usage:")} ${helper.styleUsage(helper.commandUsage(cmd))}`, ""];
			const commandDescription = helper.commandDescription(cmd);
			if (commandDescription.length > 0) {
				output = output.concat([helper.boxWrap(helper.styleCommandDescription(commandDescription), helpWidth), ""]);
			}
			const argumentList = helper.visibleArguments(cmd).map((argument) => {
				return callFormatItem(helper.styleArgumentTerm(helper.argumentTerm(argument)), helper.styleArgumentDescription(helper.argumentDescription(argument)));
			});
			output = output.concat(this.formatItemList("Arguments:", argumentList, helper));
			const optionGroups = this.groupItems(cmd.options, helper.visibleOptions(cmd), (option) => option.helpGroupHeading ?? "Options:");
			optionGroups.forEach((options, group) => {
				const optionList = options.map((option) => {
					return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
				});
				output = output.concat(this.formatItemList(group, optionList, helper));
			});
			if (helper.showGlobalOptions) {
				const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
					return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
				});
				output = output.concat(this.formatItemList("Global Options:", globalOptionList, helper));
			}
			const commandGroups = this.groupItems(cmd.commands, helper.visibleCommands(cmd), (sub) => sub.helpGroup() || "Commands:");
			commandGroups.forEach((commands, group) => {
				const commandList = commands.map((sub) => {
					return callFormatItem(helper.styleSubcommandTerm(helper.subcommandTerm(sub)), helper.styleSubcommandDescription(helper.subcommandDescription(sub)));
				});
				output = output.concat(this.formatItemList(group, commandList, helper));
			});
			return output.join("\n");
		}
		/**
		* Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.
		*
		* @param {string} str
		* @returns {number}
		*/
		displayWidth(str) {
			return stripColor(str).length;
		}
		/**
		* Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.
		*
		* @param {string} str
		* @returns {string}
		*/
		styleTitle(str) {
			return str;
		}
		styleUsage(str) {
			return str.split(" ").map((word) => {
				if (word === "[options]") return this.styleOptionText(word);
				if (word === "[command]") return this.styleSubcommandText(word);
				if (word[0] === "[" || word[0] === "<") return this.styleArgumentText(word);
				return this.styleCommandText(word);
			}).join(" ");
		}
		styleCommandDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleOptionDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleSubcommandDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleArgumentDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleDescriptionText(str) {
			return str;
		}
		styleOptionTerm(str) {
			return this.styleOptionText(str);
		}
		styleSubcommandTerm(str) {
			return str.split(" ").map((word) => {
				if (word === "[options]") return this.styleOptionText(word);
				if (word[0] === "[" || word[0] === "<") return this.styleArgumentText(word);
				return this.styleSubcommandText(word);
			}).join(" ");
		}
		styleArgumentTerm(str) {
			return this.styleArgumentText(str);
		}
		styleOptionText(str) {
			return str;
		}
		styleArgumentText(str) {
			return str;
		}
		styleSubcommandText(str) {
			return str;
		}
		styleCommandText(str) {
			return str;
		}
		/**
		* Calculate the pad width from the maximum term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		padWidth(cmd, helper) {
			return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
		}
		/**
		* Detect manually wrapped and indented strings by checking for line break followed by whitespace.
		*
		* @param {string} str
		* @returns {boolean}
		*/
		preformatted(str) {
			return /\n[^\S\r\n]/.test(str);
		}
		/**
		* Format the "item", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.
		*
		* So "TTT", 5, "DDD DDDD DD DDD" might be formatted for this.helpWidth=17 like so:
		*   TTT  DDD DDDD
		*        DD DDD
		*
		* @param {string} term
		* @param {number} termWidth
		* @param {string} description
		* @param {Help} helper
		* @returns {string}
		*/
		formatItem(term, termWidth, description, helper) {
			const itemIndent = 2;
			const itemIndentStr = " ".repeat(itemIndent);
			if (!description) return itemIndentStr + term;
			const paddedTerm = term.padEnd(termWidth + term.length - helper.displayWidth(term));
			const spacerWidth = 2;
			const helpWidth = this.helpWidth ?? 80;
			const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
			let formattedDescription;
			if (remainingWidth < this.minWidthToWrap || helper.preformatted(description)) {
				formattedDescription = description;
			} else {
				const wrappedDescription = helper.boxWrap(description, remainingWidth);
				formattedDescription = wrappedDescription.replace(/\n/g, "\n" + " ".repeat(termWidth + spacerWidth));
			}
			return itemIndentStr + paddedTerm + " ".repeat(spacerWidth) + formattedDescription.replace(/\n/g, `\n${itemIndentStr}`);
		}
		/**
		* Wrap a string at whitespace, preserving existing line breaks.
		* Wrapping is skipped if the width is less than `minWidthToWrap`.
		*
		* @param {string} str
		* @param {number} width
		* @returns {string}
		*/
		boxWrap(str, width) {
			if (width < this.minWidthToWrap) return str;
			const rawLines = str.split(/\r\n|\n/);
			const chunkPattern = /[\s]*[^\s]+/g;
			const wrappedLines = [];
			rawLines.forEach((line) => {
				const chunks = line.match(chunkPattern);
				if (chunks === null) {
					wrappedLines.push("");
					return;
				}
				let sumChunks = [chunks.shift()];
				let sumWidth = this.displayWidth(sumChunks[0]);
				chunks.forEach((chunk) => {
					const visibleWidth = this.displayWidth(chunk);
					if (sumWidth + visibleWidth <= width) {
						sumChunks.push(chunk);
						sumWidth += visibleWidth;
						return;
					}
					wrappedLines.push(sumChunks.join(""));
					const nextChunk = chunk.trimStart();
					sumChunks = [nextChunk];
					sumWidth = this.displayWidth(nextChunk);
				});
				wrappedLines.push(sumChunks.join(""));
			});
			return wrappedLines.join("\n");
		}
	};
	/**
	* Strip style ANSI escape sequences from the string. In particular, SGR (Select Graphic Rendition) codes.
	*
	* @param {string} str
	* @returns {string}
	* @package
	*/
	function stripColor(str) {
		const sgrPattern = /\x1b\[\d*(;\d*)*m/g;
		return str.replace(sgrPattern, "");
	}
	exports.Help = Help;
	exports.stripColor = stripColor;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/commander/lib/option.js
var require_option = /* @__PURE__ */ __commonJSMin(((exports) => {
	const { InvalidArgumentError } = require_error();
	var Option = class {
		/**
		* Initialize a new `Option` with the given `flags` and `description`.
		*
		* @param {string} flags
		* @param {string} [description]
		*/
		constructor(flags, description) {
			this.flags = flags;
			this.description = description || "";
			this.required = flags.includes("<");
			this.optional = flags.includes("[");
			this.variadic = /\w\.\.\.[>\]]$/.test(flags);
			this.mandatory = false;
			const optionFlags = splitOptionFlags(flags);
			this.short = optionFlags.shortFlag;
			this.long = optionFlags.longFlag;
			this.negate = false;
			if (this.long) {
				this.negate = this.long.startsWith("--no-");
			}
			this.defaultValue = undefined;
			this.defaultValueDescription = undefined;
			this.presetArg = undefined;
			this.envVar = undefined;
			this.parseArg = undefined;
			this.hidden = false;
			this.argChoices = undefined;
			this.conflictsWith = [];
			this.implied = undefined;
			this.helpGroupHeading = undefined;
		}
		/**
		* Set the default value, and optionally supply the description to be displayed in the help.
		*
		* @param {*} value
		* @param {string} [description]
		* @return {Option}
		*/
		default(value, description) {
			this.defaultValue = value;
			this.defaultValueDescription = description;
			return this;
		}
		/**
		* Preset to use when option used without option-argument, especially optional but also boolean and negated.
		* The custom processing (parseArg) is called.
		*
		* @example
		* new Option('--color').default('GREYSCALE').preset('RGB');
		* new Option('--donate [amount]').preset('20').argParser(parseFloat);
		*
		* @param {*} arg
		* @return {Option}
		*/
		preset(arg) {
			this.presetArg = arg;
			return this;
		}
		/**
		* Add option name(s) that conflict with this option.
		* An error will be displayed if conflicting options are found during parsing.
		*
		* @example
		* new Option('--rgb').conflicts('cmyk');
		* new Option('--js').conflicts(['ts', 'jsx']);
		*
		* @param {(string | string[])} names
		* @return {Option}
		*/
		conflicts(names) {
			this.conflictsWith = this.conflictsWith.concat(names);
			return this;
		}
		/**
		* Specify implied option values for when this option is set and the implied options are not.
		*
		* The custom processing (parseArg) is not called on the implied values.
		*
		* @example
		* program
		*   .addOption(new Option('--log', 'write logging information to file'))
		*   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
		*
		* @param {object} impliedOptionValues
		* @return {Option}
		*/
		implies(impliedOptionValues) {
			let newImplied = impliedOptionValues;
			if (typeof impliedOptionValues === "string") {
				newImplied = { [impliedOptionValues]: true };
			}
			this.implied = Object.assign(this.implied || {}, newImplied);
			return this;
		}
		/**
		* Set environment variable to check for option value.
		*
		* An environment variable is only used if when processed the current option value is
		* undefined, or the source of the current value is 'default' or 'config' or 'env'.
		*
		* @param {string} name
		* @return {Option}
		*/
		env(name) {
			this.envVar = name;
			return this;
		}
		/**
		* Set the custom handler for processing CLI option arguments into option values.
		*
		* @param {Function} [fn]
		* @return {Option}
		*/
		argParser(fn) {
			this.parseArg = fn;
			return this;
		}
		/**
		* Whether the option is mandatory and must have a value after parsing.
		*
		* @param {boolean} [mandatory=true]
		* @return {Option}
		*/
		makeOptionMandatory(mandatory = true) {
			this.mandatory = !!mandatory;
			return this;
		}
		/**
		* Hide option in help.
		*
		* @param {boolean} [hide=true]
		* @return {Option}
		*/
		hideHelp(hide = true) {
			this.hidden = !!hide;
			return this;
		}
		/**
		* @package
		*/
		_collectValue(value, previous) {
			if (previous === this.defaultValue || !Array.isArray(previous)) {
				return [value];
			}
			previous.push(value);
			return previous;
		}
		/**
		* Only allow option value to be one of choices.
		*
		* @param {string[]} values
		* @return {Option}
		*/
		choices(values) {
			this.argChoices = values.slice();
			this.parseArg = (arg, previous) => {
				if (!this.argChoices.includes(arg)) {
					throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
				}
				if (this.variadic) {
					return this._collectValue(arg, previous);
				}
				return arg;
			};
			return this;
		}
		/**
		* Return option name.
		*
		* @return {string}
		*/
		name() {
			if (this.long) {
				return this.long.replace(/^--/, "");
			}
			return this.short.replace(/^-/, "");
		}
		/**
		* Return option name, in a camelcase format that can be used
		* as an object attribute key.
		*
		* @return {string}
		*/
		attributeName() {
			if (this.negate) {
				return camelcase(this.name().replace(/^no-/, ""));
			}
			return camelcase(this.name());
		}
		/**
		* Set the help group heading.
		*
		* @param {string} heading
		* @return {Option}
		*/
		helpGroup(heading) {
			this.helpGroupHeading = heading;
			return this;
		}
		/**
		* Check if `arg` matches the short or long flag.
		*
		* @param {string} arg
		* @return {boolean}
		* @package
		*/
		is(arg) {
			return this.short === arg || this.long === arg;
		}
		/**
		* Return whether a boolean option.
		*
		* Options are one of boolean, negated, required argument, or optional argument.
		*
		* @return {boolean}
		* @package
		*/
		isBoolean() {
			return !this.required && !this.optional && !this.negate;
		}
	};
	/**
	* This class is to make it easier to work with dual options, without changing the existing
	* implementation. We support separate dual options for separate positive and negative options,
	* like `--build` and `--no-build`, which share a single option value. This works nicely for some
	* use cases, but is tricky for others where we want separate behaviours despite
	* the single shared option value.
	*/
	var DualOptions = class {
		/**
		* @param {Option[]} options
		*/
		constructor(options) {
			this.positiveOptions = new Map();
			this.negativeOptions = new Map();
			this.dualOptions = new Set();
			options.forEach((option) => {
				if (option.negate) {
					this.negativeOptions.set(option.attributeName(), option);
				} else {
					this.positiveOptions.set(option.attributeName(), option);
				}
			});
			this.negativeOptions.forEach((value, key) => {
				if (this.positiveOptions.has(key)) {
					this.dualOptions.add(key);
				}
			});
		}
		/**
		* Did the value come from the option, and not from possible matching dual option?
		*
		* @param {*} value
		* @param {Option} option
		* @returns {boolean}
		*/
		valueFromOption(value, option) {
			const optionKey = option.attributeName();
			if (!this.dualOptions.has(optionKey)) return true;
			const preset = this.negativeOptions.get(optionKey).presetArg;
			const negativeValue = preset !== undefined ? preset : false;
			return option.negate === (negativeValue === value);
		}
	};
	/**
	* Convert string from kebab-case to camelCase.
	*
	* @param {string} str
	* @return {string}
	* @private
	*/
	function camelcase(str) {
		return str.split("-").reduce((str$1, word) => {
			return str$1 + word[0].toUpperCase() + word.slice(1);
		});
	}
	/**
	* Split the short and long flag out of something like '-m,--mixed <value>'
	*
	* @private
	*/
	function splitOptionFlags(flags) {
		let shortFlag;
		let longFlag;
		const shortFlagExp = /^-[^-]$/;
		const longFlagExp = /^--[^-]/;
		const flagParts = flags.split(/[ |,]+/).concat("guard");
		if (shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
		if (longFlagExp.test(flagParts[0])) longFlag = flagParts.shift();
		if (!shortFlag && shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
		if (!shortFlag && longFlagExp.test(flagParts[0])) {
			shortFlag = longFlag;
			longFlag = flagParts.shift();
		}
		if (flagParts[0].startsWith("-")) {
			const unsupportedFlag = flagParts[0];
			const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
			if (/^-[^-][^-]/.test(unsupportedFlag)) throw new Error(`${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);
			if (shortFlagExp.test(unsupportedFlag)) throw new Error(`${baseError}
- too many short flags`);
			if (longFlagExp.test(unsupportedFlag)) throw new Error(`${baseError}
- too many long flags`);
			throw new Error(`${baseError}
- unrecognised flag format`);
		}
		if (shortFlag === undefined && longFlag === undefined) throw new Error(`option creation failed due to no flags found in '${flags}'.`);
		return {
			shortFlag,
			longFlag
		};
	}
	exports.Option = Option;
	exports.DualOptions = DualOptions;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = /* @__PURE__ */ __commonJSMin(((exports) => {
	const maxDistance = 3;
	function editDistance(a, b) {
		if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);
		const d = [];
		for (let i = 0; i <= a.length; i++) {
			d[i] = [i];
		}
		for (let j = 0; j <= b.length; j++) {
			d[0][j] = j;
		}
		for (let j = 1; j <= b.length; j++) {
			for (let i = 1; i <= a.length; i++) {
				let cost = 1;
				if (a[i - 1] === b[j - 1]) {
					cost = 0;
				} else {
					cost = 1;
				}
				d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
				if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
					d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
				}
			}
		}
		return d[a.length][b.length];
	}
	/**
	* Find close matches, restricted to same number of edits.
	*
	* @param {string} word
	* @param {string[]} candidates
	* @returns {string}
	*/
	function suggestSimilar(word, candidates) {
		if (!candidates || candidates.length === 0) return "";
		candidates = Array.from(new Set(candidates));
		const searchingOptions = word.startsWith("--");
		if (searchingOptions) {
			word = word.slice(2);
			candidates = candidates.map((candidate) => candidate.slice(2));
		}
		let similar = [];
		let bestDistance = maxDistance;
		const minSimilarity = .4;
		candidates.forEach((candidate) => {
			if (candidate.length <= 1) return;
			const distance = editDistance(word, candidate);
			const length = Math.max(word.length, candidate.length);
			const similarity = (length - distance) / length;
			if (similarity > minSimilarity) {
				if (distance < bestDistance) {
					bestDistance = distance;
					similar = [candidate];
				} else if (distance === bestDistance) {
					similar.push(candidate);
				}
			}
		});
		similar.sort((a, b) => a.localeCompare(b));
		if (searchingOptions) {
			similar = similar.map((candidate) => `--${candidate}`);
		}
		if (similar.length > 1) {
			return `\n(Did you mean one of ${similar.join(", ")}?)`;
		}
		if (similar.length === 1) {
			return `\n(Did you mean ${similar[0]}?)`;
		}
		return "";
	}
	exports.suggestSimilar = suggestSimilar;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/commander/lib/command.js
var require_command = /* @__PURE__ */ __commonJSMin(((exports) => {
	const EventEmitter = require("node:events").EventEmitter;
	const childProcess = require("node:child_process");
	const path$11 = require("node:path");
	const fs$11 = require("node:fs");
	const process$3 = require("node:process");
	const { Argument, humanReadableArgName } = require_argument();
	const { CommanderError } = require_error();
	const { Help, stripColor } = require_help();
	const { Option, DualOptions } = require_option();
	const { suggestSimilar } = require_suggestSimilar();
	var Command = class Command extends EventEmitter {
		/**
		* Initialize a new `Command`.
		*
		* @param {string} [name]
		*/
		constructor(name) {
			super();
			/** @type {Command[]} */
			this.commands = [];
			/** @type {Option[]} */
			this.options = [];
			this.parent = null;
			this._allowUnknownOption = false;
			this._allowExcessArguments = false;
			/** @type {Argument[]} */
			this.registeredArguments = [];
			this._args = this.registeredArguments;
			/** @type {string[]} */
			this.args = [];
			this.rawArgs = [];
			this.processedArgs = [];
			this._scriptPath = null;
			this._name = name || "";
			this._optionValues = {};
			this._optionValueSources = {};
			this._storeOptionsAsProperties = false;
			this._actionHandler = null;
			this._executableHandler = false;
			this._executableFile = null;
			this._executableDir = null;
			this._defaultCommandName = null;
			this._exitCallback = null;
			this._aliases = [];
			this._combineFlagAndOptionalValue = true;
			this._description = "";
			this._summary = "";
			this._argsDescription = undefined;
			this._enablePositionalOptions = false;
			this._passThroughOptions = false;
			this._lifeCycleHooks = {};
			/** @type {(boolean | string)} */
			this._showHelpAfterError = false;
			this._showSuggestionAfterError = true;
			this._savedState = null;
			this._outputConfiguration = {
				writeOut: (str) => process$3.stdout.write(str),
				writeErr: (str) => process$3.stderr.write(str),
				outputError: (str, write) => write(str),
				getOutHelpWidth: () => process$3.stdout.isTTY ? process$3.stdout.columns : undefined,
				getErrHelpWidth: () => process$3.stderr.isTTY ? process$3.stderr.columns : undefined,
				getOutHasColors: () => useColor() ?? (process$3.stdout.isTTY && process$3.stdout.hasColors?.()),
				getErrHasColors: () => useColor() ?? (process$3.stderr.isTTY && process$3.stderr.hasColors?.()),
				stripColor: (str) => stripColor(str)
			};
			this._hidden = false;
			/** @type {(Option | null | undefined)} */
			this._helpOption = undefined;
			this._addImplicitHelpCommand = undefined;
			/** @type {Command} */
			this._helpCommand = undefined;
			this._helpConfiguration = {};
			/** @type {string | undefined} */
			this._helpGroupHeading = undefined;
			/** @type {string | undefined} */
			this._defaultCommandGroup = undefined;
			/** @type {string | undefined} */
			this._defaultOptionGroup = undefined;
		}
		/**
		* Copy settings that are useful to have in common across root command and subcommands.
		*
		* (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
		*
		* @param {Command} sourceCommand
		* @return {Command} `this` command for chaining
		*/
		copyInheritedSettings(sourceCommand) {
			this._outputConfiguration = sourceCommand._outputConfiguration;
			this._helpOption = sourceCommand._helpOption;
			this._helpCommand = sourceCommand._helpCommand;
			this._helpConfiguration = sourceCommand._helpConfiguration;
			this._exitCallback = sourceCommand._exitCallback;
			this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
			this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
			this._allowExcessArguments = sourceCommand._allowExcessArguments;
			this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
			this._showHelpAfterError = sourceCommand._showHelpAfterError;
			this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
			return this;
		}
		/**
		* @returns {Command[]}
		* @private
		*/
		_getCommandAndAncestors() {
			const result = [];
			for (let command = this; command; command = command.parent) {
				result.push(command);
			}
			return result;
		}
		/**
		* Define a command.
		*
		* There are two styles of command: pay attention to where to put the description.
		*
		* @example
		* // Command implemented using action handler (description is supplied separately to `.command`)
		* program
		*   .command('clone <source> [destination]')
		*   .description('clone a repository into a newly created directory')
		*   .action((source, destination) => {
		*     console.log('clone command called');
		*   });
		*
		* // Command implemented using separate executable file (description is second parameter to `.command`)
		* program
		*   .command('start <service>', 'start named service')
		*   .command('stop [service]', 'stop named service, or all if no name supplied');
		*
		* @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
		* @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
		* @param {object} [execOpts] - configuration options (for executable)
		* @return {Command} returns new command for action handler, or `this` for executable command
		*/
		command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
			let desc = actionOptsOrExecDesc;
			let opts = execOpts;
			if (typeof desc === "object" && desc !== null) {
				opts = desc;
				desc = null;
			}
			opts = opts || {};
			const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
			const cmd = this.createCommand(name);
			if (desc) {
				cmd.description(desc);
				cmd._executableHandler = true;
			}
			if (opts.isDefault) this._defaultCommandName = cmd._name;
			cmd._hidden = !!(opts.noHelp || opts.hidden);
			cmd._executableFile = opts.executableFile || null;
			if (args) cmd.arguments(args);
			this._registerCommand(cmd);
			cmd.parent = this;
			cmd.copyInheritedSettings(this);
			if (desc) return this;
			return cmd;
		}
		/**
		* Factory routine to create a new unattached command.
		*
		* See .command() for creating an attached subcommand, which uses this routine to
		* create the command. You can override createCommand to customise subcommands.
		*
		* @param {string} [name]
		* @return {Command} new command
		*/
		createCommand(name) {
			return new Command(name);
		}
		/**
		* You can customise the help with a subclass of Help by overriding createHelp,
		* or by overriding Help properties using configureHelp().
		*
		* @return {Help}
		*/
		createHelp() {
			return Object.assign(new Help(), this.configureHelp());
		}
		/**
		* You can customise the help by overriding Help properties using configureHelp(),
		* or with a subclass of Help by overriding createHelp().
		*
		* @param {object} [configuration] - configuration options
		* @return {(Command | object)} `this` command for chaining, or stored configuration
		*/
		configureHelp(configuration) {
			if (configuration === undefined) return this._helpConfiguration;
			this._helpConfiguration = configuration;
			return this;
		}
		/**
		* The default output goes to stdout and stderr. You can customise this for special
		* applications. You can also customise the display of errors by overriding outputError.
		*
		* The configuration properties are all functions:
		*
		*     // change how output being written, defaults to stdout and stderr
		*     writeOut(str)
		*     writeErr(str)
		*     // change how output being written for errors, defaults to writeErr
		*     outputError(str, write) // used for displaying errors and not used for displaying help
		*     // specify width for wrapping help
		*     getOutHelpWidth()
		*     getErrHelpWidth()
		*     // color support, currently only used with Help
		*     getOutHasColors()
		*     getErrHasColors()
		*     stripColor() // used to remove ANSI escape codes if output does not have colors
		*
		* @param {object} [configuration] - configuration options
		* @return {(Command | object)} `this` command for chaining, or stored configuration
		*/
		configureOutput(configuration) {
			if (configuration === undefined) return this._outputConfiguration;
			this._outputConfiguration = {
				...this._outputConfiguration,
				...configuration
			};
			return this;
		}
		/**
		* Display the help or a custom message after an error occurs.
		*
		* @param {(boolean|string)} [displayHelp]
		* @return {Command} `this` command for chaining
		*/
		showHelpAfterError(displayHelp = true) {
			if (typeof displayHelp !== "string") displayHelp = !!displayHelp;
			this._showHelpAfterError = displayHelp;
			return this;
		}
		/**
		* Display suggestion of similar commands for unknown commands, or options for unknown options.
		*
		* @param {boolean} [displaySuggestion]
		* @return {Command} `this` command for chaining
		*/
		showSuggestionAfterError(displaySuggestion = true) {
			this._showSuggestionAfterError = !!displaySuggestion;
			return this;
		}
		/**
		* Add a prepared subcommand.
		*
		* See .command() for creating an attached subcommand which inherits settings from its parent.
		*
		* @param {Command} cmd - new subcommand
		* @param {object} [opts] - configuration options
		* @return {Command} `this` command for chaining
		*/
		addCommand(cmd, opts) {
			if (!cmd._name) {
				throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
			}
			opts = opts || {};
			if (opts.isDefault) this._defaultCommandName = cmd._name;
			if (opts.noHelp || opts.hidden) cmd._hidden = true;
			this._registerCommand(cmd);
			cmd.parent = this;
			cmd._checkForBrokenPassThrough();
			return this;
		}
		/**
		* Factory routine to create a new unattached argument.
		*
		* See .argument() for creating an attached argument, which uses this routine to
		* create the argument. You can override createArgument to return a custom argument.
		*
		* @param {string} name
		* @param {string} [description]
		* @return {Argument} new argument
		*/
		createArgument(name, description) {
			return new Argument(name, description);
		}
		/**
		* Define argument syntax for command.
		*
		* The default is that the argument is required, and you can explicitly
		* indicate this with <> around the name. Put [] around the name for an optional argument.
		*
		* @example
		* program.argument('<input-file>');
		* program.argument('[output-file]');
		*
		* @param {string} name
		* @param {string} [description]
		* @param {(Function|*)} [parseArg] - custom argument processing function or default value
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		argument(name, description, parseArg, defaultValue) {
			const argument = this.createArgument(name, description);
			if (typeof parseArg === "function") {
				argument.default(defaultValue).argParser(parseArg);
			} else {
				argument.default(parseArg);
			}
			this.addArgument(argument);
			return this;
		}
		/**
		* Define argument syntax for command, adding multiple at once (without descriptions).
		*
		* See also .argument().
		*
		* @example
		* program.arguments('<cmd> [env]');
		*
		* @param {string} names
		* @return {Command} `this` command for chaining
		*/
		arguments(names) {
			names.trim().split(/ +/).forEach((detail) => {
				this.argument(detail);
			});
			return this;
		}
		/**
		* Define argument syntax for command, adding a prepared argument.
		*
		* @param {Argument} argument
		* @return {Command} `this` command for chaining
		*/
		addArgument(argument) {
			const previousArgument = this.registeredArguments.slice(-1)[0];
			if (previousArgument?.variadic) {
				throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
			}
			if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
				throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
			}
			this.registeredArguments.push(argument);
			return this;
		}
		/**
		* Customise or override default help command. By default a help command is automatically added if your command has subcommands.
		*
		* @example
		*    program.helpCommand('help [cmd]');
		*    program.helpCommand('help [cmd]', 'show help');
		*    program.helpCommand(false); // suppress default help command
		*    program.helpCommand(true); // add help command even if no subcommands
		*
		* @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
		* @param {string} [description] - custom description
		* @return {Command} `this` command for chaining
		*/
		helpCommand(enableOrNameAndArgs, description) {
			if (typeof enableOrNameAndArgs === "boolean") {
				this._addImplicitHelpCommand = enableOrNameAndArgs;
				if (enableOrNameAndArgs && this._defaultCommandGroup) {
					this._initCommandGroup(this._getHelpCommand());
				}
				return this;
			}
			const nameAndArgs = enableOrNameAndArgs ?? "help [command]";
			const [, helpName, helpArgs] = nameAndArgs.match(/([^ ]+) *(.*)/);
			const helpDescription = description ?? "display help for command";
			const helpCommand = this.createCommand(helpName);
			helpCommand.helpOption(false);
			if (helpArgs) helpCommand.arguments(helpArgs);
			if (helpDescription) helpCommand.description(helpDescription);
			this._addImplicitHelpCommand = true;
			this._helpCommand = helpCommand;
			if (enableOrNameAndArgs || description) this._initCommandGroup(helpCommand);
			return this;
		}
		/**
		* Add prepared custom help command.
		*
		* @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
		* @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
		* @return {Command} `this` command for chaining
		*/
		addHelpCommand(helpCommand, deprecatedDescription) {
			if (typeof helpCommand !== "object") {
				this.helpCommand(helpCommand, deprecatedDescription);
				return this;
			}
			this._addImplicitHelpCommand = true;
			this._helpCommand = helpCommand;
			this._initCommandGroup(helpCommand);
			return this;
		}
		/**
		* Lazy create help command.
		*
		* @return {(Command|null)}
		* @package
		*/
		_getHelpCommand() {
			const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
			if (hasImplicitHelpCommand) {
				if (this._helpCommand === undefined) {
					this.helpCommand(undefined, undefined);
				}
				return this._helpCommand;
			}
			return null;
		}
		/**
		* Add hook for life cycle event.
		*
		* @param {string} event
		* @param {Function} listener
		* @return {Command} `this` command for chaining
		*/
		hook(event, listener) {
			const allowedValues = [
				"preSubcommand",
				"preAction",
				"postAction"
			];
			if (!allowedValues.includes(event)) {
				throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
			}
			if (this._lifeCycleHooks[event]) {
				this._lifeCycleHooks[event].push(listener);
			} else {
				this._lifeCycleHooks[event] = [listener];
			}
			return this;
		}
		/**
		* Register callback to use as replacement for calling process.exit.
		*
		* @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
		* @return {Command} `this` command for chaining
		*/
		exitOverride(fn) {
			if (fn) {
				this._exitCallback = fn;
			} else {
				this._exitCallback = (err) => {
					if (err.code !== "commander.executeSubCommandAsync") {
						throw err;
					} else {}
				};
			}
			return this;
		}
		/**
		* Call process.exit, and _exitCallback if defined.
		*
		* @param {number} exitCode exit code for using with process.exit
		* @param {string} code an id string representing the error
		* @param {string} message human-readable description of the error
		* @return never
		* @private
		*/
		_exit(exitCode, code, message) {
			if (this._exitCallback) {
				this._exitCallback(new CommanderError(exitCode, code, message));
			}
			process$3.exit(exitCode);
		}
		/**
		* Register callback `fn` for the command.
		*
		* @example
		* program
		*   .command('serve')
		*   .description('start service')
		*   .action(function() {
		*      // do work here
		*   });
		*
		* @param {Function} fn
		* @return {Command} `this` command for chaining
		*/
		action(fn) {
			const listener = (args) => {
				const expectedArgsCount = this.registeredArguments.length;
				const actionArgs = args.slice(0, expectedArgsCount);
				if (this._storeOptionsAsProperties) {
					actionArgs[expectedArgsCount] = this;
				} else {
					actionArgs[expectedArgsCount] = this.opts();
				}
				actionArgs.push(this);
				return fn.apply(this, actionArgs);
			};
			this._actionHandler = listener;
			return this;
		}
		/**
		* Factory routine to create a new unattached option.
		*
		* See .option() for creating an attached option, which uses this routine to
		* create the option. You can override createOption to return a custom option.
		*
		* @param {string} flags
		* @param {string} [description]
		* @return {Option} new option
		*/
		createOption(flags, description) {
			return new Option(flags, description);
		}
		/**
		* Wrap parseArgs to catch 'commander.invalidArgument'.
		*
		* @param {(Option | Argument)} target
		* @param {string} value
		* @param {*} previous
		* @param {string} invalidArgumentMessage
		* @private
		*/
		_callParseArg(target, value, previous, invalidArgumentMessage) {
			try {
				return target.parseArg(value, previous);
			} catch (err) {
				if (err.code === "commander.invalidArgument") {
					const message = `${invalidArgumentMessage} ${err.message}`;
					this.error(message, {
						exitCode: err.exitCode,
						code: err.code
					});
				}
				throw err;
			}
		}
		/**
		* Check for option flag conflicts.
		* Register option if no conflicts found, or throw on conflict.
		*
		* @param {Option} option
		* @private
		*/
		_registerOption(option) {
			const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
			if (matchingOption) {
				const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
				throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
			}
			this._initOptionGroup(option);
			this.options.push(option);
		}
		/**
		* Check for command name and alias conflicts with existing commands.
		* Register command if no conflicts found, or throw on conflict.
		*
		* @param {Command} command
		* @private
		*/
		_registerCommand(command) {
			const knownBy = (cmd) => {
				return [cmd.name()].concat(cmd.aliases());
			};
			const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));
			if (alreadyUsed) {
				const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
				const newCmd = knownBy(command).join("|");
				throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
			}
			this._initCommandGroup(command);
			this.commands.push(command);
		}
		/**
		* Add an option.
		*
		* @param {Option} option
		* @return {Command} `this` command for chaining
		*/
		addOption(option) {
			this._registerOption(option);
			const oname = option.name();
			const name = option.attributeName();
			if (option.negate) {
				const positiveLongFlag = option.long.replace(/^--no-/, "--");
				if (!this._findOption(positiveLongFlag)) {
					this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, "default");
				}
			} else if (option.defaultValue !== undefined) {
				this.setOptionValueWithSource(name, option.defaultValue, "default");
			}
			const handleOptionValue = (val, invalidValueMessage, valueSource) => {
				if (val == null && option.presetArg !== undefined) {
					val = option.presetArg;
				}
				const oldValue = this.getOptionValue(name);
				if (val !== null && option.parseArg) {
					val = this._callParseArg(option, val, oldValue, invalidValueMessage);
				} else if (val !== null && option.variadic) {
					val = option._collectValue(val, oldValue);
				}
				if (val == null) {
					if (option.negate) {
						val = false;
					} else if (option.isBoolean() || option.optional) {
						val = true;
					} else {
						val = "";
					}
				}
				this.setOptionValueWithSource(name, val, valueSource);
			};
			this.on("option:" + oname, (val) => {
				const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
				handleOptionValue(val, invalidValueMessage, "cli");
			});
			if (option.envVar) {
				this.on("optionEnv:" + oname, (val) => {
					const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
					handleOptionValue(val, invalidValueMessage, "env");
				});
			}
			return this;
		}
		/**
		* Internal implementation shared by .option() and .requiredOption()
		*
		* @return {Command} `this` command for chaining
		* @private
		*/
		_optionEx(config$1, flags, description, fn, defaultValue) {
			if (typeof flags === "object" && flags instanceof Option) {
				throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
			}
			const option = this.createOption(flags, description);
			option.makeOptionMandatory(!!config$1.mandatory);
			if (typeof fn === "function") {
				option.default(defaultValue).argParser(fn);
			} else if (fn instanceof RegExp) {
				const regex = fn;
				fn = (val, def) => {
					const m = regex.exec(val);
					return m ? m[0] : def;
				};
				option.default(defaultValue).argParser(fn);
			} else {
				option.default(fn);
			}
			return this.addOption(option);
		}
		/**
		* Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
		*
		* The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
		* option-argument is indicated by `<>` and an optional option-argument by `[]`.
		*
		* See the README for more details, and see also addOption() and requiredOption().
		*
		* @example
		* program
		*     .option('-p, --pepper', 'add pepper')
		*     .option('--pt, --pizza-type <TYPE>', 'type of pizza') // required option-argument
		*     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
		*     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
		*
		* @param {string} flags
		* @param {string} [description]
		* @param {(Function|*)} [parseArg] - custom option processing function or default value
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		option(flags, description, parseArg, defaultValue) {
			return this._optionEx({}, flags, description, parseArg, defaultValue);
		}
		/**
		* Add a required option which must have a value after parsing. This usually means
		* the option must be specified on the command line. (Otherwise the same as .option().)
		*
		* The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
		*
		* @param {string} flags
		* @param {string} [description]
		* @param {(Function|*)} [parseArg] - custom option processing function or default value
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		requiredOption(flags, description, parseArg, defaultValue) {
			return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
		}
		/**
		* Alter parsing of short flags with optional values.
		*
		* @example
		* // for `.option('-f,--flag [value]'):
		* program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
		* program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
		*
		* @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
		* @return {Command} `this` command for chaining
		*/
		combineFlagAndOptionalValue(combine = true) {
			this._combineFlagAndOptionalValue = !!combine;
			return this;
		}
		/**
		* Allow unknown options on the command line.
		*
		* @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
		* @return {Command} `this` command for chaining
		*/
		allowUnknownOption(allowUnknown = true) {
			this._allowUnknownOption = !!allowUnknown;
			return this;
		}
		/**
		* Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
		*
		* @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
		* @return {Command} `this` command for chaining
		*/
		allowExcessArguments(allowExcess = true) {
			this._allowExcessArguments = !!allowExcess;
			return this;
		}
		/**
		* Enable positional options. Positional means global options are specified before subcommands which lets
		* subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
		* The default behaviour is non-positional and global options may appear anywhere on the command line.
		*
		* @param {boolean} [positional]
		* @return {Command} `this` command for chaining
		*/
		enablePositionalOptions(positional = true) {
			this._enablePositionalOptions = !!positional;
			return this;
		}
		/**
		* Pass through options that come after command-arguments rather than treat them as command-options,
		* so actual command-options come before command-arguments. Turning this on for a subcommand requires
		* positional options to have been enabled on the program (parent commands).
		* The default behaviour is non-positional and options may appear before or after command-arguments.
		*
		* @param {boolean} [passThrough] for unknown options.
		* @return {Command} `this` command for chaining
		*/
		passThroughOptions(passThrough = true) {
			this._passThroughOptions = !!passThrough;
			this._checkForBrokenPassThrough();
			return this;
		}
		/**
		* @private
		*/
		_checkForBrokenPassThrough() {
			if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
				throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
			}
		}
		/**
		* Whether to store option values as properties on command object,
		* or store separately (specify false). In both cases the option values can be accessed using .opts().
		*
		* @param {boolean} [storeAsProperties=true]
		* @return {Command} `this` command for chaining
		*/
		storeOptionsAsProperties(storeAsProperties = true) {
			if (this.options.length) {
				throw new Error("call .storeOptionsAsProperties() before adding options");
			}
			if (Object.keys(this._optionValues).length) {
				throw new Error("call .storeOptionsAsProperties() before setting option values");
			}
			this._storeOptionsAsProperties = !!storeAsProperties;
			return this;
		}
		/**
		* Retrieve option value.
		*
		* @param {string} key
		* @return {object} value
		*/
		getOptionValue(key) {
			if (this._storeOptionsAsProperties) {
				return this[key];
			}
			return this._optionValues[key];
		}
		/**
		* Store option value.
		*
		* @param {string} key
		* @param {object} value
		* @return {Command} `this` command for chaining
		*/
		setOptionValue(key, value) {
			return this.setOptionValueWithSource(key, value, undefined);
		}
		/**
		* Store option value and where the value came from.
		*
		* @param {string} key
		* @param {object} value
		* @param {string} source - expected values are default/config/env/cli/implied
		* @return {Command} `this` command for chaining
		*/
		setOptionValueWithSource(key, value, source) {
			if (this._storeOptionsAsProperties) {
				this[key] = value;
			} else {
				this._optionValues[key] = value;
			}
			this._optionValueSources[key] = source;
			return this;
		}
		/**
		* Get source of option value.
		* Expected values are default | config | env | cli | implied
		*
		* @param {string} key
		* @return {string}
		*/
		getOptionValueSource(key) {
			return this._optionValueSources[key];
		}
		/**
		* Get source of option value. See also .optsWithGlobals().
		* Expected values are default | config | env | cli | implied
		*
		* @param {string} key
		* @return {string}
		*/
		getOptionValueSourceWithGlobals(key) {
			let source;
			this._getCommandAndAncestors().forEach((cmd) => {
				if (cmd.getOptionValueSource(key) !== undefined) {
					source = cmd.getOptionValueSource(key);
				}
			});
			return source;
		}
		/**
		* Get user arguments from implied or explicit arguments.
		* Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
		*
		* @private
		*/
		_prepareUserArgs(argv, parseOptions) {
			if (argv !== undefined && !Array.isArray(argv)) {
				throw new Error("first parameter to parse must be array or undefined");
			}
			parseOptions = parseOptions || {};
			if (argv === undefined && parseOptions.from === undefined) {
				if (process$3.versions?.electron) {
					parseOptions.from = "electron";
				}
				const execArgv = process$3.execArgv ?? [];
				if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
					parseOptions.from = "eval";
				}
			}
			if (argv === undefined) {
				argv = process$3.argv;
			}
			this.rawArgs = argv.slice();
			let userArgs;
			switch (parseOptions.from) {
				case undefined:
				case "node":
					this._scriptPath = argv[1];
					userArgs = argv.slice(2);
					break;
				case "electron":
					if (process$3.defaultApp) {
						this._scriptPath = argv[1];
						userArgs = argv.slice(2);
					} else {
						userArgs = argv.slice(1);
					}
					break;
				case "user":
					userArgs = argv.slice(0);
					break;
				case "eval":
					userArgs = argv.slice(1);
					break;
				default: throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
			}
			if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
			this._name = this._name || "program";
			return userArgs;
		}
		/**
		* Parse `argv`, setting options and invoking commands when defined.
		*
		* Use parseAsync instead of parse if any of your action handlers are async.
		*
		* Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
		*
		* Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
		* - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
		* - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
		* - `'user'`: just user arguments
		*
		* @example
		* program.parse(); // parse process.argv and auto-detect electron and special node flags
		* program.parse(process.argv); // assume argv[0] is app and argv[1] is script
		* program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
		*
		* @param {string[]} [argv] - optional, defaults to process.argv
		* @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
		* @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
		* @return {Command} `this` command for chaining
		*/
		parse(argv, parseOptions) {
			this._prepareForParse();
			const userArgs = this._prepareUserArgs(argv, parseOptions);
			this._parseCommand([], userArgs);
			return this;
		}
		/**
		* Parse `argv`, setting options and invoking commands when defined.
		*
		* Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
		*
		* Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
		* - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
		* - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
		* - `'user'`: just user arguments
		*
		* @example
		* await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
		* await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
		* await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
		*
		* @param {string[]} [argv]
		* @param {object} [parseOptions]
		* @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
		* @return {Promise}
		*/
		async parseAsync(argv, parseOptions) {
			this._prepareForParse();
			const userArgs = this._prepareUserArgs(argv, parseOptions);
			await this._parseCommand([], userArgs);
			return this;
		}
		_prepareForParse() {
			if (this._savedState === null) {
				this.saveStateBeforeParse();
			} else {
				this.restoreStateBeforeParse();
			}
		}
		/**
		* Called the first time parse is called to save state and allow a restore before subsequent calls to parse.
		* Not usually called directly, but available for subclasses to save their custom state.
		*
		* This is called in a lazy way. Only commands used in parsing chain will have state saved.
		*/
		saveStateBeforeParse() {
			this._savedState = {
				_name: this._name,
				_optionValues: { ...this._optionValues },
				_optionValueSources: { ...this._optionValueSources }
			};
		}
		/**
		* Restore state before parse for calls after the first.
		* Not usually called directly, but available for subclasses to save their custom state.
		*
		* This is called in a lazy way. Only commands used in parsing chain will have state restored.
		*/
		restoreStateBeforeParse() {
			if (this._storeOptionsAsProperties) throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);
			this._name = this._savedState._name;
			this._scriptPath = null;
			this.rawArgs = [];
			this._optionValues = { ...this._savedState._optionValues };
			this._optionValueSources = { ...this._savedState._optionValueSources };
			this.args = [];
			this.processedArgs = [];
		}
		/**
		* Throw if expected executable is missing. Add lots of help for author.
		*
		* @param {string} executableFile
		* @param {string} executableDir
		* @param {string} subcommandName
		*/
		_checkForMissingExecutable(executableFile, executableDir, subcommandName) {
			if (fs$11.existsSync(executableFile)) return;
			const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
			const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
			throw new Error(executableMissing);
		}
		/**
		* Execute a sub-command executable.
		*
		* @private
		*/
		_executeSubCommand(subcommand, args) {
			args = args.slice();
			let launchWithNode = false;
			const sourceExt = [
				".js",
				".ts",
				".tsx",
				".mjs",
				".cjs"
			];
			function findFile(baseDir, baseName) {
				const localBin = path$11.resolve(baseDir, baseName);
				if (fs$11.existsSync(localBin)) return localBin;
				if (sourceExt.includes(path$11.extname(baseName))) return undefined;
				const foundExt = sourceExt.find((ext) => fs$11.existsSync(`${localBin}${ext}`));
				if (foundExt) return `${localBin}${foundExt}`;
				return undefined;
			}
			this._checkForMissingMandatoryOptions();
			this._checkForConflictingOptions();
			let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
			let executableDir = this._executableDir || "";
			if (this._scriptPath) {
				let resolvedScriptPath;
				try {
					resolvedScriptPath = fs$11.realpathSync(this._scriptPath);
				} catch {
					resolvedScriptPath = this._scriptPath;
				}
				executableDir = path$11.resolve(path$11.dirname(resolvedScriptPath), executableDir);
			}
			if (executableDir) {
				let localFile = findFile(executableDir, executableFile);
				if (!localFile && !subcommand._executableFile && this._scriptPath) {
					const legacyName = path$11.basename(this._scriptPath, path$11.extname(this._scriptPath));
					if (legacyName !== this._name) {
						localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
					}
				}
				executableFile = localFile || executableFile;
			}
			launchWithNode = sourceExt.includes(path$11.extname(executableFile));
			let proc;
			if (process$3.platform !== "win32") {
				if (launchWithNode) {
					args.unshift(executableFile);
					args = incrementNodeInspectorPort(process$3.execArgv).concat(args);
					proc = childProcess.spawn(process$3.argv[0], args, { stdio: "inherit" });
				} else {
					proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
				}
			} else {
				this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
				args.unshift(executableFile);
				args = incrementNodeInspectorPort(process$3.execArgv).concat(args);
				proc = childProcess.spawn(process$3.execPath, args, { stdio: "inherit" });
			}
			if (!proc.killed) {
				const signals = [
					"SIGUSR1",
					"SIGUSR2",
					"SIGTERM",
					"SIGINT",
					"SIGHUP"
				];
				signals.forEach((signal) => {
					process$3.on(signal, () => {
						if (proc.killed === false && proc.exitCode === null) {
							proc.kill(signal);
						}
					});
				});
			}
			const exitCallback = this._exitCallback;
			proc.on("close", (code) => {
				code = code ?? 1;
				if (!exitCallback) {
					process$3.exit(code);
				} else {
					exitCallback(new CommanderError(code, "commander.executeSubCommandAsync", "(close)"));
				}
			});
			proc.on("error", (err) => {
				if (err.code === "ENOENT") {
					this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
				} else if (err.code === "EACCES") {
					throw new Error(`'${executableFile}' not executable`);
				}
				if (!exitCallback) {
					process$3.exit(1);
				} else {
					const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
					wrappedError.nestedError = err;
					exitCallback(wrappedError);
				}
			});
			this.runningCommand = proc;
		}
		/**
		* @private
		*/
		_dispatchSubcommand(commandName, operands, unknown$2) {
			const subCommand = this._findCommand(commandName);
			if (!subCommand) this.help({ error: true });
			subCommand._prepareForParse();
			let promiseChain;
			promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
			promiseChain = this._chainOrCall(promiseChain, () => {
				if (subCommand._executableHandler) {
					this._executeSubCommand(subCommand, operands.concat(unknown$2));
				} else {
					return subCommand._parseCommand(operands, unknown$2);
				}
			});
			return promiseChain;
		}
		/**
		* Invoke help directly if possible, or dispatch if necessary.
		* e.g. help foo
		*
		* @private
		*/
		_dispatchHelpCommand(subcommandName) {
			if (!subcommandName) {
				this.help();
			}
			const subCommand = this._findCommand(subcommandName);
			if (subCommand && !subCommand._executableHandler) {
				subCommand.help();
			}
			return this._dispatchSubcommand(subcommandName, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]);
		}
		/**
		* Check this.args against expected this.registeredArguments.
		*
		* @private
		*/
		_checkNumberOfArguments() {
			this.registeredArguments.forEach((arg, i) => {
				if (arg.required && this.args[i] == null) {
					this.missingArgument(arg.name());
				}
			});
			if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
				return;
			}
			if (this.args.length > this.registeredArguments.length) {
				this._excessArguments(this.args);
			}
		}
		/**
		* Process this.args using this.registeredArguments and save as this.processedArgs!
		*
		* @private
		*/
		_processArguments() {
			const myParseArg = (argument, value, previous) => {
				let parsedValue = value;
				if (value !== null && argument.parseArg) {
					const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
					parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
				}
				return parsedValue;
			};
			this._checkNumberOfArguments();
			const processedArgs = [];
			this.registeredArguments.forEach((declaredArg, index) => {
				let value = declaredArg.defaultValue;
				if (declaredArg.variadic) {
					if (index < this.args.length) {
						value = this.args.slice(index);
						if (declaredArg.parseArg) {
							value = value.reduce((processed, v) => {
								return myParseArg(declaredArg, v, processed);
							}, declaredArg.defaultValue);
						}
					} else if (value === undefined) {
						value = [];
					}
				} else if (index < this.args.length) {
					value = this.args[index];
					if (declaredArg.parseArg) {
						value = myParseArg(declaredArg, value, declaredArg.defaultValue);
					}
				}
				processedArgs[index] = value;
			});
			this.processedArgs = processedArgs;
		}
		/**
		* Once we have a promise we chain, but call synchronously until then.
		*
		* @param {(Promise|undefined)} promise
		* @param {Function} fn
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCall(promise$2, fn) {
			if (promise$2?.then && typeof promise$2.then === "function") {
				return promise$2.then(() => fn());
			}
			return fn();
		}
		/**
		*
		* @param {(Promise|undefined)} promise
		* @param {string} event
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCallHooks(promise$2, event) {
			let result = promise$2;
			const hooks = [];
			this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
				hookedCommand._lifeCycleHooks[event].forEach((callback) => {
					hooks.push({
						hookedCommand,
						callback
					});
				});
			});
			if (event === "postAction") {
				hooks.reverse();
			}
			hooks.forEach((hookDetail) => {
				result = this._chainOrCall(result, () => {
					return hookDetail.callback(hookDetail.hookedCommand, this);
				});
			});
			return result;
		}
		/**
		*
		* @param {(Promise|undefined)} promise
		* @param {Command} subCommand
		* @param {string} event
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCallSubCommandHook(promise$2, subCommand, event) {
			let result = promise$2;
			if (this._lifeCycleHooks[event] !== undefined) {
				this._lifeCycleHooks[event].forEach((hook) => {
					result = this._chainOrCall(result, () => {
						return hook(this, subCommand);
					});
				});
			}
			return result;
		}
		/**
		* Process arguments in context of this command.
		* Returns action result, in case it is a promise.
		*
		* @private
		*/
		_parseCommand(operands, unknown$2) {
			const parsed = this.parseOptions(unknown$2);
			this._parseOptionsEnv();
			this._parseOptionsImplied();
			operands = operands.concat(parsed.operands);
			unknown$2 = parsed.unknown;
			this.args = operands.concat(unknown$2);
			if (operands && this._findCommand(operands[0])) {
				return this._dispatchSubcommand(operands[0], operands.slice(1), unknown$2);
			}
			if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
				return this._dispatchHelpCommand(operands[1]);
			}
			if (this._defaultCommandName) {
				this._outputHelpIfRequested(unknown$2);
				return this._dispatchSubcommand(this._defaultCommandName, operands, unknown$2);
			}
			if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
				this.help({ error: true });
			}
			this._outputHelpIfRequested(parsed.unknown);
			this._checkForMissingMandatoryOptions();
			this._checkForConflictingOptions();
			const checkForUnknownOptions = () => {
				if (parsed.unknown.length > 0) {
					this.unknownOption(parsed.unknown[0]);
				}
			};
			const commandEvent = `command:${this.name()}`;
			if (this._actionHandler) {
				checkForUnknownOptions();
				this._processArguments();
				let promiseChain;
				promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
				promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
				if (this.parent) {
					promiseChain = this._chainOrCall(promiseChain, () => {
						this.parent.emit(commandEvent, operands, unknown$2);
					});
				}
				promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
				return promiseChain;
			}
			if (this.parent?.listenerCount(commandEvent)) {
				checkForUnknownOptions();
				this._processArguments();
				this.parent.emit(commandEvent, operands, unknown$2);
			} else if (operands.length) {
				if (this._findCommand("*")) {
					return this._dispatchSubcommand("*", operands, unknown$2);
				}
				if (this.listenerCount("command:*")) {
					this.emit("command:*", operands, unknown$2);
				} else if (this.commands.length) {
					this.unknownCommand();
				} else {
					checkForUnknownOptions();
					this._processArguments();
				}
			} else if (this.commands.length) {
				checkForUnknownOptions();
				this.help({ error: true });
			} else {
				checkForUnknownOptions();
				this._processArguments();
			}
		}
		/**
		* Find matching command.
		*
		* @private
		* @return {Command | undefined}
		*/
		_findCommand(name) {
			if (!name) return undefined;
			return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
		}
		/**
		* Return an option matching `arg` if any.
		*
		* @param {string} arg
		* @return {Option}
		* @package
		*/
		_findOption(arg) {
			return this.options.find((option) => option.is(arg));
		}
		/**
		* Display an error message if a mandatory option does not have a value.
		* Called after checking for help flags in leaf subcommand.
		*
		* @private
		*/
		_checkForMissingMandatoryOptions() {
			this._getCommandAndAncestors().forEach((cmd) => {
				cmd.options.forEach((anOption) => {
					if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
						cmd.missingMandatoryOptionValue(anOption);
					}
				});
			});
		}
		/**
		* Display an error message if conflicting options are used together in this.
		*
		* @private
		*/
		_checkForConflictingLocalOptions() {
			const definedNonDefaultOptions = this.options.filter((option) => {
				const optionKey = option.attributeName();
				if (this.getOptionValue(optionKey) === undefined) {
					return false;
				}
				return this.getOptionValueSource(optionKey) !== "default";
			});
			const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
			optionsWithConflicting.forEach((option) => {
				const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
				if (conflictingAndDefined) {
					this._conflictingOption(option, conflictingAndDefined);
				}
			});
		}
		/**
		* Display an error message if conflicting options are used together.
		* Called after checking for help flags in leaf subcommand.
		*
		* @private
		*/
		_checkForConflictingOptions() {
			this._getCommandAndAncestors().forEach((cmd) => {
				cmd._checkForConflictingLocalOptions();
			});
		}
		/**
		* Parse options from `argv` removing known options,
		* and return argv split into operands and unknown arguments.
		*
		* Side effects: modifies command by storing options. Does not reset state if called again.
		*
		* Examples:
		*
		*     argv => operands, unknown
		*     --known kkk op => [op], []
		*     op --known kkk => [op], []
		*     sub --unknown uuu op => [sub], [--unknown uuu op]
		*     sub -- --unknown uuu op => [sub --unknown uuu op], []
		*
		* @param {string[]} args
		* @return {{operands: string[], unknown: string[]}}
		*/
		parseOptions(args) {
			const operands = [];
			const unknown$2 = [];
			let dest = operands;
			function maybeOption(arg) {
				return arg.length > 1 && arg[0] === "-";
			}
			const negativeNumberArg = (arg) => {
				if (!/^-(\d+|\d*\.\d+)(e[+-]?\d+)?$/.test(arg)) return false;
				return !this._getCommandAndAncestors().some((cmd) => cmd.options.map((opt) => opt.short).some((short) => /^-\d$/.test(short)));
			};
			let activeVariadicOption = null;
			let activeGroup = null;
			let i = 0;
			while (i < args.length || activeGroup) {
				const arg = activeGroup ?? args[i++];
				activeGroup = null;
				if (arg === "--") {
					if (dest === unknown$2) dest.push(arg);
					dest.push(...args.slice(i));
					break;
				}
				if (activeVariadicOption && (!maybeOption(arg) || negativeNumberArg(arg))) {
					this.emit(`option:${activeVariadicOption.name()}`, arg);
					continue;
				}
				activeVariadicOption = null;
				if (maybeOption(arg)) {
					const option = this._findOption(arg);
					if (option) {
						if (option.required) {
							const value = args[i++];
							if (value === undefined) this.optionMissingArgument(option);
							this.emit(`option:${option.name()}`, value);
						} else if (option.optional) {
							let value = null;
							if (i < args.length && (!maybeOption(args[i]) || negativeNumberArg(args[i]))) {
								value = args[i++];
							}
							this.emit(`option:${option.name()}`, value);
						} else {
							this.emit(`option:${option.name()}`);
						}
						activeVariadicOption = option.variadic ? option : null;
						continue;
					}
				}
				if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
					const option = this._findOption(`-${arg[1]}`);
					if (option) {
						if (option.required || option.optional && this._combineFlagAndOptionalValue) {
							this.emit(`option:${option.name()}`, arg.slice(2));
						} else {
							this.emit(`option:${option.name()}`);
							activeGroup = `-${arg.slice(2)}`;
						}
						continue;
					}
				}
				if (/^--[^=]+=/.test(arg)) {
					const index = arg.indexOf("=");
					const option = this._findOption(arg.slice(0, index));
					if (option && (option.required || option.optional)) {
						this.emit(`option:${option.name()}`, arg.slice(index + 1));
						continue;
					}
				}
				if (dest === operands && maybeOption(arg) && !(this.commands.length === 0 && negativeNumberArg(arg))) {
					dest = unknown$2;
				}
				if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown$2.length === 0) {
					if (this._findCommand(arg)) {
						operands.push(arg);
						unknown$2.push(...args.slice(i));
						break;
					} else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
						operands.push(arg, ...args.slice(i));
						break;
					} else if (this._defaultCommandName) {
						unknown$2.push(arg, ...args.slice(i));
						break;
					}
				}
				if (this._passThroughOptions) {
					dest.push(arg, ...args.slice(i));
					break;
				}
				dest.push(arg);
			}
			return {
				operands,
				unknown: unknown$2
			};
		}
		/**
		* Return an object containing local option values as key-value pairs.
		*
		* @return {object}
		*/
		opts() {
			if (this._storeOptionsAsProperties) {
				const result = {};
				const len = this.options.length;
				for (let i = 0; i < len; i++) {
					const key = this.options[i].attributeName();
					result[key] = key === this._versionOptionName ? this._version : this[key];
				}
				return result;
			}
			return this._optionValues;
		}
		/**
		* Return an object containing merged local and global option values as key-value pairs.
		*
		* @return {object}
		*/
		optsWithGlobals() {
			return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
		}
		/**
		* Display error message and exit (or call exitOverride).
		*
		* @param {string} message
		* @param {object} [errorOptions]
		* @param {string} [errorOptions.code] - an id string representing the error
		* @param {number} [errorOptions.exitCode] - used with process.exit
		*/
		error(message, errorOptions) {
			this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
			if (typeof this._showHelpAfterError === "string") {
				this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
			} else if (this._showHelpAfterError) {
				this._outputConfiguration.writeErr("\n");
				this.outputHelp({ error: true });
			}
			const config$1 = errorOptions || {};
			const exitCode = config$1.exitCode || 1;
			const code = config$1.code || "commander.error";
			this._exit(exitCode, code, message);
		}
		/**
		* Apply any option related environment variables, if option does
		* not have a value from cli or client code.
		*
		* @private
		*/
		_parseOptionsEnv() {
			this.options.forEach((option) => {
				if (option.envVar && option.envVar in process$3.env) {
					const optionKey = option.attributeName();
					if (this.getOptionValue(optionKey) === undefined || [
						"default",
						"config",
						"env"
					].includes(this.getOptionValueSource(optionKey))) {
						if (option.required || option.optional) {
							this.emit(`optionEnv:${option.name()}`, process$3.env[option.envVar]);
						} else {
							this.emit(`optionEnv:${option.name()}`);
						}
					}
				}
			});
		}
		/**
		* Apply any implied option values, if option is undefined or default value.
		*
		* @private
		*/
		_parseOptionsImplied() {
			const dualHelper = new DualOptions(this.options);
			const hasCustomOptionValue = (optionKey) => {
				return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
			};
			this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
				Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
					this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
				});
			});
		}
		/**
		* Argument `name` is missing.
		*
		* @param {string} name
		* @private
		*/
		missingArgument(name) {
			const message = `error: missing required argument '${name}'`;
			this.error(message, { code: "commander.missingArgument" });
		}
		/**
		* `Option` is missing an argument.
		*
		* @param {Option} option
		* @private
		*/
		optionMissingArgument(option) {
			const message = `error: option '${option.flags}' argument missing`;
			this.error(message, { code: "commander.optionMissingArgument" });
		}
		/**
		* `Option` does not have a value, and is a mandatory option.
		*
		* @param {Option} option
		* @private
		*/
		missingMandatoryOptionValue(option) {
			const message = `error: required option '${option.flags}' not specified`;
			this.error(message, { code: "commander.missingMandatoryOptionValue" });
		}
		/**
		* `Option` conflicts with another option.
		*
		* @param {Option} option
		* @param {Option} conflictingOption
		* @private
		*/
		_conflictingOption(option, conflictingOption) {
			const findBestOptionFromValue = (option$1) => {
				const optionKey = option$1.attributeName();
				const optionValue = this.getOptionValue(optionKey);
				const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
				const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
				if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
					return negativeOption;
				}
				return positiveOption || option$1;
			};
			const getErrorMessage = (option$1) => {
				const bestOption = findBestOptionFromValue(option$1);
				const optionKey = bestOption.attributeName();
				const source = this.getOptionValueSource(optionKey);
				if (source === "env") {
					return `environment variable '${bestOption.envVar}'`;
				}
				return `option '${bestOption.flags}'`;
			};
			const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
			this.error(message, { code: "commander.conflictingOption" });
		}
		/**
		* Unknown option `flag`.
		*
		* @param {string} flag
		* @private
		*/
		unknownOption(flag) {
			if (this._allowUnknownOption) return;
			let suggestion = "";
			if (flag.startsWith("--") && this._showSuggestionAfterError) {
				let candidateFlags = [];
				let command = this;
				do {
					const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
					candidateFlags = candidateFlags.concat(moreFlags);
					command = command.parent;
				} while (command && !command._enablePositionalOptions);
				suggestion = suggestSimilar(flag, candidateFlags);
			}
			const message = `error: unknown option '${flag}'${suggestion}`;
			this.error(message, { code: "commander.unknownOption" });
		}
		/**
		* Excess arguments, more than expected.
		*
		* @param {string[]} receivedArgs
		* @private
		*/
		_excessArguments(receivedArgs) {
			if (this._allowExcessArguments) return;
			const expected = this.registeredArguments.length;
			const s = expected === 1 ? "" : "s";
			const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
			const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
			this.error(message, { code: "commander.excessArguments" });
		}
		/**
		* Unknown command.
		*
		* @private
		*/
		unknownCommand() {
			const unknownName = this.args[0];
			let suggestion = "";
			if (this._showSuggestionAfterError) {
				const candidateNames = [];
				this.createHelp().visibleCommands(this).forEach((command) => {
					candidateNames.push(command.name());
					if (command.alias()) candidateNames.push(command.alias());
				});
				suggestion = suggestSimilar(unknownName, candidateNames);
			}
			const message = `error: unknown command '${unknownName}'${suggestion}`;
			this.error(message, { code: "commander.unknownCommand" });
		}
		/**
		* Get or set the program version.
		*
		* This method auto-registers the "-V, --version" option which will print the version number.
		*
		* You can optionally supply the flags and description to override the defaults.
		*
		* @param {string} [str]
		* @param {string} [flags]
		* @param {string} [description]
		* @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
		*/
		version(str, flags, description) {
			if (str === undefined) return this._version;
			this._version = str;
			flags = flags || "-V, --version";
			description = description || "output the version number";
			const versionOption = this.createOption(flags, description);
			this._versionOptionName = versionOption.attributeName();
			this._registerOption(versionOption);
			this.on("option:" + versionOption.name(), () => {
				this._outputConfiguration.writeOut(`${str}\n`);
				this._exit(0, "commander.version", str);
			});
			return this;
		}
		/**
		* Set the description.
		*
		* @param {string} [str]
		* @param {object} [argsDescription]
		* @return {(string|Command)}
		*/
		description(str, argsDescription) {
			if (str === undefined && argsDescription === undefined) return this._description;
			this._description = str;
			if (argsDescription) {
				this._argsDescription = argsDescription;
			}
			return this;
		}
		/**
		* Set the summary. Used when listed as subcommand of parent.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		summary(str) {
			if (str === undefined) return this._summary;
			this._summary = str;
			return this;
		}
		/**
		* Set an alias for the command.
		*
		* You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
		*
		* @param {string} [alias]
		* @return {(string|Command)}
		*/
		alias(alias) {
			if (alias === undefined) return this._aliases[0];
			/** @type {Command} */
			let command = this;
			if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
				command = this.commands[this.commands.length - 1];
			}
			if (alias === command._name) throw new Error("Command alias can't be the same as its name");
			const matchingCommand = this.parent?._findCommand(alias);
			if (matchingCommand) {
				const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
				throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
			}
			command._aliases.push(alias);
			return this;
		}
		/**
		* Set aliases for the command.
		*
		* Only the first alias is shown in the auto-generated help.
		*
		* @param {string[]} [aliases]
		* @return {(string[]|Command)}
		*/
		aliases(aliases) {
			if (aliases === undefined) return this._aliases;
			aliases.forEach((alias) => this.alias(alias));
			return this;
		}
		/**
		* Set / get the command usage `str`.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		usage(str) {
			if (str === undefined) {
				if (this._usage) return this._usage;
				const args = this.registeredArguments.map((arg) => {
					return humanReadableArgName(arg);
				});
				return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
			}
			this._usage = str;
			return this;
		}
		/**
		* Get or set the name of the command.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		name(str) {
			if (str === undefined) return this._name;
			this._name = str;
			return this;
		}
		/**
		* Set/get the help group heading for this subcommand in parent command's help.
		*
		* @param {string} [heading]
		* @return {Command | string}
		*/
		helpGroup(heading) {
			if (heading === undefined) return this._helpGroupHeading ?? "";
			this._helpGroupHeading = heading;
			return this;
		}
		/**
		* Set/get the default help group heading for subcommands added to this command.
		* (This does not override a group set directly on the subcommand using .helpGroup().)
		*
		* @example
		* program.commandsGroup('Development Commands:);
		* program.command('watch')...
		* program.command('lint')...
		* ...
		*
		* @param {string} [heading]
		* @returns {Command | string}
		*/
		commandsGroup(heading) {
			if (heading === undefined) return this._defaultCommandGroup ?? "";
			this._defaultCommandGroup = heading;
			return this;
		}
		/**
		* Set/get the default help group heading for options added to this command.
		* (This does not override a group set directly on the option using .helpGroup().)
		*
		* @example
		* program
		*   .optionsGroup('Development Options:')
		*   .option('-d, --debug', 'output extra debugging')
		*   .option('-p, --profile', 'output profiling information')
		*
		* @param {string} [heading]
		* @returns {Command | string}
		*/
		optionsGroup(heading) {
			if (heading === undefined) return this._defaultOptionGroup ?? "";
			this._defaultOptionGroup = heading;
			return this;
		}
		/**
		* @param {Option} option
		* @private
		*/
		_initOptionGroup(option) {
			if (this._defaultOptionGroup && !option.helpGroupHeading) option.helpGroup(this._defaultOptionGroup);
		}
		/**
		* @param {Command} cmd
		* @private
		*/
		_initCommandGroup(cmd) {
			if (this._defaultCommandGroup && !cmd.helpGroup()) cmd.helpGroup(this._defaultCommandGroup);
		}
		/**
		* Set the name of the command from script filename, such as process.argv[1],
		* or require.main.filename, or __filename.
		*
		* (Used internally and public although not documented in README.)
		*
		* @example
		* program.nameFromFilename(require.main.filename);
		*
		* @param {string} filename
		* @return {Command}
		*/
		nameFromFilename(filename) {
			this._name = path$11.basename(filename, path$11.extname(filename));
			return this;
		}
		/**
		* Get or set the directory for searching for executable subcommands of this command.
		*
		* @example
		* program.executableDir(__dirname);
		* // or
		* program.executableDir('subcommands');
		*
		* @param {string} [path]
		* @return {(string|null|Command)}
		*/
		executableDir(path$12) {
			if (path$12 === undefined) return this._executableDir;
			this._executableDir = path$12;
			return this;
		}
		/**
		* Return program help documentation.
		*
		* @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
		* @return {string}
		*/
		helpInformation(contextOptions) {
			const helper = this.createHelp();
			const context = this._getOutputContext(contextOptions);
			helper.prepareContext({
				error: context.error,
				helpWidth: context.helpWidth,
				outputHasColors: context.hasColors
			});
			const text = helper.formatHelp(this, helper);
			if (context.hasColors) return text;
			return this._outputConfiguration.stripColor(text);
		}
		/**
		* @typedef HelpContext
		* @type {object}
		* @property {boolean} error
		* @property {number} helpWidth
		* @property {boolean} hasColors
		* @property {function} write - includes stripColor if needed
		*
		* @returns {HelpContext}
		* @private
		*/
		_getOutputContext(contextOptions) {
			contextOptions = contextOptions || {};
			const error$47 = !!contextOptions.error;
			let baseWrite;
			let hasColors;
			let helpWidth;
			if (error$47) {
				baseWrite = (str) => this._outputConfiguration.writeErr(str);
				hasColors = this._outputConfiguration.getErrHasColors();
				helpWidth = this._outputConfiguration.getErrHelpWidth();
			} else {
				baseWrite = (str) => this._outputConfiguration.writeOut(str);
				hasColors = this._outputConfiguration.getOutHasColors();
				helpWidth = this._outputConfiguration.getOutHelpWidth();
			}
			const write = (str) => {
				if (!hasColors) str = this._outputConfiguration.stripColor(str);
				return baseWrite(str);
			};
			return {
				error: error$47,
				write,
				hasColors,
				helpWidth
			};
		}
		/**
		* Output help information for this command.
		*
		* Outputs built-in help, and custom text added using `.addHelpText()`.
		*
		* @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
		*/
		outputHelp(contextOptions) {
			let deprecatedCallback;
			if (typeof contextOptions === "function") {
				deprecatedCallback = contextOptions;
				contextOptions = undefined;
			}
			const outputContext = this._getOutputContext(contextOptions);
			/** @type {HelpTextEventContext} */
			const eventContext = {
				error: outputContext.error,
				write: outputContext.write,
				command: this
			};
			this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", eventContext));
			this.emit("beforeHelp", eventContext);
			let helpInformation = this.helpInformation({ error: outputContext.error });
			if (deprecatedCallback) {
				helpInformation = deprecatedCallback(helpInformation);
				if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
					throw new Error("outputHelp callback must return a string or a Buffer");
				}
			}
			outputContext.write(helpInformation);
			if (this._getHelpOption()?.long) {
				this.emit(this._getHelpOption().long);
			}
			this.emit("afterHelp", eventContext);
			this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", eventContext));
		}
		/**
		* You can pass in flags and a description to customise the built-in help option.
		* Pass in false to disable the built-in help option.
		*
		* @example
		* program.helpOption('-?, --help' 'show help'); // customise
		* program.helpOption(false); // disable
		*
		* @param {(string | boolean)} flags
		* @param {string} [description]
		* @return {Command} `this` command for chaining
		*/
		helpOption(flags, description) {
			if (typeof flags === "boolean") {
				if (flags) {
					if (this._helpOption === null) this._helpOption = undefined;
					if (this._defaultOptionGroup) {
						this._initOptionGroup(this._getHelpOption());
					}
				} else {
					this._helpOption = null;
				}
				return this;
			}
			this._helpOption = this.createOption(flags ?? "-h, --help", description ?? "display help for command");
			if (flags || description) this._initOptionGroup(this._helpOption);
			return this;
		}
		/**
		* Lazy create help option.
		* Returns null if has been disabled with .helpOption(false).
		*
		* @returns {(Option | null)} the help option
		* @package
		*/
		_getHelpOption() {
			if (this._helpOption === undefined) {
				this.helpOption(undefined, undefined);
			}
			return this._helpOption;
		}
		/**
		* Supply your own option to use for the built-in help option.
		* This is an alternative to using helpOption() to customise the flags and description etc.
		*
		* @param {Option} option
		* @return {Command} `this` command for chaining
		*/
		addHelpOption(option) {
			this._helpOption = option;
			this._initOptionGroup(option);
			return this;
		}
		/**
		* Output help information and exit.
		*
		* Outputs built-in help, and custom text added using `.addHelpText()`.
		*
		* @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
		*/
		help(contextOptions) {
			this.outputHelp(contextOptions);
			let exitCode = Number(process$3.exitCode ?? 0);
			if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
				exitCode = 1;
			}
			this._exit(exitCode, "commander.help", "(outputHelp)");
		}
		/**
		* // Do a little typing to coordinate emit and listener for the help text events.
		* @typedef HelpTextEventContext
		* @type {object}
		* @property {boolean} error
		* @property {Command} command
		* @property {function} write
		*/
		/**
		* Add additional text to be displayed with the built-in help.
		*
		* Position is 'before' or 'after' to affect just this command,
		* and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
		*
		* @param {string} position - before or after built-in help
		* @param {(string | Function)} text - string to add, or a function returning a string
		* @return {Command} `this` command for chaining
		*/
		addHelpText(position, text) {
			const allowedValues = [
				"beforeAll",
				"before",
				"after",
				"afterAll"
			];
			if (!allowedValues.includes(position)) {
				throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
			}
			const helpEvent = `${position}Help`;
			this.on(helpEvent, (context) => {
				let helpStr;
				if (typeof text === "function") {
					helpStr = text({
						error: context.error,
						command: context.command
					});
				} else {
					helpStr = text;
				}
				if (helpStr) {
					context.write(`${helpStr}\n`);
				}
			});
			return this;
		}
		/**
		* Output help information if help flags specified
		*
		* @param {Array} args - array of options to search for help flags
		* @private
		*/
		_outputHelpIfRequested(args) {
			const helpOption = this._getHelpOption();
			const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
			if (helpRequested) {
				this.outputHelp();
				this._exit(0, "commander.helpDisplayed", "(outputHelp)");
			}
		}
	};
	/**
	* Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
	*
	* @param {string[]} args - array of arguments from node.execArgv
	* @returns {string[]}
	* @private
	*/
	function incrementNodeInspectorPort(args) {
		return args.map((arg) => {
			if (!arg.startsWith("--inspect")) {
				return arg;
			}
			let debugOption;
			let debugHost = "127.0.0.1";
			let debugPort = "9229";
			let match;
			if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
				debugOption = match[1];
			} else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
				debugOption = match[1];
				if (/^\d+$/.test(match[3])) {
					debugPort = match[3];
				} else {
					debugHost = match[3];
				}
			} else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
				debugOption = match[1];
				debugHost = match[3];
				debugPort = match[4];
			}
			if (debugOption && debugPort !== "0") {
				return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
			}
			return arg;
		});
	}
	/**
	* @returns {boolean | undefined}
	* @package
	*/
	function useColor() {
		if (process$3.env.NO_COLOR || process$3.env.FORCE_COLOR === "0" || process$3.env.FORCE_COLOR === "false") return false;
		if (process$3.env.FORCE_COLOR || process$3.env.CLICOLOR_FORCE !== undefined) return true;
		return undefined;
	}
	exports.Command = Command;
	exports.useColor = useColor;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/commander/index.js
var require_commander = /* @__PURE__ */ __commonJSMin(((exports) => {
	const { Argument } = require_argument();
	const { Command } = require_command();
	const { CommanderError, InvalidArgumentError } = require_error();
	const { Help } = require_help();
	const { Option } = require_option();
	exports.program = new Command();
	exports.createCommand = (name) => new Command(name);
	exports.createOption = (flags, description) => new Option(flags, description);
	exports.createArgument = (name, description) => new Argument(name, description);
	/**
	* Expose classes
	*/
	exports.Command = Command;
	exports.Option = Option;
	exports.Argument = Argument;
	exports.Help = Help;
	exports.CommanderError = CommanderError;
	exports.InvalidArgumentError = InvalidArgumentError;
	exports.InvalidOptionArgumentError = InvalidArgumentError;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/lib/parser.js
var require_parser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const ParserEND = 1114112;
	var ParserError = class ParserError extends Error {
		/* istanbul ignore next */
		constructor(msg, filename, linenumber) {
			super("[ParserError] " + msg, filename, linenumber);
			this.name = "ParserError";
			this.code = "ParserError";
			if (Error.captureStackTrace) Error.captureStackTrace(this, ParserError);
		}
	};
	var State = class {
		constructor(parser) {
			this.parser = parser;
			this.buf = "";
			this.returned = null;
			this.result = null;
			this.resultTable = null;
			this.resultArr = null;
		}
	};
	var Parser = class {
		constructor() {
			this.pos = 0;
			this.col = 0;
			this.line = 0;
			this.obj = {};
			this.ctx = this.obj;
			this.stack = [];
			this._buf = "";
			this.char = null;
			this.ii = 0;
			this.state = new State(this.parseStart);
		}
		parse(str) {
			/* istanbul ignore next */
			if (str.length === 0 || str.length == null) return;
			this._buf = String(str);
			this.ii = -1;
			this.char = -1;
			let getNext;
			while (getNext === false || this.nextChar()) {
				getNext = this.runOne();
			}
			this._buf = null;
		}
		nextChar() {
			if (this.char === 10) {
				++this.line;
				this.col = -1;
			}
			++this.ii;
			this.char = this._buf.codePointAt(this.ii);
			++this.pos;
			++this.col;
			return this.haveBuffer();
		}
		haveBuffer() {
			return this.ii < this._buf.length;
		}
		runOne() {
			return this.state.parser.call(this, this.state.returned);
		}
		finish() {
			this.char = ParserEND;
			let last;
			do {
				last = this.state.parser;
				this.runOne();
			} while (this.state.parser !== last);
			this.ctx = null;
			this.state = null;
			this._buf = null;
			return this.obj;
		}
		next(fn) {
			/* istanbul ignore next */
			if (typeof fn !== "function") throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
			this.state.parser = fn;
		}
		goto(fn) {
			this.next(fn);
			return this.runOne();
		}
		call(fn, returnWith) {
			if (returnWith) this.next(returnWith);
			this.stack.push(this.state);
			this.state = new State(fn);
		}
		callNow(fn, returnWith) {
			this.call(fn, returnWith);
			return this.runOne();
		}
		return(value) {
			/* istanbul ignore next */
			if (this.stack.length === 0) throw this.error(new ParserError("Stack underflow"));
			if (value === undefined) value = this.state.buf;
			this.state = this.stack.pop();
			this.state.returned = value;
		}
		returnNow(value) {
			this.return(value);
			return this.runOne();
		}
		consume() {
			/* istanbul ignore next */
			if (this.char === ParserEND) throw this.error(new ParserError("Unexpected end-of-buffer"));
			this.state.buf += this._buf[this.ii];
		}
		error(err) {
			err.line = this.line;
			err.col = this.col;
			err.pos = this.pos;
			return err;
		}
		/* istanbul ignore next */
		parseStart() {
			throw new ParserError("Must declare a parseStart method");
		}
	};
	Parser.END = ParserEND;
	Parser.Error = ParserError;
	module.exports = Parser;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/lib/create-datetime.js
var require_create_datetime = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = (value) => {
		const date$7 = new Date(value);
		/* istanbul ignore if */
		if (isNaN(date$7)) {
			throw new TypeError("Invalid Datetime");
		} else {
			return date$7;
		}
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/lib/format-num.js
var require_format_num = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = (d, num) => {
		num = String(num);
		while (num.length < d) num = "0" + num;
		return num;
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/lib/create-datetime-float.js
var require_create_datetime_float = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const f = require_format_num();
	var FloatingDateTime = class extends Date {
		constructor(value) {
			super(value + "Z");
			this.isFloating = true;
		}
		toISOString() {
			const date$7 = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
			const time$3 = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
			return `${date$7}T${time$3}`;
		}
	};
	module.exports = (value) => {
		const date$7 = new FloatingDateTime(value);
		/* istanbul ignore if */
		if (isNaN(date$7)) {
			throw new TypeError("Invalid Datetime");
		} else {
			return date$7;
		}
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/lib/create-date.js
var require_create_date = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const f = require_format_num();
	const DateTime = global.Date;
	var Date = class extends DateTime {
		constructor(value) {
			super(value);
			this.isDate = true;
		}
		toISOString() {
			return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
		}
	};
	module.exports = (value) => {
		const date$7 = new Date(value);
		/* istanbul ignore if */
		if (isNaN(date$7)) {
			throw new TypeError("Invalid Datetime");
		} else {
			return date$7;
		}
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/lib/create-time.js
var require_create_time = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const f = require_format_num();
	var Time = class extends Date {
		constructor(value) {
			super(`0000-01-01T${value}Z`);
			this.isTime = true;
		}
		toISOString() {
			return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
		}
	};
	module.exports = (value) => {
		const date$7 = new Time(value);
		/* istanbul ignore if */
		if (isNaN(date$7)) {
			throw new TypeError("Invalid Datetime");
		} else {
			return date$7;
		}
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/lib/toml-parser.js
var require_toml_parser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = makeParserClass(require_parser());
	module.exports.makeParserClass = makeParserClass;
	var TomlError = class TomlError extends Error {
		constructor(msg) {
			super(msg);
			this.name = "TomlError";
			/* istanbul ignore next */
			if (Error.captureStackTrace) Error.captureStackTrace(this, TomlError);
			this.fromTOML = true;
			this.wrapped = null;
		}
	};
	TomlError.wrap = (err) => {
		const terr = new TomlError(err.message);
		terr.code = err.code;
		terr.wrapped = err;
		return terr;
	};
	module.exports.TomlError = TomlError;
	const createDateTime = require_create_datetime();
	const createDateTimeFloat = require_create_datetime_float();
	const createDate = require_create_date();
	const createTime = require_create_time();
	const CTRL_I = 9;
	const CTRL_J = 10;
	const CTRL_M = 13;
	const CTRL_CHAR_BOUNDARY = 31;
	const CHAR_SP = 32;
	const CHAR_QUOT = 34;
	const CHAR_NUM = 35;
	const CHAR_APOS = 39;
	const CHAR_PLUS = 43;
	const CHAR_COMMA = 44;
	const CHAR_HYPHEN = 45;
	const CHAR_PERIOD = 46;
	const CHAR_0 = 48;
	const CHAR_1 = 49;
	const CHAR_7 = 55;
	const CHAR_9 = 57;
	const CHAR_COLON = 58;
	const CHAR_EQUALS = 61;
	const CHAR_A = 65;
	const CHAR_E = 69;
	const CHAR_F = 70;
	const CHAR_T = 84;
	const CHAR_U = 85;
	const CHAR_Z = 90;
	const CHAR_LOWBAR = 95;
	const CHAR_a = 97;
	const CHAR_b = 98;
	const CHAR_e = 101;
	const CHAR_f = 102;
	const CHAR_i = 105;
	const CHAR_l = 108;
	const CHAR_n = 110;
	const CHAR_o = 111;
	const CHAR_r = 114;
	const CHAR_s = 115;
	const CHAR_t = 116;
	const CHAR_u = 117;
	const CHAR_x = 120;
	const CHAR_z = 122;
	const CHAR_LCUB = 123;
	const CHAR_RCUB = 125;
	const CHAR_LSQB = 91;
	const CHAR_BSOL = 92;
	const CHAR_RSQB = 93;
	const CHAR_DEL = 127;
	const SURROGATE_FIRST = 55296;
	const SURROGATE_LAST = 57343;
	const escapes = {
		[CHAR_b]: "\b",
		[CHAR_t]: "	",
		[CHAR_n]: "\n",
		[CHAR_f]: "\f",
		[CHAR_r]: "\r",
		[CHAR_QUOT]: "\"",
		[CHAR_BSOL]: "\\"
	};
	function isDigit(cp$1) {
		return cp$1 >= CHAR_0 && cp$1 <= CHAR_9;
	}
	function isHexit(cp$1) {
		return cp$1 >= CHAR_A && cp$1 <= CHAR_F || cp$1 >= CHAR_a && cp$1 <= CHAR_f || cp$1 >= CHAR_0 && cp$1 <= CHAR_9;
	}
	function isBit(cp$1) {
		return cp$1 === CHAR_1 || cp$1 === CHAR_0;
	}
	function isOctit(cp$1) {
		return cp$1 >= CHAR_0 && cp$1 <= CHAR_7;
	}
	function isAlphaNumQuoteHyphen(cp$1) {
		return cp$1 >= CHAR_A && cp$1 <= CHAR_Z || cp$1 >= CHAR_a && cp$1 <= CHAR_z || cp$1 >= CHAR_0 && cp$1 <= CHAR_9 || cp$1 === CHAR_APOS || cp$1 === CHAR_QUOT || cp$1 === CHAR_LOWBAR || cp$1 === CHAR_HYPHEN;
	}
	function isAlphaNumHyphen(cp$1) {
		return cp$1 >= CHAR_A && cp$1 <= CHAR_Z || cp$1 >= CHAR_a && cp$1 <= CHAR_z || cp$1 >= CHAR_0 && cp$1 <= CHAR_9 || cp$1 === CHAR_LOWBAR || cp$1 === CHAR_HYPHEN;
	}
	const _type = Symbol("type");
	const _declared = Symbol("declared");
	const hasOwnProperty = Object.prototype.hasOwnProperty;
	const defineProperty = Object.defineProperty;
	const descriptor = {
		configurable: true,
		enumerable: true,
		writable: true,
		value: undefined
	};
	function hasKey(obj, key) {
		if (hasOwnProperty.call(obj, key)) return true;
		if (key === "__proto__") defineProperty(obj, "__proto__", descriptor);
		return false;
	}
	const INLINE_TABLE = Symbol("inline-table");
	function InlineTable() {
		return Object.defineProperties({}, { [_type]: { value: INLINE_TABLE } });
	}
	function isInlineTable(obj) {
		if (obj === null || typeof obj !== "object") return false;
		return obj[_type] === INLINE_TABLE;
	}
	const TABLE = Symbol("table");
	function Table() {
		return Object.defineProperties({}, {
			[_type]: { value: TABLE },
			[_declared]: {
				value: false,
				writable: true
			}
		});
	}
	function isTable(obj) {
		if (obj === null || typeof obj !== "object") return false;
		return obj[_type] === TABLE;
	}
	const _contentType = Symbol("content-type");
	const INLINE_LIST = Symbol("inline-list");
	function InlineList(type) {
		return Object.defineProperties([], {
			[_type]: { value: INLINE_LIST },
			[_contentType]: { value: type }
		});
	}
	function isInlineList(obj) {
		if (obj === null || typeof obj !== "object") return false;
		return obj[_type] === INLINE_LIST;
	}
	const LIST = Symbol("list");
	function List() {
		return Object.defineProperties([], { [_type]: { value: LIST } });
	}
	function isList(obj) {
		if (obj === null || typeof obj !== "object") return false;
		return obj[_type] === LIST;
	}
	let _custom;
	try {
		const utilInspect = eval("require('util').inspect");
		_custom = utilInspect.custom;
	} catch (_) {}
	/* istanbul ignore next */
	const _inspect = _custom || "inspect";
	var BoxedBigInt = class {
		constructor(value) {
			try {
				this.value = global.BigInt.asIntN(64, value);
			} catch (_) {
				/* istanbul ignore next */
				this.value = null;
			}
			Object.defineProperty(this, _type, { value: INTEGER });
		}
		isNaN() {
			return this.value === null;
		}
		/* istanbul ignore next */
		toString() {
			return String(this.value);
		}
		/* istanbul ignore next */
		[_inspect]() {
			return `[BigInt: ${this.toString()}]}`;
		}
		valueOf() {
			return this.value;
		}
	};
	const INTEGER = Symbol("integer");
	function Integer(value) {
		let num = Number(value);
		if (Object.is(num, -0)) num = 0;
		/* istanbul ignore else */
		if (global.BigInt && !Number.isSafeInteger(num)) {
			return new BoxedBigInt(value);
		} else {
			/* istanbul ignore next */
			return Object.defineProperties(new Number(num), {
				isNaN: { value: function() {
					return isNaN(this);
				} },
				[_type]: { value: INTEGER },
				[_inspect]: { value: () => `[Integer: ${value}]` }
			});
		}
	}
	function isInteger(obj) {
		if (obj === null || typeof obj !== "object") return false;
		return obj[_type] === INTEGER;
	}
	const FLOAT = Symbol("float");
	function Float(value) {
		/* istanbul ignore next */
		return Object.defineProperties(new Number(value), {
			[_type]: { value: FLOAT },
			[_inspect]: { value: () => `[Float: ${value}]` }
		});
	}
	function isFloat(obj) {
		if (obj === null || typeof obj !== "object") return false;
		return obj[_type] === FLOAT;
	}
	function tomlType(value) {
		const type = typeof value;
		if (type === "object") {
			/* istanbul ignore if */
			if (value === null) return "null";
			if (value instanceof Date) return "datetime";
			/* istanbul ignore else */
			if (_type in value) {
				switch (value[_type]) {
					case INLINE_TABLE: return "inline-table";
					case INLINE_LIST: return "inline-list";
					case TABLE: return "table";
					case LIST: return "list";
					case FLOAT: return "float";
					case INTEGER: return "integer";
				}
			}
		}
		return type;
	}
	function makeParserClass(Parser) {
		class TOMLParser extends Parser {
			constructor() {
				super();
				this.ctx = this.obj = Table();
			}
			atEndOfWord() {
				return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
			}
			atEndOfLine() {
				return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
			}
			parseStart() {
				if (this.char === Parser.END) {
					return null;
				} else if (this.char === CHAR_LSQB) {
					return this.call(this.parseTableOrList);
				} else if (this.char === CHAR_NUM) {
					return this.call(this.parseComment);
				} else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
					return null;
				} else if (isAlphaNumQuoteHyphen(this.char)) {
					return this.callNow(this.parseAssignStatement);
				} else {
					throw this.error(new TomlError(`Unknown character "${this.char}"`));
				}
			}
			parseWhitespaceToEOL() {
				if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
					return null;
				} else if (this.char === CHAR_NUM) {
					return this.goto(this.parseComment);
				} else if (this.char === Parser.END || this.char === CTRL_J) {
					return this.return();
				} else {
					throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
				}
			}
			parseAssignStatement() {
				return this.callNow(this.parseAssign, this.recordAssignStatement);
			}
			recordAssignStatement(kv) {
				let target = this.ctx;
				let finalKey = kv.key.pop();
				for (let kw of kv.key) {
					if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
						throw this.error(new TomlError("Can't redefine existing key"));
					}
					target = target[kw] = target[kw] || Table();
				}
				if (hasKey(target, finalKey)) {
					throw this.error(new TomlError("Can't redefine existing key"));
				}
				if (isInteger(kv.value) || isFloat(kv.value)) {
					target[finalKey] = kv.value.valueOf();
				} else {
					target[finalKey] = kv.value;
				}
				return this.goto(this.parseWhitespaceToEOL);
			}
			parseAssign() {
				return this.callNow(this.parseKeyword, this.recordAssignKeyword);
			}
			recordAssignKeyword(key) {
				if (this.state.resultTable) {
					this.state.resultTable.push(key);
				} else {
					this.state.resultTable = [key];
				}
				return this.goto(this.parseAssignKeywordPreDot);
			}
			parseAssignKeywordPreDot() {
				if (this.char === CHAR_PERIOD) {
					return this.next(this.parseAssignKeywordPostDot);
				} else if (this.char !== CHAR_SP && this.char !== CTRL_I) {
					return this.goto(this.parseAssignEqual);
				}
			}
			parseAssignKeywordPostDot() {
				if (this.char !== CHAR_SP && this.char !== CTRL_I) {
					return this.callNow(this.parseKeyword, this.recordAssignKeyword);
				}
			}
			parseAssignEqual() {
				if (this.char === CHAR_EQUALS) {
					return this.next(this.parseAssignPreValue);
				} else {
					throw this.error(new TomlError("Invalid character, expected \"=\""));
				}
			}
			parseAssignPreValue() {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else {
					return this.callNow(this.parseValue, this.recordAssignValue);
				}
			}
			recordAssignValue(value) {
				return this.returnNow({
					key: this.state.resultTable,
					value
				});
			}
			parseComment() {
				do {
					if (this.char === Parser.END || this.char === CTRL_J) {
						return this.return();
					}
				} while (this.nextChar());
			}
			parseTableOrList() {
				if (this.char === CHAR_LSQB) {
					this.next(this.parseList);
				} else {
					return this.goto(this.parseTable);
				}
			}
			parseTable() {
				this.ctx = this.obj;
				return this.goto(this.parseTableNext);
			}
			parseTableNext() {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else {
					return this.callNow(this.parseKeyword, this.parseTableMore);
				}
			}
			parseTableMore(keyword) {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else if (this.char === CHAR_RSQB) {
					if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {
						throw this.error(new TomlError("Can't redefine existing key"));
					} else {
						this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
						this.ctx[_declared] = true;
					}
					return this.next(this.parseWhitespaceToEOL);
				} else if (this.char === CHAR_PERIOD) {
					if (!hasKey(this.ctx, keyword)) {
						this.ctx = this.ctx[keyword] = Table();
					} else if (isTable(this.ctx[keyword])) {
						this.ctx = this.ctx[keyword];
					} else if (isList(this.ctx[keyword])) {
						this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
					} else {
						throw this.error(new TomlError("Can't redefine existing key"));
					}
					return this.next(this.parseTableNext);
				} else {
					throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
				}
			}
			parseList() {
				this.ctx = this.obj;
				return this.goto(this.parseListNext);
			}
			parseListNext() {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else {
					return this.callNow(this.parseKeyword, this.parseListMore);
				}
			}
			parseListMore(keyword) {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else if (this.char === CHAR_RSQB) {
					if (!hasKey(this.ctx, keyword)) {
						this.ctx[keyword] = List();
					}
					if (isInlineList(this.ctx[keyword])) {
						throw this.error(new TomlError("Can't extend an inline array"));
					} else if (isList(this.ctx[keyword])) {
						const next = Table();
						this.ctx[keyword].push(next);
						this.ctx = next;
					} else {
						throw this.error(new TomlError("Can't redefine an existing key"));
					}
					return this.next(this.parseListEnd);
				} else if (this.char === CHAR_PERIOD) {
					if (!hasKey(this.ctx, keyword)) {
						this.ctx = this.ctx[keyword] = Table();
					} else if (isInlineList(this.ctx[keyword])) {
						throw this.error(new TomlError("Can't extend an inline array"));
					} else if (isInlineTable(this.ctx[keyword])) {
						throw this.error(new TomlError("Can't extend an inline table"));
					} else if (isList(this.ctx[keyword])) {
						this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
					} else if (isTable(this.ctx[keyword])) {
						this.ctx = this.ctx[keyword];
					} else {
						throw this.error(new TomlError("Can't redefine an existing key"));
					}
					return this.next(this.parseListNext);
				} else {
					throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
				}
			}
			parseListEnd(keyword) {
				if (this.char === CHAR_RSQB) {
					return this.next(this.parseWhitespaceToEOL);
				} else {
					throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
				}
			}
			parseValue() {
				if (this.char === Parser.END) {
					throw this.error(new TomlError("Key without value"));
				} else if (this.char === CHAR_QUOT) {
					return this.next(this.parseDoubleString);
				}
				if (this.char === CHAR_APOS) {
					return this.next(this.parseSingleString);
				} else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
					return this.goto(this.parseNumberSign);
				} else if (this.char === CHAR_i) {
					return this.next(this.parseInf);
				} else if (this.char === CHAR_n) {
					return this.next(this.parseNan);
				} else if (isDigit(this.char)) {
					return this.goto(this.parseNumberOrDateTime);
				} else if (this.char === CHAR_t || this.char === CHAR_f) {
					return this.goto(this.parseBoolean);
				} else if (this.char === CHAR_LSQB) {
					return this.call(this.parseInlineList, this.recordValue);
				} else if (this.char === CHAR_LCUB) {
					return this.call(this.parseInlineTable, this.recordValue);
				} else {
					throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
				}
			}
			recordValue(value) {
				return this.returnNow(value);
			}
			parseInf() {
				if (this.char === CHAR_n) {
					return this.next(this.parseInf2);
				} else {
					throw this.error(new TomlError("Unexpected character, expected \"inf\", \"+inf\" or \"-inf\""));
				}
			}
			parseInf2() {
				if (this.char === CHAR_f) {
					if (this.state.buf === "-") {
						return this.return(-Infinity);
					} else {
						return this.return(Infinity);
					}
				} else {
					throw this.error(new TomlError("Unexpected character, expected \"inf\", \"+inf\" or \"-inf\""));
				}
			}
			parseNan() {
				if (this.char === CHAR_a) {
					return this.next(this.parseNan2);
				} else {
					throw this.error(new TomlError("Unexpected character, expected \"nan\""));
				}
			}
			parseNan2() {
				if (this.char === CHAR_n) {
					return this.return(NaN);
				} else {
					throw this.error(new TomlError("Unexpected character, expected \"nan\""));
				}
			}
			parseKeyword() {
				if (this.char === CHAR_QUOT) {
					return this.next(this.parseBasicString);
				} else if (this.char === CHAR_APOS) {
					return this.next(this.parseLiteralString);
				} else {
					return this.goto(this.parseBareKey);
				}
			}
			parseBareKey() {
				do {
					if (this.char === Parser.END) {
						throw this.error(new TomlError("Key ended without value"));
					} else if (isAlphaNumHyphen(this.char)) {
						this.consume();
					} else if (this.state.buf.length === 0) {
						throw this.error(new TomlError("Empty bare keys are not allowed"));
					} else {
						return this.returnNow();
					}
				} while (this.nextChar());
			}
			parseSingleString() {
				if (this.char === CHAR_APOS) {
					return this.next(this.parseLiteralMultiStringMaybe);
				} else {
					return this.goto(this.parseLiteralString);
				}
			}
			parseLiteralString() {
				do {
					if (this.char === CHAR_APOS) {
						return this.return();
					} else if (this.atEndOfLine()) {
						throw this.error(new TomlError("Unterminated string"));
					} else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
						throw this.errorControlCharInString();
					} else {
						this.consume();
					}
				} while (this.nextChar());
			}
			parseLiteralMultiStringMaybe() {
				if (this.char === CHAR_APOS) {
					return this.next(this.parseLiteralMultiString);
				} else {
					return this.returnNow();
				}
			}
			parseLiteralMultiString() {
				if (this.char === CTRL_M) {
					return null;
				} else if (this.char === CTRL_J) {
					return this.next(this.parseLiteralMultiStringContent);
				} else {
					return this.goto(this.parseLiteralMultiStringContent);
				}
			}
			parseLiteralMultiStringContent() {
				do {
					if (this.char === CHAR_APOS) {
						return this.next(this.parseLiteralMultiEnd);
					} else if (this.char === Parser.END) {
						throw this.error(new TomlError("Unterminated multi-line string"));
					} else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
						throw this.errorControlCharInString();
					} else {
						this.consume();
					}
				} while (this.nextChar());
			}
			parseLiteralMultiEnd() {
				if (this.char === CHAR_APOS) {
					return this.next(this.parseLiteralMultiEnd2);
				} else {
					this.state.buf += "'";
					return this.goto(this.parseLiteralMultiStringContent);
				}
			}
			parseLiteralMultiEnd2() {
				if (this.char === CHAR_APOS) {
					return this.return();
				} else {
					this.state.buf += "''";
					return this.goto(this.parseLiteralMultiStringContent);
				}
			}
			parseDoubleString() {
				if (this.char === CHAR_QUOT) {
					return this.next(this.parseMultiStringMaybe);
				} else {
					return this.goto(this.parseBasicString);
				}
			}
			parseBasicString() {
				do {
					if (this.char === CHAR_BSOL) {
						return this.call(this.parseEscape, this.recordEscapeReplacement);
					} else if (this.char === CHAR_QUOT) {
						return this.return();
					} else if (this.atEndOfLine()) {
						throw this.error(new TomlError("Unterminated string"));
					} else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
						throw this.errorControlCharInString();
					} else {
						this.consume();
					}
				} while (this.nextChar());
			}
			recordEscapeReplacement(replacement) {
				this.state.buf += replacement;
				return this.goto(this.parseBasicString);
			}
			parseMultiStringMaybe() {
				if (this.char === CHAR_QUOT) {
					return this.next(this.parseMultiString);
				} else {
					return this.returnNow();
				}
			}
			parseMultiString() {
				if (this.char === CTRL_M) {
					return null;
				} else if (this.char === CTRL_J) {
					return this.next(this.parseMultiStringContent);
				} else {
					return this.goto(this.parseMultiStringContent);
				}
			}
			parseMultiStringContent() {
				do {
					if (this.char === CHAR_BSOL) {
						return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
					} else if (this.char === CHAR_QUOT) {
						return this.next(this.parseMultiEnd);
					} else if (this.char === Parser.END) {
						throw this.error(new TomlError("Unterminated multi-line string"));
					} else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
						throw this.errorControlCharInString();
					} else {
						this.consume();
					}
				} while (this.nextChar());
			}
			errorControlCharInString() {
				let displayCode = "\\u00";
				if (this.char < 16) {
					displayCode += "0";
				}
				displayCode += this.char.toString(16);
				return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
			}
			recordMultiEscapeReplacement(replacement) {
				this.state.buf += replacement;
				return this.goto(this.parseMultiStringContent);
			}
			parseMultiEnd() {
				if (this.char === CHAR_QUOT) {
					return this.next(this.parseMultiEnd2);
				} else {
					this.state.buf += "\"";
					return this.goto(this.parseMultiStringContent);
				}
			}
			parseMultiEnd2() {
				if (this.char === CHAR_QUOT) {
					return this.return();
				} else {
					this.state.buf += "\"\"";
					return this.goto(this.parseMultiStringContent);
				}
			}
			parseMultiEscape() {
				if (this.char === CTRL_M || this.char === CTRL_J) {
					return this.next(this.parseMultiTrim);
				} else if (this.char === CHAR_SP || this.char === CTRL_I) {
					return this.next(this.parsePreMultiTrim);
				} else {
					return this.goto(this.parseEscape);
				}
			}
			parsePreMultiTrim() {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else if (this.char === CTRL_M || this.char === CTRL_J) {
					return this.next(this.parseMultiTrim);
				} else {
					throw this.error(new TomlError("Can't escape whitespace"));
				}
			}
			parseMultiTrim() {
				if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
					return null;
				} else {
					return this.returnNow();
				}
			}
			parseEscape() {
				if (this.char in escapes) {
					return this.return(escapes[this.char]);
				} else if (this.char === CHAR_u) {
					return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
				} else if (this.char === CHAR_U) {
					return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
				} else {
					throw this.error(new TomlError("Unknown escape character: " + this.char));
				}
			}
			parseUnicodeReturn(char) {
				try {
					const codePoint = parseInt(char, 16);
					if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {
						throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
					}
					return this.returnNow(String.fromCodePoint(codePoint));
				} catch (err) {
					throw this.error(TomlError.wrap(err));
				}
			}
			parseSmallUnicode() {
				if (!isHexit(this.char)) {
					throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
				} else {
					this.consume();
					if (this.state.buf.length >= 4) return this.return();
				}
			}
			parseLargeUnicode() {
				if (!isHexit(this.char)) {
					throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
				} else {
					this.consume();
					if (this.state.buf.length >= 8) return this.return();
				}
			}
			parseNumberSign() {
				this.consume();
				return this.next(this.parseMaybeSignedInfOrNan);
			}
			parseMaybeSignedInfOrNan() {
				if (this.char === CHAR_i) {
					return this.next(this.parseInf);
				} else if (this.char === CHAR_n) {
					return this.next(this.parseNan);
				} else {
					return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
				}
			}
			parseNumberIntegerStart() {
				if (this.char === CHAR_0) {
					this.consume();
					return this.next(this.parseNumberIntegerExponentOrDecimal);
				} else {
					return this.goto(this.parseNumberInteger);
				}
			}
			parseNumberIntegerExponentOrDecimal() {
				if (this.char === CHAR_PERIOD) {
					this.consume();
					return this.call(this.parseNoUnder, this.parseNumberFloat);
				} else if (this.char === CHAR_E || this.char === CHAR_e) {
					this.consume();
					return this.next(this.parseNumberExponentSign);
				} else {
					return this.returnNow(Integer(this.state.buf));
				}
			}
			parseNumberInteger() {
				if (isDigit(this.char)) {
					this.consume();
				} else if (this.char === CHAR_LOWBAR) {
					return this.call(this.parseNoUnder);
				} else if (this.char === CHAR_E || this.char === CHAR_e) {
					this.consume();
					return this.next(this.parseNumberExponentSign);
				} else if (this.char === CHAR_PERIOD) {
					this.consume();
					return this.call(this.parseNoUnder, this.parseNumberFloat);
				} else {
					const result = Integer(this.state.buf);
					/* istanbul ignore if */
					if (result.isNaN()) {
						throw this.error(new TomlError("Invalid number"));
					} else {
						return this.returnNow(result);
					}
				}
			}
			parseNoUnder() {
				if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) {
					throw this.error(new TomlError("Unexpected character, expected digit"));
				} else if (this.atEndOfWord()) {
					throw this.error(new TomlError("Incomplete number"));
				}
				return this.returnNow();
			}
			parseNoUnderHexOctBinLiteral() {
				if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD) {
					throw this.error(new TomlError("Unexpected character, expected digit"));
				} else if (this.atEndOfWord()) {
					throw this.error(new TomlError("Incomplete number"));
				}
				return this.returnNow();
			}
			parseNumberFloat() {
				if (this.char === CHAR_LOWBAR) {
					return this.call(this.parseNoUnder, this.parseNumberFloat);
				} else if (isDigit(this.char)) {
					this.consume();
				} else if (this.char === CHAR_E || this.char === CHAR_e) {
					this.consume();
					return this.next(this.parseNumberExponentSign);
				} else {
					return this.returnNow(Float(this.state.buf));
				}
			}
			parseNumberExponentSign() {
				if (isDigit(this.char)) {
					return this.goto(this.parseNumberExponent);
				} else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
					this.consume();
					this.call(this.parseNoUnder, this.parseNumberExponent);
				} else {
					throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
				}
			}
			parseNumberExponent() {
				if (isDigit(this.char)) {
					this.consume();
				} else if (this.char === CHAR_LOWBAR) {
					return this.call(this.parseNoUnder);
				} else {
					return this.returnNow(Float(this.state.buf));
				}
			}
			parseNumberOrDateTime() {
				if (this.char === CHAR_0) {
					this.consume();
					return this.next(this.parseNumberBaseOrDateTime);
				} else {
					return this.goto(this.parseNumberOrDateTimeOnly);
				}
			}
			parseNumberOrDateTimeOnly() {
				if (this.char === CHAR_LOWBAR) {
					return this.call(this.parseNoUnder, this.parseNumberInteger);
				} else if (isDigit(this.char)) {
					this.consume();
					if (this.state.buf.length > 4) this.next(this.parseNumberInteger);
				} else if (this.char === CHAR_E || this.char === CHAR_e) {
					this.consume();
					return this.next(this.parseNumberExponentSign);
				} else if (this.char === CHAR_PERIOD) {
					this.consume();
					return this.call(this.parseNoUnder, this.parseNumberFloat);
				} else if (this.char === CHAR_HYPHEN) {
					return this.goto(this.parseDateTime);
				} else if (this.char === CHAR_COLON) {
					return this.goto(this.parseOnlyTimeHour);
				} else {
					return this.returnNow(Integer(this.state.buf));
				}
			}
			parseDateTimeOnly() {
				if (this.state.buf.length < 4) {
					if (isDigit(this.char)) {
						return this.consume();
					} else if (this.char === CHAR_COLON) {
						return this.goto(this.parseOnlyTimeHour);
					} else {
						throw this.error(new TomlError("Expected digit while parsing year part of a date"));
					}
				} else {
					if (this.char === CHAR_HYPHEN) {
						return this.goto(this.parseDateTime);
					} else {
						throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
					}
				}
			}
			parseNumberBaseOrDateTime() {
				if (this.char === CHAR_b) {
					this.consume();
					return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin);
				} else if (this.char === CHAR_o) {
					this.consume();
					return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct);
				} else if (this.char === CHAR_x) {
					this.consume();
					return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex);
				} else if (this.char === CHAR_PERIOD) {
					return this.goto(this.parseNumberInteger);
				} else if (isDigit(this.char)) {
					return this.goto(this.parseDateTimeOnly);
				} else {
					return this.returnNow(Integer(this.state.buf));
				}
			}
			parseIntegerHex() {
				if (isHexit(this.char)) {
					this.consume();
				} else if (this.char === CHAR_LOWBAR) {
					return this.call(this.parseNoUnderHexOctBinLiteral);
				} else {
					const result = Integer(this.state.buf);
					/* istanbul ignore if */
					if (result.isNaN()) {
						throw this.error(new TomlError("Invalid number"));
					} else {
						return this.returnNow(result);
					}
				}
			}
			parseIntegerOct() {
				if (isOctit(this.char)) {
					this.consume();
				} else if (this.char === CHAR_LOWBAR) {
					return this.call(this.parseNoUnderHexOctBinLiteral);
				} else {
					const result = Integer(this.state.buf);
					/* istanbul ignore if */
					if (result.isNaN()) {
						throw this.error(new TomlError("Invalid number"));
					} else {
						return this.returnNow(result);
					}
				}
			}
			parseIntegerBin() {
				if (isBit(this.char)) {
					this.consume();
				} else if (this.char === CHAR_LOWBAR) {
					return this.call(this.parseNoUnderHexOctBinLiteral);
				} else {
					const result = Integer(this.state.buf);
					/* istanbul ignore if */
					if (result.isNaN()) {
						throw this.error(new TomlError("Invalid number"));
					} else {
						return this.returnNow(result);
					}
				}
			}
			parseDateTime() {
				if (this.state.buf.length < 4) {
					throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
				}
				this.state.result = this.state.buf;
				this.state.buf = "";
				return this.next(this.parseDateMonth);
			}
			parseDateMonth() {
				if (this.char === CHAR_HYPHEN) {
					if (this.state.buf.length < 2) {
						throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
					}
					this.state.result += "-" + this.state.buf;
					this.state.buf = "";
					return this.next(this.parseDateDay);
				} else if (isDigit(this.char)) {
					this.consume();
				} else {
					throw this.error(new TomlError("Incomplete datetime"));
				}
			}
			parseDateDay() {
				if (this.char === CHAR_T || this.char === CHAR_SP) {
					if (this.state.buf.length < 2) {
						throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
					}
					this.state.result += "-" + this.state.buf;
					this.state.buf = "";
					return this.next(this.parseStartTimeHour);
				} else if (this.atEndOfWord()) {
					return this.returnNow(createDate(this.state.result + "-" + this.state.buf));
				} else if (isDigit(this.char)) {
					this.consume();
				} else {
					throw this.error(new TomlError("Incomplete datetime"));
				}
			}
			parseStartTimeHour() {
				if (this.atEndOfWord()) {
					return this.returnNow(createDate(this.state.result));
				} else {
					return this.goto(this.parseTimeHour);
				}
			}
			parseTimeHour() {
				if (this.char === CHAR_COLON) {
					if (this.state.buf.length < 2) {
						throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
					}
					this.state.result += "T" + this.state.buf;
					this.state.buf = "";
					return this.next(this.parseTimeMin);
				} else if (isDigit(this.char)) {
					this.consume();
				} else {
					throw this.error(new TomlError("Incomplete datetime"));
				}
			}
			parseTimeMin() {
				if (this.state.buf.length < 2 && isDigit(this.char)) {
					this.consume();
				} else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
					this.state.result += ":" + this.state.buf;
					this.state.buf = "";
					return this.next(this.parseTimeSec);
				} else {
					throw this.error(new TomlError("Incomplete datetime"));
				}
			}
			parseTimeSec() {
				if (isDigit(this.char)) {
					this.consume();
					if (this.state.buf.length === 2) {
						this.state.result += ":" + this.state.buf;
						this.state.buf = "";
						return this.next(this.parseTimeZoneOrFraction);
					}
				} else {
					throw this.error(new TomlError("Incomplete datetime"));
				}
			}
			parseOnlyTimeHour() {
				/* istanbul ignore else */
				if (this.char === CHAR_COLON) {
					if (this.state.buf.length < 2) {
						throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
					}
					this.state.result = this.state.buf;
					this.state.buf = "";
					return this.next(this.parseOnlyTimeMin);
				} else {
					throw this.error(new TomlError("Incomplete time"));
				}
			}
			parseOnlyTimeMin() {
				if (this.state.buf.length < 2 && isDigit(this.char)) {
					this.consume();
				} else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
					this.state.result += ":" + this.state.buf;
					this.state.buf = "";
					return this.next(this.parseOnlyTimeSec);
				} else {
					throw this.error(new TomlError("Incomplete time"));
				}
			}
			parseOnlyTimeSec() {
				if (isDigit(this.char)) {
					this.consume();
					if (this.state.buf.length === 2) {
						return this.next(this.parseOnlyTimeFractionMaybe);
					}
				} else {
					throw this.error(new TomlError("Incomplete time"));
				}
			}
			parseOnlyTimeFractionMaybe() {
				this.state.result += ":" + this.state.buf;
				if (this.char === CHAR_PERIOD) {
					this.state.buf = "";
					this.next(this.parseOnlyTimeFraction);
				} else {
					return this.return(createTime(this.state.result));
				}
			}
			parseOnlyTimeFraction() {
				if (isDigit(this.char)) {
					this.consume();
				} else if (this.atEndOfWord()) {
					if (this.state.buf.length === 0) throw this.error(new TomlError("Expected digit in milliseconds"));
					return this.returnNow(createTime(this.state.result + "." + this.state.buf));
				} else {
					throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
				}
			}
			parseTimeZoneOrFraction() {
				if (this.char === CHAR_PERIOD) {
					this.consume();
					this.next(this.parseDateTimeFraction);
				} else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
					this.consume();
					this.next(this.parseTimeZoneHour);
				} else if (this.char === CHAR_Z) {
					this.consume();
					return this.return(createDateTime(this.state.result + this.state.buf));
				} else if (this.atEndOfWord()) {
					return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
				} else {
					throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
				}
			}
			parseDateTimeFraction() {
				if (isDigit(this.char)) {
					this.consume();
				} else if (this.state.buf.length === 1) {
					throw this.error(new TomlError("Expected digit in milliseconds"));
				} else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
					this.consume();
					this.next(this.parseTimeZoneHour);
				} else if (this.char === CHAR_Z) {
					this.consume();
					return this.return(createDateTime(this.state.result + this.state.buf));
				} else if (this.atEndOfWord()) {
					return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
				} else {
					throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
				}
			}
			parseTimeZoneHour() {
				if (isDigit(this.char)) {
					this.consume();
					if (/\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
				} else {
					throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
				}
			}
			parseTimeZoneSep() {
				if (this.char === CHAR_COLON) {
					this.consume();
					this.next(this.parseTimeZoneMin);
				} else {
					throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
				}
			}
			parseTimeZoneMin() {
				if (isDigit(this.char)) {
					this.consume();
					if (/\d\d$/.test(this.state.buf)) return this.return(createDateTime(this.state.result + this.state.buf));
				} else {
					throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
				}
			}
			parseBoolean() {
				/* istanbul ignore else */
				if (this.char === CHAR_t) {
					this.consume();
					return this.next(this.parseTrue_r);
				} else if (this.char === CHAR_f) {
					this.consume();
					return this.next(this.parseFalse_a);
				}
			}
			parseTrue_r() {
				if (this.char === CHAR_r) {
					this.consume();
					return this.next(this.parseTrue_u);
				} else {
					throw this.error(new TomlError("Invalid boolean, expected true or false"));
				}
			}
			parseTrue_u() {
				if (this.char === CHAR_u) {
					this.consume();
					return this.next(this.parseTrue_e);
				} else {
					throw this.error(new TomlError("Invalid boolean, expected true or false"));
				}
			}
			parseTrue_e() {
				if (this.char === CHAR_e) {
					return this.return(true);
				} else {
					throw this.error(new TomlError("Invalid boolean, expected true or false"));
				}
			}
			parseFalse_a() {
				if (this.char === CHAR_a) {
					this.consume();
					return this.next(this.parseFalse_l);
				} else {
					throw this.error(new TomlError("Invalid boolean, expected true or false"));
				}
			}
			parseFalse_l() {
				if (this.char === CHAR_l) {
					this.consume();
					return this.next(this.parseFalse_s);
				} else {
					throw this.error(new TomlError("Invalid boolean, expected true or false"));
				}
			}
			parseFalse_s() {
				if (this.char === CHAR_s) {
					this.consume();
					return this.next(this.parseFalse_e);
				} else {
					throw this.error(new TomlError("Invalid boolean, expected true or false"));
				}
			}
			parseFalse_e() {
				if (this.char === CHAR_e) {
					return this.return(false);
				} else {
					throw this.error(new TomlError("Invalid boolean, expected true or false"));
				}
			}
			parseInlineList() {
				if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
					return null;
				} else if (this.char === Parser.END) {
					throw this.error(new TomlError("Unterminated inline array"));
				} else if (this.char === CHAR_NUM) {
					return this.call(this.parseComment);
				} else if (this.char === CHAR_RSQB) {
					return this.return(this.state.resultArr || InlineList());
				} else {
					return this.callNow(this.parseValue, this.recordInlineListValue);
				}
			}
			recordInlineListValue(value) {
				if (this.state.resultArr) {
					const listType = this.state.resultArr[_contentType];
					const valueType = tomlType(value);
					if (listType !== valueType) {
						throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
					}
				} else {
					this.state.resultArr = InlineList(tomlType(value));
				}
				if (isFloat(value) || isInteger(value)) {
					this.state.resultArr.push(value.valueOf());
				} else {
					this.state.resultArr.push(value);
				}
				return this.goto(this.parseInlineListNext);
			}
			parseInlineListNext() {
				if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
					return null;
				} else if (this.char === CHAR_NUM) {
					return this.call(this.parseComment);
				} else if (this.char === CHAR_COMMA) {
					return this.next(this.parseInlineList);
				} else if (this.char === CHAR_RSQB) {
					return this.goto(this.parseInlineList);
				} else {
					throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
				}
			}
			parseInlineTable() {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
					throw this.error(new TomlError("Unterminated inline array"));
				} else if (this.char === CHAR_RCUB) {
					return this.return(this.state.resultTable || InlineTable());
				} else {
					if (!this.state.resultTable) this.state.resultTable = InlineTable();
					return this.callNow(this.parseAssign, this.recordInlineTableValue);
				}
			}
			recordInlineTableValue(kv) {
				let target = this.state.resultTable;
				let finalKey = kv.key.pop();
				for (let kw of kv.key) {
					if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
						throw this.error(new TomlError("Can't redefine existing key"));
					}
					target = target[kw] = target[kw] || Table();
				}
				if (hasKey(target, finalKey)) {
					throw this.error(new TomlError("Can't redefine existing key"));
				}
				if (isInteger(kv.value) || isFloat(kv.value)) {
					target[finalKey] = kv.value.valueOf();
				} else {
					target[finalKey] = kv.value;
				}
				return this.goto(this.parseInlineTableNext);
			}
			parseInlineTableNext() {
				if (this.char === CHAR_SP || this.char === CTRL_I) {
					return null;
				} else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
					throw this.error(new TomlError("Unterminated inline array"));
				} else if (this.char === CHAR_COMMA) {
					return this.next(this.parseInlineTable);
				} else if (this.char === CHAR_RCUB) {
					return this.goto(this.parseInlineTable);
				} else {
					throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
				}
			}
		}
		return TOMLParser;
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/parse-pretty-error.js
var require_parse_pretty_error = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = prettyError;
	function prettyError(err, buf) {
		/* istanbul ignore if */
		if (err.pos == null || err.line == null) return err;
		let msg = err.message;
		msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:\n`;
		/* istanbul ignore else */
		if (buf && buf.split) {
			const lines = buf.split(/\n/);
			const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
			let linePadding = " ";
			while (linePadding.length < lineNumWidth) linePadding += " ";
			for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {
				let lineNum = String(ii + 1);
				if (lineNum.length < lineNumWidth) lineNum = " " + lineNum;
				if (err.line === ii) {
					msg += lineNum + "> " + lines[ii] + "\n";
					msg += linePadding + "  ";
					for (let hh = 0; hh < err.col; ++hh) {
						msg += " ";
					}
					msg += "^\n";
				} else {
					msg += lineNum + ": " + lines[ii] + "\n";
				}
			}
		}
		err.message = msg + "\n";
		return err;
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/parse-string.js
var require_parse_string = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = parseString;
	const TOMLParser = require_toml_parser();
	const prettyError = require_parse_pretty_error();
	function parseString(str) {
		if (global.Buffer && global.Buffer.isBuffer(str)) {
			str = str.toString("utf8");
		}
		const parser = new TOMLParser();
		try {
			parser.parse(str);
			return parser.finish();
		} catch (err) {
			throw prettyError(err, str);
		}
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/parse-async.js
var require_parse_async = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = parseAsync;
	const TOMLParser = require_toml_parser();
	const prettyError = require_parse_pretty_error();
	function parseAsync(str, opts) {
		if (!opts) opts = {};
		const index = 0;
		const blocksize = opts.blocksize || 40960;
		const parser = new TOMLParser();
		return new Promise((resolve, reject) => {
			setImmediate(parseAsyncNext, index, blocksize, resolve, reject);
		});
		function parseAsyncNext(index$1, blocksize$1, resolve, reject) {
			if (index$1 >= str.length) {
				try {
					return resolve(parser.finish());
				} catch (err) {
					return reject(prettyError(err, str));
				}
			}
			try {
				parser.parse(str.slice(index$1, index$1 + blocksize$1));
				setImmediate(parseAsyncNext, index$1 + blocksize$1, blocksize$1, resolve, reject);
			} catch (err) {
				reject(prettyError(err, str));
			}
		}
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/parse-stream.js
var require_parse_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = parseStream;
	const stream = require("stream");
	const TOMLParser = require_toml_parser();
	function parseStream(stm) {
		if (stm) {
			return parseReadable(stm);
		} else {
			return parseTransform(stm);
		}
	}
	function parseReadable(stm) {
		const parser = new TOMLParser();
		stm.setEncoding("utf8");
		return new Promise((resolve, reject) => {
			let readable;
			let ended = false;
			let errored = false;
			function finish() {
				ended = true;
				if (readable) return;
				try {
					resolve(parser.finish());
				} catch (err) {
					reject(err);
				}
			}
			function error$47(err) {
				errored = true;
				reject(err);
			}
			stm.once("end", finish);
			stm.once("error", error$47);
			readNext();
			function readNext() {
				readable = true;
				let data;
				while ((data = stm.read()) !== null) {
					try {
						parser.parse(data);
					} catch (err) {
						return error$47(err);
					}
				}
				readable = false;
				/* istanbul ignore if */
				if (ended) return finish();
				/* istanbul ignore if */
				if (errored) return;
				stm.once("readable", readNext);
			}
		});
	}
	function parseTransform() {
		const parser = new TOMLParser();
		return new stream.Transform({
			objectMode: true,
			transform(chunk, encoding, cb) {
				try {
					parser.parse(chunk.toString(encoding));
				} catch (err) {
					this.emit("error", err);
				}
				cb();
			},
			flush(cb) {
				try {
					this.push(parser.finish());
				} catch (err) {
					this.emit("error", err);
				}
				cb();
			}
		});
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/parse.js
var require_parse$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_parse_string();
	module.exports.async = require_parse_async();
	module.exports.stream = require_parse_stream();
	module.exports.prettyError = require_parse_pretty_error();
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/stringify.js
var require_stringify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = stringify;
	module.exports.value = stringifyInline;
	function stringify(obj) {
		if (obj === null) throw typeError("null");
		if (obj === void 0) throw typeError("undefined");
		if (typeof obj !== "object") throw typeError(typeof obj);
		if (typeof obj.toJSON === "function") obj = obj.toJSON();
		if (obj == null) return null;
		const type = tomlType(obj);
		if (type !== "table") throw typeError(type);
		return stringifyObject("", "", obj);
	}
	function typeError(type) {
		return new Error("Can only stringify objects, not " + type);
	}
	function arrayOneTypeError() {
		return new Error("Array values can't have mixed types");
	}
	function getInlineKeys(obj) {
		return Object.keys(obj).filter((key) => isInline(obj[key]));
	}
	function getComplexKeys(obj) {
		return Object.keys(obj).filter((key) => !isInline(obj[key]));
	}
	function toJSON(obj) {
		let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, "__proto__") ? { ["__proto__"]: undefined } : {};
		for (let prop of Object.keys(obj)) {
			if (obj[prop] && typeof obj[prop].toJSON === "function" && !("toISOString" in obj[prop])) {
				nobj[prop] = obj[prop].toJSON();
			} else {
				nobj[prop] = obj[prop];
			}
		}
		return nobj;
	}
	function stringifyObject(prefix, indent, obj) {
		obj = toJSON(obj);
		var inlineKeys;
		var complexKeys;
		inlineKeys = getInlineKeys(obj);
		complexKeys = getComplexKeys(obj);
		var result = [];
		var inlineIndent = indent || "";
		inlineKeys.forEach((key) => {
			var type = tomlType(obj[key]);
			if (type !== "undefined" && type !== "null") {
				result.push(inlineIndent + stringifyKey(key) + " = " + stringifyAnyInline(obj[key], true));
			}
		});
		if (result.length > 0) result.push("");
		var complexIndent = prefix && inlineKeys.length > 0 ? indent + "  " : "";
		complexKeys.forEach((key) => {
			result.push(stringifyComplex(prefix, complexIndent, key, obj[key]));
		});
		return result.join("\n");
	}
	function isInline(value) {
		switch (tomlType(value)) {
			case "undefined":
			case "null":
			case "integer":
			case "nan":
			case "float":
			case "boolean":
			case "string":
			case "datetime": return true;
			case "array": return value.length === 0 || tomlType(value[0]) !== "table";
			case "table": return Object.keys(value).length === 0;
			default: return false;
		}
	}
	function tomlType(value) {
		if (value === undefined) {
			return "undefined";
		} else if (value === null) {
			return "null";
		} else if (typeof value === "bigint" || Number.isInteger(value) && !Object.is(value, -0)) {
			return "integer";
		} else if (typeof value === "number") {
			return "float";
		} else if (typeof value === "boolean") {
			return "boolean";
		} else if (typeof value === "string") {
			return "string";
		} else if ("toISOString" in value) {
			return isNaN(value) ? "undefined" : "datetime";
		} else if (Array.isArray(value)) {
			return "array";
		} else {
			return "table";
		}
	}
	function stringifyKey(key) {
		var keyStr = String(key);
		if (/^[-A-Za-z0-9_]+$/.test(keyStr)) {
			return keyStr;
		} else {
			return stringifyBasicString(keyStr);
		}
	}
	function stringifyBasicString(str) {
		return "\"" + escapeString(str).replace(/"/g, "\\\"") + "\"";
	}
	function stringifyLiteralString(str) {
		return "'" + str + "'";
	}
	function numpad(num, str) {
		while (str.length < num) str = "0" + str;
		return str;
	}
	function escapeString(str) {
		return str.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/([\u0000-\u001f\u007f])/, (c) => "\\u" + numpad(4, c.codePointAt(0).toString(16)));
	}
	function stringifyMultilineString(str) {
		let escaped = str.split(/\n/).map((str$1) => {
			return escapeString(str$1).replace(/"(?="")/g, "\\\"");
		}).join("\n");
		if (escaped.slice(-1) === "\"") escaped += "\\\n";
		return "\"\"\"\n" + escaped + "\"\"\"";
	}
	function stringifyAnyInline(value, multilineOk) {
		let type = tomlType(value);
		if (type === "string") {
			if (multilineOk && /\n/.test(value)) {
				type = "string-multiline";
			} else if (!/[\b\t\n\f\r']/.test(value) && /"/.test(value)) {
				type = "string-literal";
			}
		}
		return stringifyInline(value, type);
	}
	function stringifyInline(value, type) {
		/* istanbul ignore if */
		if (!type) type = tomlType(value);
		switch (type) {
			case "string-multiline": return stringifyMultilineString(value);
			case "string": return stringifyBasicString(value);
			case "string-literal": return stringifyLiteralString(value);
			case "integer": return stringifyInteger(value);
			case "float": return stringifyFloat(value);
			case "boolean": return stringifyBoolean(value);
			case "datetime": return stringifyDatetime(value);
			case "array": return stringifyInlineArray(value.filter((_) => tomlType(_) !== "null" && tomlType(_) !== "undefined" && tomlType(_) !== "nan"));
			case "table": return stringifyInlineTable(value);
			default: throw typeError(type);
		}
	}
	function stringifyInteger(value) {
		return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, "_");
	}
	function stringifyFloat(value) {
		if (value === Infinity) {
			return "inf";
		} else if (value === -Infinity) {
			return "-inf";
		} else if (Object.is(value, NaN)) {
			return "nan";
		} else if (Object.is(value, -0)) {
			return "-0.0";
		}
		var chunks = String(value).split(".");
		var int$2 = chunks[0];
		var dec = chunks[1] || 0;
		return stringifyInteger(int$2) + "." + dec;
	}
	function stringifyBoolean(value) {
		return String(value);
	}
	function stringifyDatetime(value) {
		return value.toISOString();
	}
	function isNumber(type) {
		return type === "float" || type === "integer";
	}
	function arrayType(values) {
		var contentType = tomlType(values[0]);
		if (values.every((_) => tomlType(_) === contentType)) return contentType;
		if (values.every((_) => isNumber(tomlType(_)))) return "float";
		return "mixed";
	}
	function validateArray(values) {
		const type = arrayType(values);
		if (type === "mixed") {
			throw arrayOneTypeError();
		}
		return type;
	}
	function stringifyInlineArray(values) {
		values = toJSON(values);
		const type = validateArray(values);
		var result = "[";
		var stringified = values.map((_) => stringifyInline(_, type));
		if (stringified.join(", ").length > 60 || /\n/.test(stringified)) {
			result += "\n  " + stringified.join(",\n  ") + "\n";
		} else {
			result += " " + stringified.join(", ") + (stringified.length > 0 ? " " : "");
		}
		return result + "]";
	}
	function stringifyInlineTable(value) {
		value = toJSON(value);
		var result = [];
		Object.keys(value).forEach((key) => {
			result.push(stringifyKey(key) + " = " + stringifyAnyInline(value[key], false));
		});
		return "{ " + result.join(", ") + (result.length > 0 ? " " : "") + "}";
	}
	function stringifyComplex(prefix, indent, key, value) {
		var valueType = tomlType(value);
		/* istanbul ignore else */
		if (valueType === "array") {
			return stringifyArrayOfTables(prefix, indent, key, value);
		} else if (valueType === "table") {
			return stringifyComplexTable(prefix, indent, key, value);
		} else {
			throw typeError(valueType);
		}
	}
	function stringifyArrayOfTables(prefix, indent, key, values) {
		values = toJSON(values);
		validateArray(values);
		var firstValueType = tomlType(values[0]);
		/* istanbul ignore if */
		if (firstValueType !== "table") throw typeError(firstValueType);
		var fullKey = prefix + stringifyKey(key);
		var result = "";
		values.forEach((table) => {
			if (result.length > 0) result += "\n";
			result += indent + "[[" + fullKey + "]]\n";
			result += stringifyObject(fullKey + ".", indent, table);
		});
		return result;
	}
	function stringifyComplexTable(prefix, indent, key, value) {
		var fullKey = prefix + stringifyKey(key);
		var result = "";
		if (getInlineKeys(value).length > 0) {
			result += indent + "[" + fullKey + "]\n";
		}
		return result + stringifyObject(fullKey + ".", indent, value);
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@iarna/toml/toml.js
var require_toml = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.parse = require_parse$1();
	exports.stringify = require_stringify();
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/core.js
var import_toml = require_toml();
var import_commander = require_commander();
/** A special constant with type `never` */
const NEVER$1 = Object.freeze({ status: "aborted" });
function $constructor(name, initializer$2, params) {
	function init(inst, def) {
		if (!inst._zod) {
			Object.defineProperty(inst, "_zod", {
				value: {
					def,
					constr: _,
					traits: new Set()
				},
				enumerable: false
			});
		}
		if (inst._zod.traits.has(name)) {
			return;
		}
		inst._zod.traits.add(name);
		initializer$2(inst, def);
		const proto = _.prototype;
		const keys = Object.keys(proto);
		for (let i = 0; i < keys.length; i++) {
			const k = keys[i];
			if (!(k in inst)) {
				inst[k] = proto[k].bind(inst);
			}
		}
	}
	const Parent = params?.Parent ?? Object;
	class Definition extends Parent {}
	Object.defineProperty(Definition, "name", { value: name });
	function _(def) {
		var _a$1;
		const inst = params?.Parent ? new Definition() : this;
		init(inst, def);
		(_a$1 = inst._zod).deferred ?? (_a$1.deferred = []);
		for (const fn of inst._zod.deferred) {
			fn();
		}
		return inst;
	}
	Object.defineProperty(_, "init", { value: init });
	Object.defineProperty(_, Symbol.hasInstance, { value: (inst) => {
		if (params?.Parent && inst instanceof params.Parent) return true;
		return inst?._zod?.traits?.has(name);
	} });
	Object.defineProperty(_, "name", { value: name });
	return _;
}
const $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
	constructor() {
		super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	}
};
var $ZodEncodeError = class extends Error {
	constructor(name) {
		super(`Encountered unidirectional transform during encode: ${name}`);
		this.name = "ZodEncodeError";
	}
};
const globalConfig = {};
function config(newConfig) {
	if (newConfig) Object.assign(globalConfig, newConfig);
	return globalConfig;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/util.js
var util_exports = /* @__PURE__ */ __exportAll({
	BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
	Class: () => Class$2,
	NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
	aborted: () => aborted,
	allowsEval: () => allowsEval,
	assert: () => assert,
	assertEqual: () => assertEqual,
	assertIs: () => assertIs,
	assertNever: () => assertNever,
	assertNotEqual: () => assertNotEqual,
	assignProp: () => assignProp,
	base64ToUint8Array: () => base64ToUint8Array,
	base64urlToUint8Array: () => base64urlToUint8Array,
	cached: () => cached,
	captureStackTrace: () => captureStackTrace,
	cleanEnum: () => cleanEnum,
	cleanRegex: () => cleanRegex,
	clone: () => clone,
	cloneDef: () => cloneDef,
	createTransparentProxy: () => createTransparentProxy,
	defineLazy: () => defineLazy,
	esc: () => esc,
	escapeRegex: () => escapeRegex,
	extend: () => extend$1,
	finalizeIssue: () => finalizeIssue,
	floatSafeRemainder: () => floatSafeRemainder$1,
	getElementAtPath: () => getElementAtPath,
	getEnumValues: () => getEnumValues,
	getLengthableOrigin: () => getLengthableOrigin,
	getParsedType: () => getParsedType$1,
	getSizableOrigin: () => getSizableOrigin,
	hexToUint8Array: () => hexToUint8Array,
	isObject: () => isObject,
	isPlainObject: () => isPlainObject$2,
	issue: () => issue,
	joinValues: () => joinValues,
	jsonStringifyReplacer: () => jsonStringifyReplacer,
	merge: () => merge$1,
	mergeDefs: () => mergeDefs,
	normalizeParams: () => normalizeParams,
	nullish: () => nullish$2,
	numKeys: () => numKeys,
	objectClone: () => objectClone,
	omit: () => omit$1,
	optionalKeys: () => optionalKeys,
	parsedType: () => parsedType,
	partial: () => partial$1,
	pick: () => pick$1,
	prefixIssues: () => prefixIssues,
	primitiveTypes: () => primitiveTypes,
	promiseAllObject: () => promiseAllObject,
	propertyKeyTypes: () => propertyKeyTypes,
	randomString: () => randomString,
	required: () => required$1,
	safeExtend: () => safeExtend$1,
	shallowClone: () => shallowClone,
	slugify: () => slugify,
	stringifyPrimitive: () => stringifyPrimitive,
	uint8ArrayToBase64: () => uint8ArrayToBase64,
	uint8ArrayToBase64url: () => uint8ArrayToBase64url,
	uint8ArrayToHex: () => uint8ArrayToHex,
	unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
	return val;
}
function assertNotEqual(val) {
	return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
	throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {}
function getEnumValues(entries) {
	const numericValues = Object.values(entries).filter((v) => typeof v === "number");
	const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
	return values;
}
function joinValues(array$2, separator = "|") {
	return array$2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
	if (typeof value === "bigint") return value.toString();
	return value;
}
function cached(getter) {
	const set$2 = false;
	return { get value() {
		if (!set$2) {
			const value = getter();
			Object.defineProperty(this, "value", { value });
			return value;
		}
		throw new Error("cached value already set");
	} };
}
function nullish$2(input) {
	return input === null || input === undefined;
}
function cleanRegex(source) {
	const start = source.startsWith("^") ? 1 : 0;
	const end = source.endsWith("$") ? source.length - 1 : source.length;
	return source.slice(start, end);
}
function floatSafeRemainder$1(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepString = step.toString();
	let stepDecCount = (stepString.split(".")[1] || "").length;
	if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
		const match = stepString.match(/\d?e-(\d?)/);
		if (match?.[1]) {
			stepDecCount = Number.parseInt(match[1]);
		}
	}
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
	const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
	return valInt % stepInt / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object$2, key, getter) {
	let value = undefined;
	Object.defineProperty(object$2, key, {
		get() {
			if (value === EVALUATING) {
				return undefined;
			}
			if (value === undefined) {
				value = EVALUATING;
				value = getter();
			}
			return value;
		},
		set(v) {
			Object.defineProperty(object$2, key, { value: v });
		},
		configurable: true
	});
}
function objectClone(obj) {
	return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
	Object.defineProperty(target, prop, {
		value,
		writable: true,
		enumerable: true,
		configurable: true
	});
}
function mergeDefs(...defs) {
	const mergedDescriptors = {};
	for (const def of defs) {
		const descriptors = Object.getOwnPropertyDescriptors(def);
		Object.assign(mergedDescriptors, descriptors);
	}
	return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
	return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path$12) {
	if (!path$12) return obj;
	return path$12.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
	const keys = Object.keys(promisesObj);
	const promises = keys.map((key) => promisesObj[key]);
	return Promise.all(promises).then((results) => {
		const resolvedObj = {};
		for (let i = 0; i < keys.length; i++) {
			resolvedObj[keys[i]] = results[i];
		}
		return resolvedObj;
	});
}
function randomString(length = 10) {
	const chars = "abcdefghijklmnopqrstuvwxyz";
	let str = "";
	for (let i = 0; i < length; i++) {
		str += chars[Math.floor(Math.random() * chars.length)];
	}
	return str;
}
function esc(str) {
	return JSON.stringify(str);
}
function slugify(input) {
	return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
	return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
	if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
		return false;
	}
	try {
		const F = Function;
		new F("");
		return true;
	} catch (_) {
		return false;
	}
});
function isPlainObject$2(o) {
	if (isObject(o) === false) return false;
	const ctor = o.constructor;
	if (ctor === undefined) return true;
	if (typeof ctor !== "function") return true;
	const prot = ctor.prototype;
	if (isObject(prot) === false) return false;
	if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
		return false;
	}
	return true;
}
function shallowClone(o) {
	if (isPlainObject$2(o)) return { ...o };
	if (Array.isArray(o)) return [...o];
	return o;
}
function numKeys(data) {
	let keyCount = 0;
	for (const key in data) {
		if (Object.prototype.hasOwnProperty.call(data, key)) {
			keyCount++;
		}
	}
	return keyCount;
}
const getParsedType$1 = (data) => {
	const t = typeof data;
	switch (t) {
		case "undefined": return "undefined";
		case "string": return "string";
		case "number": return Number.isNaN(data) ? "nan" : "number";
		case "boolean": return "boolean";
		case "function": return "function";
		case "bigint": return "bigint";
		case "symbol": return "symbol";
		case "object":
			if (Array.isArray(data)) {
				return "array";
			}
			if (data === null) {
				return "null";
			}
			if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
				return "promise";
			}
			if (typeof Map !== "undefined" && data instanceof Map) {
				return "map";
			}
			if (typeof Set !== "undefined" && data instanceof Set) {
				return "set";
			}
			if (typeof Date !== "undefined" && data instanceof Date) {
				return "date";
			}
			if (typeof File !== "undefined" && data instanceof File) {
				return "file";
			}
			return "object";
		default: throw new Error(`Unknown data type: ${t}`);
	}
};
const propertyKeyTypes = new Set([
	"string",
	"number",
	"symbol"
]);
const primitiveTypes = new Set([
	"string",
	"number",
	"bigint",
	"boolean",
	"symbol",
	"undefined"
]);
function escapeRegex(str) {
	return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
	const cl = new inst._zod.constr(def ?? inst._zod.def);
	if (!def || params?.parent) cl._zod.parent = inst;
	return cl;
}
function normalizeParams(_params) {
	const params = _params;
	if (!params) return {};
	if (typeof params === "string") return { error: () => params };
	if (params?.message !== undefined) {
		if (params?.error !== undefined) throw new Error("Cannot specify both `message` and `error` params");
		params.error = params.message;
	}
	delete params.message;
	if (typeof params.error === "string") return {
		...params,
		error: () => params.error
	};
	return params;
}
function createTransparentProxy(getter) {
	let target;
	return new Proxy({}, {
		get(_, prop, receiver) {
			target ?? (target = getter());
			return Reflect.get(target, prop, receiver);
		},
		set(_, prop, value, receiver) {
			target ?? (target = getter());
			return Reflect.set(target, prop, value, receiver);
		},
		has(_, prop) {
			target ?? (target = getter());
			return Reflect.has(target, prop);
		},
		deleteProperty(_, prop) {
			target ?? (target = getter());
			return Reflect.deleteProperty(target, prop);
		},
		ownKeys(_) {
			target ?? (target = getter());
			return Reflect.ownKeys(target);
		},
		getOwnPropertyDescriptor(_, prop) {
			target ?? (target = getter());
			return Reflect.getOwnPropertyDescriptor(target, prop);
		},
		defineProperty(_, prop, descriptor) {
			target ?? (target = getter());
			return Reflect.defineProperty(target, prop, descriptor);
		}
	});
}
function stringifyPrimitive(value) {
	if (typeof value === "bigint") return value.toString() + "n";
	if (typeof value === "string") return `"${value}"`;
	return `${value}`;
}
function optionalKeys(shape) {
	return Object.keys(shape).filter((k) => {
		return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
	});
}
const NUMBER_FORMAT_RANGES = {
	safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
	int32: [-2147483648, 2147483647],
	uint32: [0, 4294967295],
	float32: [-34028234663852886e22, 34028234663852886e22],
	float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
const BIGINT_FORMAT_RANGES = {
	int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
	uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick$1(schema, mask) {
	const currDef = schema._zod.def;
	const checks = currDef.checks;
	const hasChecks = checks && checks.length > 0;
	if (hasChecks) {
		throw new Error(".pick() cannot be used on object schemas containing refinements");
	}
	const def = mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = {};
			for (const key in mask) {
				if (!(key in currDef.shape)) {
					throw new Error(`Unrecognized key: "${key}"`);
				}
				if (!mask[key]) continue;
				newShape[key] = currDef.shape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	});
	return clone(schema, def);
}
function omit$1(schema, mask) {
	const currDef = schema._zod.def;
	const checks = currDef.checks;
	const hasChecks = checks && checks.length > 0;
	if (hasChecks) {
		throw new Error(".omit() cannot be used on object schemas containing refinements");
	}
	const def = mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = { ...schema._zod.def.shape };
			for (const key in mask) {
				if (!(key in currDef.shape)) {
					throw new Error(`Unrecognized key: "${key}"`);
				}
				if (!mask[key]) continue;
				delete newShape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	});
	return clone(schema, def);
}
function extend$1(schema, shape) {
	if (!isPlainObject$2(shape)) {
		throw new Error("Invalid input to extend: expected a plain object");
	}
	const checks = schema._zod.def.checks;
	const hasChecks = checks && checks.length > 0;
	if (hasChecks) {
		const existingShape = schema._zod.def.shape;
		for (const key in shape) {
			if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {
				throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
			}
		}
	}
	const def = mergeDefs(schema._zod.def, { get shape() {
		const _shape = {
			...schema._zod.def.shape,
			...shape
		};
		assignProp(this, "shape", _shape);
		return _shape;
	} });
	return clone(schema, def);
}
function safeExtend$1(schema, shape) {
	if (!isPlainObject$2(shape)) {
		throw new Error("Invalid input to safeExtend: expected a plain object");
	}
	const def = mergeDefs(schema._zod.def, { get shape() {
		const _shape = {
			...schema._zod.def.shape,
			...shape
		};
		assignProp(this, "shape", _shape);
		return _shape;
	} });
	return clone(schema, def);
}
function merge$1(a, b) {
	const def = mergeDefs(a._zod.def, {
		get shape() {
			const _shape = {
				...a._zod.def.shape,
				...b._zod.def.shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		get catchall() {
			return b._zod.def.catchall;
		},
		checks: []
	});
	return clone(a, def);
}
function partial$1(Class$3, schema, mask) {
	const currDef = schema._zod.def;
	const checks = currDef.checks;
	const hasChecks = checks && checks.length > 0;
	if (hasChecks) {
		throw new Error(".partial() cannot be used on object schemas containing refinements");
	}
	const def = mergeDefs(schema._zod.def, {
		get shape() {
			const oldShape = schema._zod.def.shape;
			const shape = { ...oldShape };
			if (mask) {
				for (const key in mask) {
					if (!(key in oldShape)) {
						throw new Error(`Unrecognized key: "${key}"`);
					}
					if (!mask[key]) continue;
					shape[key] = Class$3 ? new Class$3({
						type: "optional",
						innerType: oldShape[key]
					}) : oldShape[key];
				}
			} else {
				for (const key in oldShape) {
					shape[key] = Class$3 ? new Class$3({
						type: "optional",
						innerType: oldShape[key]
					}) : oldShape[key];
				}
			}
			assignProp(this, "shape", shape);
			return shape;
		},
		checks: []
	});
	return clone(schema, def);
}
function required$1(Class$3, schema, mask) {
	const def = mergeDefs(schema._zod.def, { get shape() {
		const oldShape = schema._zod.def.shape;
		const shape = { ...oldShape };
		if (mask) {
			for (const key in mask) {
				if (!(key in shape)) {
					throw new Error(`Unrecognized key: "${key}"`);
				}
				if (!mask[key]) continue;
				shape[key] = new Class$3({
					type: "nonoptional",
					innerType: oldShape[key]
				});
			}
		} else {
			for (const key in oldShape) {
				shape[key] = new Class$3({
					type: "nonoptional",
					innerType: oldShape[key]
				});
			}
		}
		assignProp(this, "shape", shape);
		return shape;
	} });
	return clone(schema, def);
}
function aborted(x, startIndex = 0) {
	if (x.aborted === true) return true;
	for (let i = startIndex; i < x.issues.length; i++) {
		if (x.issues[i]?.continue !== true) {
			return true;
		}
	}
	return false;
}
function prefixIssues(path$12, issues) {
	return issues.map((iss) => {
		var _a$1;
		(_a$1 = iss).path ?? (_a$1.path = []);
		iss.path.unshift(path$12);
		return iss;
	});
}
function unwrapMessage(message) {
	return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config$1) {
	const full = {
		...iss,
		path: iss.path ?? []
	};
	if (!iss.message) {
		const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? "Invalid input";
		full.message = message;
	}
	delete full.inst;
	delete full.continue;
	if (!ctx?.reportInput) {
		delete full.input;
	}
	return full;
}
function getSizableOrigin(input) {
	if (input instanceof Set) return "set";
	if (input instanceof Map) return "map";
	if (input instanceof File) return "file";
	return "unknown";
}
function getLengthableOrigin(input) {
	if (Array.isArray(input)) return "array";
	if (typeof input === "string") return "string";
	return "unknown";
}
function parsedType(data) {
	const t = typeof data;
	switch (t) {
		case "number": {
			return Number.isNaN(data) ? "nan" : "number";
		}
		case "object": {
			if (data === null) {
				return "null";
			}
			if (Array.isArray(data)) {
				return "array";
			}
			const obj = data;
			if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
				return obj.constructor.name;
			}
		}
	}
	return t;
}
function issue(...args) {
	const [iss, input, inst] = args;
	if (typeof iss === "string") {
		return {
			message: iss,
			code: "custom",
			input,
			inst
		};
	}
	return { ...iss };
}
function cleanEnum(obj) {
	return Object.entries(obj).filter(([k, _]) => {
		return Number.isNaN(Number.parseInt(k, 10));
	}).map((el) => el[1]);
}
function base64ToUint8Array(base64$3) {
	const binaryString = atob(base64$3);
	const bytes = new Uint8Array(binaryString.length);
	for (let i = 0; i < binaryString.length; i++) {
		bytes[i] = binaryString.charCodeAt(i);
	}
	return bytes;
}
function uint8ArrayToBase64(bytes) {
	let binaryString = "";
	for (let i = 0; i < bytes.length; i++) {
		binaryString += String.fromCharCode(bytes[i]);
	}
	return btoa(binaryString);
}
function base64urlToUint8Array(base64url$3) {
	const base64$3 = base64url$3.replace(/-/g, "+").replace(/_/g, "/");
	const padding = "=".repeat((4 - base64$3.length % 4) % 4);
	return base64ToUint8Array(base64$3 + padding);
}
function uint8ArrayToBase64url(bytes) {
	return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex$3) {
	const cleanHex = hex$3.replace(/^0x/, "");
	if (cleanHex.length % 2 !== 0) {
		throw new Error("Invalid hex string length");
	}
	const bytes = new Uint8Array(cleanHex.length / 2);
	for (let i = 0; i < cleanHex.length; i += 2) {
		bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
	}
	return bytes;
}
function uint8ArrayToHex(bytes) {
	return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class$2 = class {
	constructor(..._args) {}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/errors.js
const initializer$1 = (inst, def) => {
	inst.name = "$ZodError";
	Object.defineProperty(inst, "_zod", {
		value: inst._zod,
		enumerable: false
	});
	Object.defineProperty(inst, "issues", {
		value: def,
		enumerable: false
	});
	inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
	Object.defineProperty(inst, "toString", {
		value: () => inst.message,
		enumerable: false
	});
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError$1(error$47, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = {};
	const formErrors = [];
	for (const sub of error$47.issues) {
		if (sub.path.length > 0) {
			fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
			fieldErrors[sub.path[0]].push(mapper(sub));
		} else {
			formErrors.push(mapper(sub));
		}
	}
	return {
		formErrors,
		fieldErrors
	};
}
function formatError(error$47, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = { _errors: [] };
	const processError = (error$48) => {
		for (const issue$1 of error$48.issues) {
			if (issue$1.code === "invalid_union" && issue$1.errors.length) {
				issue$1.errors.map((issues) => processError({ issues }));
			} else if (issue$1.code === "invalid_key") {
				processError({ issues: issue$1.issues });
			} else if (issue$1.code === "invalid_element") {
				processError({ issues: issue$1.issues });
			} else if (issue$1.path.length === 0) {
				fieldErrors._errors.push(mapper(issue$1));
			} else {
				let curr = fieldErrors;
				let i = 0;
				while (i < issue$1.path.length) {
					const el = issue$1.path[i];
					const terminal = i === issue$1.path.length - 1;
					if (!terminal) {
						curr[el] = curr[el] || { _errors: [] };
					} else {
						curr[el] = curr[el] || { _errors: [] };
						curr[el]._errors.push(mapper(issue$1));
					}
					curr = curr[el];
					i++;
				}
			}
		}
	};
	processError(error$47);
	return fieldErrors;
}
function treeifyError(error$47, mapper = (issue$1) => issue$1.message) {
	const result = { errors: [] };
	const processError = (error$48, path$12 = []) => {
		var _a$1, _b;
		for (const issue$1 of error$48.issues) {
			if (issue$1.code === "invalid_union" && issue$1.errors.length) {
				issue$1.errors.map((issues) => processError({ issues }, issue$1.path));
			} else if (issue$1.code === "invalid_key") {
				processError({ issues: issue$1.issues }, issue$1.path);
			} else if (issue$1.code === "invalid_element") {
				processError({ issues: issue$1.issues }, issue$1.path);
			} else {
				const fullpath = [...path$12, ...issue$1.path];
				if (fullpath.length === 0) {
					result.errors.push(mapper(issue$1));
					continue;
				}
				let curr = result;
				let i = 0;
				while (i < fullpath.length) {
					const el = fullpath[i];
					const terminal = i === fullpath.length - 1;
					if (typeof el === "string") {
						curr.properties ?? (curr.properties = {});
						(_a$1 = curr.properties)[el] ?? (_a$1[el] = { errors: [] });
						curr = curr.properties[el];
					} else {
						curr.items ?? (curr.items = []);
						(_b = curr.items)[el] ?? (_b[el] = { errors: [] });
						curr = curr.items[el];
					}
					if (terminal) {
						curr.errors.push(mapper(issue$1));
					}
					i++;
				}
			}
		}
	};
	processError(error$47);
	return result;
}
/** Format a ZodError as a human-readable string in the following form.
*
* From
*
* ```ts
* ZodError {
*   issues: [
*     {
*       expected: 'string',
*       code: 'invalid_type',
*       path: [ 'username' ],
*       message: 'Invalid input: expected string'
*     },
*     {
*       expected: 'number',
*       code: 'invalid_type',
*       path: [ 'favoriteNumbers', 1 ],
*       message: 'Invalid input: expected number'
*     }
*   ];
* }
* ```
*
* to
*
* ```
* username
*    Expected number, received string at "username
* favoriteNumbers[0]
*    Invalid input: expected number
* ```
*/
function toDotPath(_path) {
	const segs = [];
	const path$12 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
	for (const seg of path$12) {
		if (typeof seg === "number") segs.push(`[${seg}]`);
		else if (typeof seg === "symbol") segs.push(`[${JSON.stringify(String(seg))}]`);
		else if (/[^\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);
		else {
			if (segs.length) segs.push(".");
			segs.push(seg);
		}
	}
	return segs.join("");
}
function prettifyError(error$47) {
	const lines = [];
	const issues = [...error$47.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
	for (const issue$1 of issues) {
		lines.push(` ${issue$1.message}`);
		if (issue$1.path?.length) lines.push(`   at ${toDotPath(issue$1.path)}`);
	}
	return lines.join("\n");
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/parse.js
const _parse = (_Err) => (schema, value, _ctx, _params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) {
		throw new $ZodAsyncError();
	}
	if (result.issues.length) {
		const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, _params?.callee);
		throw e;
	}
	return result.value;
};
const parse$3 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	if (result.issues.length) {
		const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, params?.callee);
		throw e;
	}
	return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? {
		..._ctx,
		async: false
	} : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) {
		throw new $ZodAsyncError();
	}
	return result.issues.length ? {
		success: false,
		error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParse$2 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	return result.issues.length ? {
		success: false,
		error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParseAsync$2 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parse(_Err)(schema, value, ctx);
};
const encode$1 = /* @__PURE__ */ _encode($ZodRealError);
const _decode = (_Err) => (schema, value, _ctx) => {
	return _parse(_Err)(schema, value, _ctx);
};
const decode$1 = /* @__PURE__ */ _decode($ZodRealError);
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parseAsync(_Err)(schema, value, ctx);
};
const encodeAsync$1 = /* @__PURE__ */ _encodeAsync($ZodRealError);
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _parseAsync(_Err)(schema, value, _ctx);
};
const decodeAsync$1 = /* @__PURE__ */ _decodeAsync($ZodRealError);
const _safeEncode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParse(_Err)(schema, value, ctx);
};
const safeEncode$1 = /* @__PURE__ */ _safeEncode($ZodRealError);
const _safeDecode = (_Err) => (schema, value, _ctx) => {
	return _safeParse(_Err)(schema, value, _ctx);
};
const safeDecode$1 = /* @__PURE__ */ _safeDecode($ZodRealError);
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParseAsync(_Err)(schema, value, ctx);
};
const safeEncodeAsync$1 = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _safeParseAsync(_Err)(schema, value, _ctx);
};
const safeDecodeAsync$1 = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/regexes.js
var regexes_exports = /* @__PURE__ */ __exportAll({
	base64: () => base64$2,
	base64url: () => base64url$2,
	bigint: () => bigint$4,
	boolean: () => boolean$4,
	browserEmail: () => browserEmail,
	cidrv4: () => cidrv4$2,
	cidrv6: () => cidrv6$2,
	cuid: () => cuid$2,
	cuid2: () => cuid2$2,
	date: () => date$6,
	datetime: () => datetime$2,
	domain: () => domain,
	duration: () => duration$2,
	e164: () => e164$2,
	email: () => email$2,
	emoji: () => emoji$2,
	extendedDuration: () => extendedDuration,
	guid: () => guid$2,
	hex: () => hex$2,
	hostname: () => hostname$2,
	html5Email: () => html5Email,
	idnEmail: () => idnEmail,
	integer: () => integer,
	ipv4: () => ipv4$2,
	ipv6: () => ipv6$2,
	ksuid: () => ksuid$2,
	lowercase: () => lowercase,
	mac: () => mac$2,
	md5_base64: () => md5_base64,
	md5_base64url: () => md5_base64url,
	md5_hex: () => md5_hex,
	nanoid: () => nanoid$2,
	null: () => _null$3,
	number: () => number$4,
	rfc5322Email: () => rfc5322Email,
	sha1_base64: () => sha1_base64,
	sha1_base64url: () => sha1_base64url,
	sha1_hex: () => sha1_hex,
	sha256_base64: () => sha256_base64,
	sha256_base64url: () => sha256_base64url,
	sha256_hex: () => sha256_hex,
	sha384_base64: () => sha384_base64,
	sha384_base64url: () => sha384_base64url,
	sha384_hex: () => sha384_hex,
	sha512_base64: () => sha512_base64,
	sha512_base64url: () => sha512_base64url,
	sha512_hex: () => sha512_hex,
	string: () => string$4,
	time: () => time$2,
	ulid: () => ulid$2,
	undefined: () => _undefined$3,
	unicodeEmail: () => unicodeEmail,
	uppercase: () => uppercase,
	uuid: () => uuid$2,
	uuid4: () => uuid4,
	uuid6: () => uuid6,
	uuid7: () => uuid7,
	xid: () => xid$2
});
const cuid$2 = /^[cC][^\s-]{8,}$/;
const cuid2$2 = /^[0-9a-z]+$/;
const ulid$2 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid$2 = /^[0-9a-vA-V]{20}$/;
const ksuid$2 = /^[A-Za-z0-9]{27}$/;
const nanoid$2 = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration$2 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */
const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid$2 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
*
* @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid$2 = (version$1) => {
	if (!version$1) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
	return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version$1}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const uuid4 = /* @__PURE__ */ uuid$2(4);
const uuid6 = /* @__PURE__ */ uuid$2(6);
const uuid7 = /* @__PURE__ */ uuid$2(7);
/** Practical email validation */
const email$2 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */
const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/** The classic emailregex.com regex for RFC 5322-compliant emails */
const rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */
const unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
const idnEmail = unicodeEmail;
const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji$2() {
	return new RegExp(_emoji$1, "u");
}
const ipv4$2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6$2 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const mac$2 = (delimiter) => {
	const escapedDelim = escapeRegex(delimiter ?? ":");
	return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
const cidrv4$2 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6$2 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64$2 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url$2 = /^[A-Za-z0-9_-]*$/;
const hostname$2 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
const e164$2 = /^\+[1-9]\d{6,14}$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$6 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
	const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
	const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
	return regex;
}
function time$2(args) {
	return new RegExp(`^${timeSource(args)}$`);
}
function datetime$2(args) {
	const time$3 = timeSource({ precision: args.precision });
	const opts = ["Z"];
	if (args.local) opts.push("");
	if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
	const timeRegex$1 = `${time$3}(?:${opts.join("|")})`;
	return new RegExp(`^${dateSource}T(?:${timeRegex$1})$`);
}
const string$4 = (params) => {
	const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	return new RegExp(`^${regex}$`);
};
const bigint$4 = /^-?\d+n?$/;
const integer = /^-?\d+$/;
const number$4 = /^-?\d+(?:\.\d+)?$/;
const boolean$4 = /^(?:true|false)$/i;
const _null$3 = /^null$/i;
const _undefined$3 = /^undefined$/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const hex$2 = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
	return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
	return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
const md5_hex = /^[0-9a-fA-F]{32}$/;
const md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
const md5_base64url = /* @__PURE__ */ fixedBase64url(22);
const sha1_hex = /^[0-9a-fA-F]{40}$/;
const sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
const sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
const sha256_hex = /^[0-9a-fA-F]{64}$/;
const sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
const sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
const sha384_hex = /^[0-9a-fA-F]{96}$/;
const sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
const sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
const sha512_hex = /^[0-9a-fA-F]{128}$/;
const sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
const sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/checks.js
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
	var _a$1;
	inst._zod ?? (inst._zod = {});
	inst._zod.def = def;
	(_a$1 = inst._zod).onattach ?? (_a$1.onattach = []);
});
const numericOriginMap = {
	number: "number",
	bigint: "bigint",
	object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
		if (def.value < curr) {
			if (def.inclusive) bag.maximum = def.value;
			else bag.exclusiveMaximum = def.value;
		}
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
			return;
		}
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
		if (def.value > curr) {
			if (def.inclusive) bag.minimum = def.value;
			else bag.exclusiveMinimum = def.value;
		}
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
			return;
		}
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		var _a$1;
		(_a$1 = inst$1._zod.bag).multipleOf ?? (_a$1.multipleOf = def.value);
	});
	inst._zod.check = (payload) => {
		if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
		const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder$1(payload.value, def.value) === 0;
		if (isMultiple) return;
		payload.issues.push({
			origin: typeof payload.value,
			code: "not_multiple_of",
			divisor: def.value,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
	$ZodCheck.init(inst, def);
	def.format = def.format || "float64";
	const isInt = def.format?.includes("int");
	const origin = isInt ? "int" : "number";
	const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
		if (isInt) bag.pattern = integer;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (isInt) {
			if (!Number.isInteger(input)) {
				payload.issues.push({
					expected: origin,
					format: def.format,
					code: "invalid_type",
					continue: false,
					input,
					inst
				});
				return;
			}
			if (!Number.isSafeInteger(input)) {
				if (input > 0) {
					payload.issues.push({
						input,
						code: "too_big",
						maximum: Number.MAX_SAFE_INTEGER,
						note: "Integers must be within the safe integer range.",
						inst,
						origin,
						inclusive: true,
						continue: !def.abort
					});
				} else {
					payload.issues.push({
						input,
						code: "too_small",
						minimum: Number.MIN_SAFE_INTEGER,
						note: "Integers must be within the safe integer range.",
						inst,
						origin,
						inclusive: true,
						continue: !def.abort
					});
				}
				return;
			}
		}
		if (input < minimum) {
			payload.issues.push({
				origin: "number",
				input,
				code: "too_small",
				minimum,
				inclusive: true,
				inst,
				continue: !def.abort
			});
		}
		if (input > maximum) {
			payload.issues.push({
				origin: "number",
				input,
				code: "too_big",
				maximum,
				inclusive: true,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
	$ZodCheck.init(inst, def);
	const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input < minimum) {
			payload.issues.push({
				origin: "bigint",
				input,
				code: "too_small",
				minimum,
				inclusive: true,
				inst,
				continue: !def.abort
			});
		}
		if (input > maximum) {
			payload.issues.push({
				origin: "bigint",
				input,
				code: "too_big",
				maximum,
				inclusive: true,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$2(val) && val.size !== undefined;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const size = input.size;
		if (size <= def.maximum) return;
		payload.issues.push({
			origin: getSizableOrigin(input),
			code: "too_big",
			maximum: def.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$2(val) && val.size !== undefined;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const size = input.size;
		if (size >= def.minimum) return;
		payload.issues.push({
			origin: getSizableOrigin(input),
			code: "too_small",
			minimum: def.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$2(val) && val.size !== undefined;
	});
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.minimum = def.size;
		bag.maximum = def.size;
		bag.size = def.size;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const size = input.size;
		if (size === def.size) return;
		const tooBig = size > def.size;
		payload.issues.push({
			origin: getSizableOrigin(input),
			...tooBig ? {
				code: "too_big",
				maximum: def.size
			} : {
				code: "too_small",
				minimum: def.size
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$2(val) && val.length !== undefined;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length <= def.maximum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: def.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$2(val) && val.length !== undefined;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length >= def.minimum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: def.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish$2(val) && val.length !== undefined;
	});
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.minimum = def.length;
		bag.maximum = def.length;
		bag.length = def.length;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length === def.length) return;
		const origin = getLengthableOrigin(input);
		const tooBig = length > def.length;
		payload.issues.push({
			origin,
			...tooBig ? {
				code: "too_big",
				maximum: def.length
			} : {
				code: "too_small",
				minimum: def.length
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
	var _a$1, _b;
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		if (def.pattern) {
			bag.patterns ?? (bag.patterns = new Set());
			bag.patterns.add(def.pattern);
		}
	});
	if (def.pattern) (_a$1 = inst._zod).check ?? (_a$1.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: def.format,
			input: payload.value,
			...def.pattern ? { pattern: def.pattern.toString() } : {},
			inst,
			continue: !def.abort
		});
	});
	else (_b = inst._zod).check ?? (_b.check = () => {});
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "regex",
			input: payload.value,
			pattern: def.pattern.toString(),
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
	def.pattern ?? (def.pattern = lowercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
	def.pattern ?? (def.pattern = uppercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
	$ZodCheck.init(inst, def);
	const escapedRegex = escapeRegex(def.includes);
	const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
	def.pattern = pattern;
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.includes(def.includes, def.position)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "includes",
			includes: def.includes,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.startsWith(def.prefix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "starts_with",
			prefix: def.prefix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.endsWith(def.suffix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "ends_with",
			suffix: def.suffix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
function handleCheckPropertyResult(result, payload, property) {
	if (result.issues.length) {
		payload.issues.push(...prefixIssues(property, result.issues));
	}
}
const $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.check = (payload) => {
		const result = def.schema._zod.run({
			value: payload.value[def.property],
			issues: []
		}, {});
		if (result instanceof Promise) {
			return result.then((result$1) => handleCheckPropertyResult(result$1, payload, def.property));
		}
		handleCheckPropertyResult(result, payload, def.property);
		return;
	};
});
const $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
	$ZodCheck.init(inst, def);
	const mimeSet = new Set(def.mime);
	inst._zod.onattach.push((inst$1) => {
		inst$1._zod.bag.mime = def.mime;
	});
	inst._zod.check = (payload) => {
		if (mimeSet.has(payload.value.type)) return;
		payload.issues.push({
			code: "invalid_value",
			values: def.mime,
			input: payload.value.type,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.check = (payload) => {
		payload.value = def.tx(payload.value);
	};
});

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/doc.js
var Doc = class {
	constructor(args = []) {
		this.content = [];
		this.indent = 0;
		if (this) this.args = args;
	}
	indented(fn) {
		this.indent += 1;
		fn(this);
		this.indent -= 1;
	}
	write(arg) {
		if (typeof arg === "function") {
			arg(this, { execution: "sync" });
			arg(this, { execution: "async" });
			return;
		}
		const content = arg;
		const lines = content.split("\n").filter((x) => x);
		const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
		const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
		for (const line of dedented) {
			this.content.push(line);
		}
	}
	compile() {
		const F = Function;
		const args = this?.args;
		const content = this?.content ?? [``];
		const lines = [...content.map((x) => `  ${x}`)];
		return new F(...args, lines.join("\n"));
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/versions.js
const version = {
	major: 4,
	minor: 3,
	patch: 5
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/schemas.js
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
	var _a$1;
	inst ?? (inst = {});
	inst._zod.def = def;
	inst._zod.bag = inst._zod.bag || {};
	inst._zod.version = version;
	const checks = [...inst._zod.def.checks ?? []];
	if (inst._zod.traits.has("$ZodCheck")) {
		checks.unshift(inst);
	}
	for (const ch of checks) {
		for (const fn of ch._zod.onattach) {
			fn(inst);
		}
	}
	if (checks.length === 0) {
		(_a$1 = inst._zod).deferred ?? (_a$1.deferred = []);
		inst._zod.deferred?.push(() => {
			inst._zod.run = inst._zod.parse;
		});
	} else {
		const runChecks = (payload, checks$1, ctx) => {
			let isAborted$1 = aborted(payload);
			let asyncResult;
			for (const ch of checks$1) {
				if (ch._zod.def.when) {
					const shouldRun = ch._zod.def.when(payload);
					if (!shouldRun) continue;
				} else if (isAborted$1) {
					continue;
				}
				const currLen = payload.issues.length;
				const _ = ch._zod.check(payload);
				if (_ instanceof Promise && ctx?.async === false) {
					throw new $ZodAsyncError();
				}
				if (asyncResult || _ instanceof Promise) {
					asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
						await _;
						const nextLen = payload.issues.length;
						if (nextLen === currLen) return;
						if (!isAborted$1) isAborted$1 = aborted(payload, currLen);
					});
				} else {
					const nextLen = payload.issues.length;
					if (nextLen === currLen) continue;
					if (!isAborted$1) isAborted$1 = aborted(payload, currLen);
				}
			}
			if (asyncResult) {
				return asyncResult.then(() => {
					return payload;
				});
			}
			return payload;
		};
		const handleCanaryResult = (canary, payload, ctx) => {
			if (aborted(canary)) {
				canary.aborted = true;
				return canary;
			}
			const checkResult = runChecks(payload, checks, ctx);
			if (checkResult instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return checkResult.then((checkResult$1) => inst._zod.parse(checkResult$1, ctx));
			}
			return inst._zod.parse(checkResult, ctx);
		};
		inst._zod.run = (payload, ctx) => {
			if (ctx.skipChecks) {
				return inst._zod.parse(payload, ctx);
			}
			if (ctx.direction === "backward") {
				const canary = inst._zod.parse({
					value: payload.value,
					issues: []
				}, {
					...ctx,
					skipChecks: true
				});
				if (canary instanceof Promise) {
					return canary.then((canary$1) => {
						return handleCanaryResult(canary$1, payload, ctx);
					});
				}
				return handleCanaryResult(canary, payload, ctx);
			}
			const result = inst._zod.parse(payload, ctx);
			if (result instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return result.then((result$1) => runChecks(result$1, checks, ctx));
			}
			return runChecks(result, checks, ctx);
		};
	}
	defineLazy(inst, "~standard", () => ({
		validate: (value) => {
			try {
				const r = safeParse$2(inst, value);
				return r.success ? { value: r.data } : { issues: r.error?.issues };
			} catch (_) {
				return safeParseAsync$2(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
			}
		},
		vendor: "zod",
		version: 1
	}));
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$4(inst._zod.bag);
	inst._zod.parse = (payload, _) => {
		if (def.coerce) try {
			payload.value = String(payload.value);
		} catch (_$1) {}
		if (typeof payload.value === "string") return payload;
		payload.issues.push({
			expected: "string",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	$ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
	def.pattern ?? (def.pattern = guid$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
	if (def.version) {
		const versionMap = {
			v1: 1,
			v2: 2,
			v3: 3,
			v4: 4,
			v5: 5,
			v6: 6,
			v7: 7,
			v8: 8
		};
		const v = versionMap[def.version];
		if (v === undefined) throw new Error(`Invalid UUID version: "${def.version}"`);
		def.pattern ?? (def.pattern = uuid$2(v));
	} else def.pattern ?? (def.pattern = uuid$2());
	$ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
	def.pattern ?? (def.pattern = email$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		try {
			const trimmed = payload.value.trim();
			const url$2 = new URL(trimmed);
			if (def.hostname) {
				def.hostname.lastIndex = 0;
				if (!def.hostname.test(url$2.hostname)) {
					payload.issues.push({
						code: "invalid_format",
						format: "url",
						note: "Invalid hostname",
						pattern: def.hostname.source,
						input: payload.value,
						inst,
						continue: !def.abort
					});
				}
			}
			if (def.protocol) {
				def.protocol.lastIndex = 0;
				if (!def.protocol.test(url$2.protocol.endsWith(":") ? url$2.protocol.slice(0, -1) : url$2.protocol)) {
					payload.issues.push({
						code: "invalid_format",
						format: "url",
						note: "Invalid protocol",
						pattern: def.protocol.source,
						input: payload.value,
						inst,
						continue: !def.abort
					});
				}
			}
			if (def.normalize) {
				payload.value = url$2.href;
			} else {
				payload.value = trimmed;
			}
			return;
		} catch (_) {
			payload.issues.push({
				code: "invalid_format",
				format: "url",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
	def.pattern ?? (def.pattern = emoji$2());
	$ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
	def.pattern ?? (def.pattern = nanoid$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
	def.pattern ?? (def.pattern = cuid$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
	def.pattern ?? (def.pattern = cuid2$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
	def.pattern ?? (def.pattern = ulid$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
	def.pattern ?? (def.pattern = xid$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
	def.pattern ?? (def.pattern = ksuid$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
	def.pattern ?? (def.pattern = datetime$2(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
	def.pattern ?? (def.pattern = date$6);
	$ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
	def.pattern ?? (def.pattern = time$2(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
	def.pattern ?? (def.pattern = duration$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
	def.pattern ?? (def.pattern = ipv4$2);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
	def.pattern ?? (def.pattern = ipv6$2);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv6`;
	inst._zod.check = (payload) => {
		try {
			new URL(`http://[${payload.value}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "ipv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
	def.pattern ?? (def.pattern = mac$2(def.delimiter));
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `mac`;
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv4$2);
	$ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv6$2);
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		const parts = payload.value.split("/");
		try {
			if (parts.length !== 2) throw new Error();
			const [address, prefix] = parts;
			if (!prefix) throw new Error();
			const prefixNum = Number(prefix);
			if (`${prefixNum}` !== prefix) throw new Error();
			if (prefixNum < 0 || prefixNum > 128) throw new Error();
			new URL(`http://[${address}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "cidrv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
function isValidBase64(data) {
	if (data === "") return true;
	if (data.length % 4 !== 0) return false;
	try {
		atob(data);
		return true;
	} catch {
		return false;
	}
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
	def.pattern ?? (def.pattern = base64$2);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64";
	inst._zod.check = (payload) => {
		if (isValidBase64(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
function isValidBase64URL(data) {
	if (!base64url$2.test(data)) return false;
	const base64$3 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
	const padded = base64$3.padEnd(Math.ceil(base64$3.length / 4) * 4, "=");
	return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
	def.pattern ?? (def.pattern = base64url$2);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64url";
	inst._zod.check = (payload) => {
		if (isValidBase64URL(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64url",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
	def.pattern ?? (def.pattern = e164$2);
	$ZodStringFormat.init(inst, def);
});
function isValidJWT$1(token, algorithm = null) {
	try {
		const tokensParts = token.split(".");
		if (tokensParts.length !== 3) return false;
		const [header] = tokensParts;
		if (!header) return false;
		const parsedHeader = JSON.parse(atob(header));
		if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
		if (!parsedHeader.alg) return false;
		if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
		return true;
	} catch {
		return false;
	}
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		if (isValidJWT$1(payload.value, def.alg)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "jwt",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		if (def.fn(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: def.format,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = inst._zod.bag.pattern ?? number$4;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Number(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
			return payload;
		}
		const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
		payload.issues.push({
			expected: "number",
			code: "invalid_type",
			input,
			inst,
			...received ? { received } : {}
		});
		return payload;
	};
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
	$ZodCheckNumberFormat.init(inst, def);
	$ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = boolean$4;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Boolean(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "boolean") return payload;
		payload.issues.push({
			expected: "boolean",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = bigint$4;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = BigInt(payload.value);
		} catch (_) {}
		if (typeof payload.value === "bigint") return payload;
		payload.issues.push({
			expected: "bigint",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
	$ZodCheckBigIntFormat.init(inst, def);
	$ZodBigInt.init(inst, def);
});
const $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (typeof input === "symbol") return payload;
		payload.issues.push({
			expected: "symbol",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = _undefined$3;
	inst._zod.values = new Set([undefined]);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (typeof input === "undefined") return payload;
		payload.issues.push({
			expected: "undefined",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = _null$3;
	inst._zod.values = new Set([null]);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (input === null) return payload;
		payload.issues.push({
			expected: "null",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		payload.issues.push({
			expected: "never",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (typeof input === "undefined") return payload;
		payload.issues.push({
			expected: "void",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) {
			try {
				payload.value = new Date(payload.value);
			} catch (_err) {}
		}
		const input = payload.value;
		const isDate = input instanceof Date;
		const isValidDate = isDate && !Number.isNaN(input.getTime());
		if (isValidDate) return payload;
		payload.issues.push({
			expected: "date",
			code: "invalid_type",
			input,
			...isDate ? { received: "Invalid Date" } : {},
			inst
		});
		return payload;
	};
});
function handleArrayResult(result, final, index) {
	if (result.issues.length) {
		final.issues.push(...prefixIssues(index, result.issues));
	}
	final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				expected: "array",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = Array(input.length);
		const proms = [];
		for (let i = 0; i < input.length; i++) {
			const item = input[i];
			const result = def.element._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i)));
			} else {
				handleArrayResult(result, payload, i);
			}
		}
		if (proms.length) {
			return Promise.all(proms).then(() => payload);
		}
		return payload;
	};
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
	if (result.issues.length) {
		if (isOptionalOut && !(key in input)) {
			return;
		}
		final.issues.push(...prefixIssues(key, result.issues));
	}
	if (result.value === undefined) {
		if (key in input) {
			final.value[key] = undefined;
		}
	} else {
		final.value[key] = result.value;
	}
}
function normalizeDef(def) {
	const keys = Object.keys(def.shape);
	for (const k of keys) {
		if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
			throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
		}
	}
	const okeys = optionalKeys(def.shape);
	return {
		...def,
		keys,
		keySet: new Set(keys),
		numKeys: keys.length,
		optionalKeys: new Set(okeys)
	};
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
	const unrecognized = [];
	const keySet = def.keySet;
	const _catchall = def.catchall._zod;
	const t = _catchall.def.type;
	const isOptionalOut = _catchall.optout === "optional";
	for (const key in input) {
		if (keySet.has(key)) continue;
		if (t === "never") {
			unrecognized.push(key);
			continue;
		}
		const r = _catchall.run({
			value: input[key],
			issues: []
		}, ctx);
		if (r instanceof Promise) {
			proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input, isOptionalOut)));
		} else {
			handlePropertyResult(r, payload, key, input, isOptionalOut);
		}
	}
	if (unrecognized.length) {
		payload.issues.push({
			code: "unrecognized_keys",
			keys: unrecognized,
			input,
			inst
		});
	}
	if (!proms.length) return payload;
	return Promise.all(proms).then(() => {
		return payload;
	});
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
	$ZodType.init(inst, def);
	const desc = Object.getOwnPropertyDescriptor(def, "shape");
	if (!desc?.get) {
		const sh = def.shape;
		Object.defineProperty(def, "shape", { get: () => {
			const newSh = { ...sh };
			Object.defineProperty(def, "shape", { value: newSh });
			return newSh;
		} });
	}
	const _normalized = cached(() => normalizeDef(def));
	defineLazy(inst._zod, "propValues", () => {
		const shape = def.shape;
		const propValues = {};
		for (const key in shape) {
			const field = shape[key]._zod;
			if (field.values) {
				propValues[key] ?? (propValues[key] = new Set());
				for (const v of field.values) propValues[key].add(v);
			}
		}
		return propValues;
	});
	const isObject$1 = isObject;
	const catchall$1 = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$1(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = {};
		const proms = [];
		const shape = value.shape;
		for (const key of value.keys) {
			const el = shape[key];
			const isOptionalOut = el._zod.optout === "optional";
			const r = el._zod.run({
				value: input[key],
				issues: []
			}, ctx);
			if (r instanceof Promise) {
				proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input, isOptionalOut)));
			} else {
				handlePropertyResult(r, payload, key, input, isOptionalOut);
			}
		}
		if (!catchall$1) {
			return proms.length ? Promise.all(proms).then(() => payload) : payload;
		}
		return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
	};
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
	$ZodObject.init(inst, def);
	const superParse = inst._zod.parse;
	const _normalized = cached(() => normalizeDef(def));
	const generateFastpass = (shape) => {
		const doc = new Doc([
			"shape",
			"payload",
			"ctx"
		]);
		const normalized = _normalized.value;
		const parseStr = (key) => {
			const k = esc(key);
			return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
		};
		doc.write(`const input = payload.value;`);
		const ids = Object.create(null);
		let counter = 0;
		for (const key of normalized.keys) {
			ids[key] = `key_${counter++}`;
		}
		doc.write(`const newResult = {};`);
		for (const key of normalized.keys) {
			const id = ids[key];
			const k = esc(key);
			const schema = shape[key];
			const isOptionalOut = schema?._zod?.optout === "optional";
			doc.write(`const ${id} = ${parseStr(key)};`);
			if (isOptionalOut) {
				doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
			} else {
				doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
			}
		}
		doc.write(`payload.value = newResult;`);
		doc.write(`return payload;`);
		const fn = doc.compile();
		return (payload, ctx) => fn(shape, payload, ctx);
	};
	let fastpass;
	const isObject$1 = isObject;
	const jit = !globalConfig.jitless;
	const allowsEval$1 = allowsEval;
	const fastEnabled = jit && allowsEval$1.value;
	const catchall$1 = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$1(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
			if (!fastpass) fastpass = generateFastpass(def.shape);
			payload = fastpass(payload, ctx);
			if (!catchall$1) return payload;
			return handleCatchall([], input, payload, ctx, value, inst);
		}
		return superParse(payload, ctx);
	};
});
function handleUnionResults(results, final, inst, ctx) {
	for (const result of results) {
		if (result.issues.length === 0) {
			final.value = result.value;
			return final;
		}
	}
	const nonaborted = results.filter((r) => !aborted(r));
	if (nonaborted.length === 1) {
		final.value = nonaborted[0].value;
		return nonaborted[0];
	}
	final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	});
	return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
	defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
	defineLazy(inst._zod, "values", () => {
		if (def.options.every((o) => o._zod.values)) {
			return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
		}
		return undefined;
	});
	defineLazy(inst._zod, "pattern", () => {
		if (def.options.every((o) => o._zod.pattern)) {
			const patterns = def.options.map((o) => o._zod.pattern);
			return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
		}
		return undefined;
	});
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) {
			return first(payload, ctx);
		}
		let async = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else {
				if (result.issues.length === 0) return result;
				results.push(result);
			}
		}
		if (!async) return handleUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleUnionResults(results$1, payload, inst, ctx);
		});
	};
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
	const successes = results.filter((r) => r.issues.length === 0);
	if (successes.length === 1) {
		final.value = successes[0].value;
		return final;
	}
	if (successes.length === 0) {
		final.issues.push({
			code: "invalid_union",
			input: final.value,
			inst,
			errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
		});
	} else {
		final.issues.push({
			code: "invalid_union",
			input: final.value,
			inst,
			errors: [],
			inclusive: false
		});
	}
	return final;
}
const $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
	$ZodUnion.init(inst, def);
	def.inclusive = false;
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) {
			return first(payload, ctx);
		}
		let async = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else {
				results.push(result);
			}
		}
		if (!async) return handleExclusiveUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleExclusiveUnionResults(results$1, payload, inst, ctx);
		});
	};
});
const $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
	def.inclusive = false;
	$ZodUnion.init(inst, def);
	const _super = inst._zod.parse;
	defineLazy(inst._zod, "propValues", () => {
		const propValues = {};
		for (const option of def.options) {
			const pv = option._zod.propValues;
			if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
			for (const [k, v] of Object.entries(pv)) {
				if (!propValues[k]) propValues[k] = new Set();
				for (const val of v) {
					propValues[k].add(val);
				}
			}
		}
		return propValues;
	});
	const disc = cached(() => {
		const opts = def.options;
		const map$2 = new Map();
		for (const o of opts) {
			const values = o._zod.propValues?.[def.discriminator];
			if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
			for (const v of values) {
				if (map$2.has(v)) {
					throw new Error(`Duplicate discriminator value "${String(v)}"`);
				}
				map$2.set(v, o);
			}
		}
		return map$2;
	});
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!isObject(input)) {
			payload.issues.push({
				code: "invalid_type",
				expected: "object",
				input,
				inst
			});
			return payload;
		}
		const opt = disc.value.get(input?.[def.discriminator]);
		if (opt) {
			return opt._zod.run(payload, ctx);
		}
		if (def.unionFallback) {
			return _super(payload, ctx);
		}
		payload.issues.push({
			code: "invalid_union",
			errors: [],
			note: "No matching discriminator",
			discriminator: def.discriminator,
			input,
			path: [def.discriminator],
			inst
		});
		return payload;
	};
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		const left = def.left._zod.run({
			value: input,
			issues: []
		}, ctx);
		const right = def.right._zod.run({
			value: input,
			issues: []
		}, ctx);
		const async = left instanceof Promise || right instanceof Promise;
		if (async) {
			return Promise.all([left, right]).then(([left$1, right$1]) => {
				return handleIntersectionResults(payload, left$1, right$1);
			});
		}
		return handleIntersectionResults(payload, left, right);
	};
});
function mergeValues$1(a, b) {
	if (a === b) {
		return {
			valid: true,
			data: a
		};
	}
	if (a instanceof Date && b instanceof Date && +a === +b) {
		return {
			valid: true,
			data: a
		};
	}
	if (isPlainObject$2(a) && isPlainObject$2(b)) {
		const bKeys = Object.keys(b);
		const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues$1(a[key], b[key]);
			if (!sharedValue.valid) {
				return {
					valid: false,
					mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
				};
			}
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return {
				valid: false,
				mergeErrorPath: []
			};
		}
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues$1(itemA, itemB);
			if (!sharedValue.valid) {
				return {
					valid: false,
					mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
				};
			}
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	}
	return {
		valid: false,
		mergeErrorPath: []
	};
}
function handleIntersectionResults(result, left, right) {
	const unrecKeys = new Map();
	let unrecIssue;
	for (const iss of left.issues) {
		if (iss.code === "unrecognized_keys") {
			unrecIssue ?? (unrecIssue = iss);
			for (const k of iss.keys) {
				if (!unrecKeys.has(k)) unrecKeys.set(k, {});
				unrecKeys.get(k).l = true;
			}
		} else {
			result.issues.push(iss);
		}
	}
	for (const iss of right.issues) {
		if (iss.code === "unrecognized_keys") {
			for (const k of iss.keys) {
				if (!unrecKeys.has(k)) unrecKeys.set(k, {});
				unrecKeys.get(k).r = true;
			}
		} else {
			result.issues.push(iss);
		}
	}
	const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
	if (bothKeys.length && unrecIssue) {
		result.issues.push({
			...unrecIssue,
			keys: bothKeys
		});
	}
	if (aborted(result)) return result;
	const merged = mergeValues$1(left.value, right.value);
	if (!merged.valid) {
		throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
	}
	result.value = merged.data;
	return result;
}
const $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
	$ZodType.init(inst, def);
	const items = def.items;
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				input,
				inst,
				expected: "tuple",
				code: "invalid_type"
			});
			return payload;
		}
		payload.value = [];
		const proms = [];
		const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
		const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
		if (!def.rest) {
			const tooBig = input.length > items.length;
			const tooSmall = input.length < optStart - 1;
			if (tooBig || tooSmall) {
				payload.issues.push({
					...tooBig ? {
						code: "too_big",
						maximum: items.length,
						inclusive: true
					} : {
						code: "too_small",
						minimum: items.length
					},
					input,
					inst,
					origin: "array"
				});
				return payload;
			}
		}
		let i = -1;
		for (const item of items) {
			i++;
			if (i >= input.length) {
				if (i >= optStart) continue;
			}
			const result = item._zod.run({
				value: input[i],
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				proms.push(result.then((result$1) => handleTupleResult(result$1, payload, i)));
			} else {
				handleTupleResult(result, payload, i);
			}
		}
		if (def.rest) {
			const rest = input.slice(items.length);
			for (const el of rest) {
				i++;
				const result = def.rest._zod.run({
					value: el,
					issues: []
				}, ctx);
				if (result instanceof Promise) {
					proms.push(result.then((result$1) => handleTupleResult(result$1, payload, i)));
				} else {
					handleTupleResult(result, payload, i);
				}
			}
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleTupleResult(result, final, index) {
	if (result.issues.length) {
		final.issues.push(...prefixIssues(index, result.issues));
	}
	final.value[index] = result.value;
}
const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!isPlainObject$2(input)) {
			payload.issues.push({
				expected: "record",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		const values = def.keyType._zod.values;
		if (values) {
			payload.value = {};
			const recordKeys = new Set();
			for (const key of values) {
				if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
					recordKeys.add(typeof key === "number" ? key.toString() : key);
					const result = def.valueType._zod.run({
						value: input[key],
						issues: []
					}, ctx);
					if (result instanceof Promise) {
						proms.push(result.then((result$1) => {
							if (result$1.issues.length) {
								payload.issues.push(...prefixIssues(key, result$1.issues));
							}
							payload.value[key] = result$1.value;
						}));
					} else {
						if (result.issues.length) {
							payload.issues.push(...prefixIssues(key, result.issues));
						}
						payload.value[key] = result.value;
					}
				}
			}
			let unrecognized;
			for (const key in input) {
				if (!recordKeys.has(key)) {
					unrecognized = unrecognized ?? [];
					unrecognized.push(key);
				}
			}
			if (unrecognized && unrecognized.length > 0) {
				payload.issues.push({
					code: "unrecognized_keys",
					input,
					inst,
					keys: unrecognized
				});
			}
		} else {
			payload.value = {};
			for (const key of Reflect.ownKeys(input)) {
				if (key === "__proto__") continue;
				let keyResult = def.keyType._zod.run({
					value: key,
					issues: []
				}, ctx);
				if (keyResult instanceof Promise) {
					throw new Error("Async schemas not supported in object keys currently");
				}
				const checkNumericKey = typeof key === "string" && number$4.test(key) && keyResult.issues.length && keyResult.issues.some((iss) => iss.code === "invalid_type" && iss.expected === "number");
				if (checkNumericKey) {
					const retryResult = def.keyType._zod.run({
						value: Number(key),
						issues: []
					}, ctx);
					if (retryResult instanceof Promise) {
						throw new Error("Async schemas not supported in object keys currently");
					}
					if (retryResult.issues.length === 0) {
						keyResult = retryResult;
					}
				}
				if (keyResult.issues.length) {
					if (def.mode === "loose") {
						payload.value[key] = input[key];
					} else {
						payload.issues.push({
							code: "invalid_key",
							origin: "record",
							issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
							input: key,
							path: [key],
							inst
						});
					}
					continue;
				}
				const result = def.valueType._zod.run({
					value: input[key],
					issues: []
				}, ctx);
				if (result instanceof Promise) {
					proms.push(result.then((result$1) => {
						if (result$1.issues.length) {
							payload.issues.push(...prefixIssues(key, result$1.issues));
						}
						payload.value[keyResult.value] = result$1.value;
					}));
				} else {
					if (result.issues.length) {
						payload.issues.push(...prefixIssues(key, result.issues));
					}
					payload.value[keyResult.value] = result.value;
				}
			}
		}
		if (proms.length) {
			return Promise.all(proms).then(() => payload);
		}
		return payload;
	};
});
const $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!(input instanceof Map)) {
			payload.issues.push({
				expected: "map",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		payload.value = new Map();
		for (const [key, value] of input) {
			const keyResult = def.keyType._zod.run({
				value: key,
				issues: []
			}, ctx);
			const valueResult = def.valueType._zod.run({
				value,
				issues: []
			}, ctx);
			if (keyResult instanceof Promise || valueResult instanceof Promise) {
				proms.push(Promise.all([keyResult, valueResult]).then(([keyResult$1, valueResult$1]) => {
					handleMapResult(keyResult$1, valueResult$1, payload, key, input, inst, ctx);
				}));
			} else {
				handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
			}
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
	if (keyResult.issues.length) {
		if (propertyKeyTypes.has(typeof key)) {
			final.issues.push(...prefixIssues(key, keyResult.issues));
		} else {
			final.issues.push({
				code: "invalid_key",
				origin: "map",
				input,
				inst,
				issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
			});
		}
	}
	if (valueResult.issues.length) {
		if (propertyKeyTypes.has(typeof key)) {
			final.issues.push(...prefixIssues(key, valueResult.issues));
		} else {
			final.issues.push({
				origin: "map",
				code: "invalid_element",
				input,
				inst,
				key,
				issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
			});
		}
	}
	final.value.set(keyResult.value, valueResult.value);
}
const $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!(input instanceof Set)) {
			payload.issues.push({
				input,
				inst,
				expected: "set",
				code: "invalid_type"
			});
			return payload;
		}
		const proms = [];
		payload.value = new Set();
		for (const item of input) {
			const result = def.valueType._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				proms.push(result.then((result$1) => handleSetResult(result$1, payload)));
			} else handleSetResult(result, payload);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleSetResult(result, final) {
	if (result.issues.length) {
		final.issues.push(...result.issues);
	}
	final.value.add(result.value);
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
	$ZodType.init(inst, def);
	const values = getEnumValues(def.entries);
	const valuesSet = new Set(values);
	inst._zod.values = valuesSet;
	inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (valuesSet.has(input)) {
			return payload;
		}
		payload.issues.push({
			code: "invalid_value",
			values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
	$ZodType.init(inst, def);
	if (def.values.length === 0) {
		throw new Error("Cannot create literal schema with no valid values");
	}
	const values = new Set(def.values);
	inst._zod.values = values;
	inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (values.has(input)) {
			return payload;
		}
		payload.issues.push({
			code: "invalid_value",
			values: def.values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (input instanceof File) return payload;
		payload.issues.push({
			expected: "file",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			throw new $ZodEncodeError(inst.constructor.name);
		}
		const _out = def.transform(payload.value, payload);
		if (ctx.async) {
			const output = _out instanceof Promise ? _out : Promise.resolve(_out);
			return output.then((output$1) => {
				payload.value = output$1;
				return payload;
			});
		}
		if (_out instanceof Promise) {
			throw new $ZodAsyncError();
		}
		payload.value = _out;
		return payload;
	};
});
function handleOptionalResult(result, input) {
	if (result.issues.length && input === undefined) {
		return {
			issues: [],
			value: undefined
		};
	}
	return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
	});
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
	});
	inst._zod.parse = (payload, ctx) => {
		if (def.innerType._zod.optin === "optional") {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((r) => handleOptionalResult(r, payload.value));
			return handleOptionalResult(result, payload.value);
		}
		if (payload.value === undefined) {
			return payload;
		}
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
	inst._zod.parse = (payload, ctx) => {
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
	});
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
	});
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === null) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			return def.innerType._zod.run(payload, ctx);
		}
		if (payload.value === undefined) {
			payload.value = def.defaultValue;
			/**
			* $ZodDefault returns the default value immediately in forward direction.
			* It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
			return payload;
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) {
			return result.then((result$1) => handleDefaultResult(result$1, def));
		}
		return handleDefaultResult(result, def);
	};
});
function handleDefaultResult(payload, def) {
	if (payload.value === undefined) {
		payload.value = def.defaultValue;
	}
	return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			return def.innerType._zod.run(payload, ctx);
		}
		if (payload.value === undefined) {
			payload.value = def.defaultValue;
		}
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => {
		const v = def.innerType._zod.values;
		return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
	});
	inst._zod.parse = (payload, ctx) => {
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) {
			return result.then((result$1) => handleNonOptionalResult(result$1, inst));
		}
		return handleNonOptionalResult(result, inst);
	};
});
function handleNonOptionalResult(payload, inst) {
	if (!payload.issues.length && payload.value === undefined) {
		payload.issues.push({
			code: "invalid_type",
			expected: "nonoptional",
			input: payload.value,
			inst
		});
	}
	return payload;
}
const $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			throw new $ZodEncodeError("ZodSuccess");
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) {
			return result.then((result$1) => {
				payload.value = result$1.issues.length === 0;
				return payload;
			});
		}
		payload.value = result.issues.length === 0;
		return payload;
	};
});
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			return def.innerType._zod.run(payload, ctx);
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) {
			return result.then((result$1) => {
				payload.value = result$1.value;
				if (result$1.issues.length) {
					payload.value = def.catchValue({
						...payload,
						error: { issues: result$1.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
						input: payload.value
					});
					payload.issues = [];
				}
				return payload;
			});
		}
		payload.value = result.value;
		if (result.issues.length) {
			payload.value = def.catchValue({
				...payload,
				error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
				input: payload.value
			});
			payload.issues = [];
		}
		return payload;
	};
});
const $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
			payload.issues.push({
				input: payload.value,
				inst,
				expected: "nan",
				code: "invalid_type"
			});
			return payload;
		}
		return payload;
	};
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => def.in._zod.values);
	defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			const right = def.out._zod.run(payload, ctx);
			if (right instanceof Promise) {
				return right.then((right$1) => handlePipeResult(right$1, def.in, ctx));
			}
			return handlePipeResult(right, def.in, ctx);
		}
		const left = def.in._zod.run(payload, ctx);
		if (left instanceof Promise) {
			return left.then((left$1) => handlePipeResult(left$1, def.out, ctx));
		}
		return handlePipeResult(left, def.out, ctx);
	};
});
function handlePipeResult(left, next, ctx) {
	if (left.issues.length) {
		left.aborted = true;
		return left;
	}
	return next._zod.run({
		value: left.value,
		issues: left.issues
	}, ctx);
}
const $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => def.in._zod.values);
	defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	inst._zod.parse = (payload, ctx) => {
		const direction = ctx.direction || "forward";
		if (direction === "forward") {
			const left = def.in._zod.run(payload, ctx);
			if (left instanceof Promise) {
				return left.then((left$1) => handleCodecAResult(left$1, def, ctx));
			}
			return handleCodecAResult(left, def, ctx);
		} else {
			const right = def.out._zod.run(payload, ctx);
			if (right instanceof Promise) {
				return right.then((right$1) => handleCodecAResult(right$1, def, ctx));
			}
			return handleCodecAResult(right, def, ctx);
		}
	};
});
function handleCodecAResult(result, def, ctx) {
	if (result.issues.length) {
		result.aborted = true;
		return result;
	}
	const direction = ctx.direction || "forward";
	if (direction === "forward") {
		const transformed = def.transform(result.value, result);
		if (transformed instanceof Promise) {
			return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
		}
		return handleCodecTxResult(result, transformed, def.out, ctx);
	} else {
		const transformed = def.reverseTransform(result.value, result);
		if (transformed instanceof Promise) {
			return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
		}
		return handleCodecTxResult(result, transformed, def.in, ctx);
	}
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
	if (left.issues.length) {
		left.aborted = true;
		return left;
	}
	return nextSchema._zod.run({
		value,
		issues: left.issues
	}, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
	defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			return def.innerType._zod.run(payload, ctx);
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) {
			return result.then(handleReadonlyResult);
		}
		return handleReadonlyResult(result);
	};
});
function handleReadonlyResult(payload) {
	payload.value = Object.freeze(payload.value);
	return payload;
}
const $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
	$ZodType.init(inst, def);
	const regexParts = [];
	for (const part of def.parts) {
		if (typeof part === "object" && part !== null) {
			if (!part._zod.pattern) {
				throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
			}
			const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
			if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);
			const start = source.startsWith("^") ? 1 : 0;
			const end = source.endsWith("$") ? source.length - 1 : source.length;
			regexParts.push(source.slice(start, end));
		} else if (part === null || primitiveTypes.has(typeof part)) {
			regexParts.push(escapeRegex(`${part}`));
		} else {
			throw new Error(`Invalid template literal part: ${part}`);
		}
	}
	inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
	inst._zod.parse = (payload, _ctx) => {
		if (typeof payload.value !== "string") {
			payload.issues.push({
				input: payload.value,
				inst,
				expected: "string",
				code: "invalid_type"
			});
			return payload;
		}
		inst._zod.pattern.lastIndex = 0;
		if (!inst._zod.pattern.test(payload.value)) {
			payload.issues.push({
				input: payload.value,
				inst,
				code: "invalid_format",
				format: def.format ?? "template_literal",
				pattern: inst._zod.pattern.source
			});
			return payload;
		}
		return payload;
	};
});
const $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
	$ZodType.init(inst, def);
	inst._def = def;
	inst._zod.def = def;
	inst.implement = (func) => {
		if (typeof func !== "function") {
			throw new Error("implement() must be called with a function");
		}
		return function(...args) {
			const parsedArgs = inst._def.input ? parse$3(inst._def.input, args) : args;
			const result = Reflect.apply(func, this, parsedArgs);
			if (inst._def.output) {
				return parse$3(inst._def.output, result);
			}
			return result;
		};
	};
	inst.implementAsync = (func) => {
		if (typeof func !== "function") {
			throw new Error("implementAsync() must be called with a function");
		}
		return async function(...args) {
			const parsedArgs = inst._def.input ? await parseAsync$1(inst._def.input, args) : args;
			const result = await Reflect.apply(func, this, parsedArgs);
			if (inst._def.output) {
				return await parseAsync$1(inst._def.output, result);
			}
			return result;
		};
	};
	inst._zod.parse = (payload, _ctx) => {
		if (typeof payload.value !== "function") {
			payload.issues.push({
				code: "invalid_type",
				expected: "function",
				input: payload.value,
				inst
			});
			return payload;
		}
		const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
		if (hasPromiseOutput) {
			payload.value = inst.implementAsync(payload.value);
		} else {
			payload.value = inst.implement(payload.value);
		}
		return payload;
	};
	inst.input = (...args) => {
		const F = inst.constructor;
		if (Array.isArray(args[0])) {
			return new F({
				type: "function",
				input: new $ZodTuple({
					type: "tuple",
					items: args[0],
					rest: args[1]
				}),
				output: inst._def.output
			});
		}
		return new F({
			type: "function",
			input: args[0],
			output: inst._def.output
		});
	};
	inst.output = (output) => {
		const F = inst.constructor;
		return new F({
			type: "function",
			input: inst._def.input,
			output
		});
	};
	return inst;
});
const $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({
			value: inner,
			issues: []
		}, ctx));
	};
});
const $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "innerType", () => def.getter());
	defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
	defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
	defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);
	defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);
	inst._zod.parse = (payload, ctx) => {
		const inner = inst._zod.innerType;
		return inner._zod.run(payload, ctx);
	};
});
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
	$ZodCheck.init(inst, def);
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _) => {
		return payload;
	};
	inst._zod.check = (payload) => {
		const input = payload.value;
		const r = def.fn(input);
		if (r instanceof Promise) {
			return r.then((r$1) => handleRefineResult(r$1, payload, input, inst));
		}
		handleRefineResult(r, payload, input, inst);
		return;
	};
});
function handleRefineResult(result, payload, input, inst) {
	if (!result) {
		const _iss = {
			code: "custom",
			input,
			inst,
			path: [...inst._zod.def.path ?? []],
			continue: !inst._zod.def.abort
		};
		if (inst._zod.def.params) _iss.params = inst._zod.def.params;
		payload.issues.push(issue(_iss));
	}
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ar.js
const error$46 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "   ISO",
		date: "  ISO",
		time: "  ISO",
		duration: "  ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: "   IPv4",
		cidrv6: "   IPv6",
		base64: "  base64-encoded",
		base64url: "  base64url-encoded",
		json_string: "   JSON",
		e164: "   E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `  :   instanceof ${issue$1.expected}    ${received}`;
				}
				return `  :   ${expected}    ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  :   ${stringifyPrimitive(issue$1.values[0])}`;
				return `  :     : ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `   :    ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return `  :    ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `  :   ${issue$1.origin}   ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `  :   ${issue$1.origin}   ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `  :     "${issue$1.prefix}"`;
				if (_issue.format === "ends_with") return `  :     "${_issue.suffix}"`;
				if (_issue.format === "includes") return `  :    "${_issue.includes}"`;
				if (_issue.format === "regex") return `  :     ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format}  `;
			}
			case "not_multiple_of": return `  :      ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, " ")}`;
			case "invalid_key": return `    ${issue$1.origin}`;
			case "invalid_union": return "  ";
			case "invalid_element": return `    ${issue$1.origin}`;
			default: return "  ";
		}
	};
};
function ar_default() {
	return { localeError: error$46() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/az.js
const error$45 = () => {
	const Sizable = {
		string: {
			unit: "simvol",
			verb: "olmaldr"
		},
		file: {
			unit: "bayt",
			verb: "olmaldr"
		},
		array: {
			unit: "element",
			verb: "olmaldr"
		},
		set: {
			unit: "element",
			verb: "olmaldr"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "email address",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datetime",
		date: "ISO date",
		time: "ISO time",
		duration: "ISO duration",
		ipv4: "IPv4 address",
		ipv6: "IPv6 address",
		cidrv4: "IPv4 range",
		cidrv6: "IPv6 range",
		base64: "base64-encoded string",
		base64url: "base64url-encoded string",
		json_string: "JSON string",
		e164: "E.164 number",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Yanl dyr: gzlniln instanceof ${issue$1.expected}, daxil olan ${received}`;
				}
				return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Yanl dyr: gzlniln ${stringifyPrimitive(issue$1.values[0])}`;
				return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ox byk: gzlniln ${issue$1.origin ?? "dyr"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "element"}`;
				return `ox byk: gzlniln ${issue$1.origin ?? "dyr"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ox kiik: gzlniln ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `ox kiik: gzlniln ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
				if (_issue.format === "ends_with") return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
				if (_issue.format === "includes") return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
				if (_issue.format === "regex") return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
				return `Yanl ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Yanl dd: ${issue$1.divisor} il bln biln olmaldr`;
			case "unrecognized_keys": return `Tannmayan aar${issue$1.keys.length > 1 ? "lar" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} daxilind yanl aar`;
			case "invalid_union": return "Yanl dyr";
			case "invalid_element": return `${issue$1.origin} daxilind yanl dyr`;
			default: return `Yanl dyr`;
		}
	};
};
function az_default() {
	return { localeError: error$45() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
	const absCount = Math.abs(count);
	const lastDigit = absCount % 10;
	const lastTwoDigits = absCount % 100;
	if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
		return many;
	}
	if (lastDigit === 1) {
		return one;
	}
	if (lastDigit >= 2 && lastDigit <= 4) {
		return few;
	}
	return many;
}
const error$44 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		array: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		set: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		file: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "email ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "   base64",
		base64url: "   base64url",
		json_string: "JSON ",
		e164: " E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :  instanceof ${issue$1.expected},  ${received}`;
				}
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const maxValue = Number(issue$1.maximum);
					const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return ` : ,  ${issue$1.origin ?? ""}  ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${unit}`;
				}
				return ` : ,  ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const minValue = Number(issue$1.minimum);
					const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return ` : ,  ${issue$1.origin}  ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${unit}`;
				}
				return ` : ,  ${issue$1.origin}   ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :    "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :    ${issue$1.divisor}`;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return " ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function be_default() {
	return { localeError: error$44() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/bg.js
const error$43 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64- ",
		base64url: "base64url- ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :  instanceof ${issue$1.expected},  ${received}`;
				}
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` :     "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return ` :     "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :    "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :     ${_issue.pattern}`;
				let invalid_adj = "";
				if (_issue.format === "emoji") invalid_adj = "";
				if (_issue.format === "datetime") invalid_adj = "";
				if (_issue.format === "date") invalid_adj = "";
				if (_issue.format === "time") invalid_adj = "";
				if (_issue.format === "duration") invalid_adj = "";
				return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :      ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return " ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function bg_default() {
	return { localeError: error$43() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ca.js
const error$42 = () => {
	const Sizable = {
		string: {
			unit: "carcters",
			verb: "contenir"
		},
		file: {
			unit: "bytes",
			verb: "contenir"
		},
		array: {
			unit: "elements",
			verb: "contenir"
		},
		set: {
			unit: "elements",
			verb: "contenir"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entrada",
		email: "adrea electrnica",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data i hora ISO",
		date: "data ISO",
		time: "hora ISO",
		duration: "durada ISO",
		ipv4: "adrea IPv4",
		ipv6: "adrea IPv6",
		cidrv4: "rang IPv4",
		cidrv6: "rang IPv6",
		base64: "cadena codificada en base64",
		base64url: "cadena codificada en base64url",
		json_string: "cadena JSON",
		e164: "nmero E.164",
		jwt: "JWT",
		template_literal: "entrada"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Tipus invlid: s'esperava instanceof ${issue$1.expected}, s'ha rebut ${received}`;
				}
				return `Tipus invlid: s'esperava ${expected}, s'ha rebut ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Valor invlid: s'esperava ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opci invlida: s'esperava una de ${joinValues(issue$1.values, " o ")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "com a mxim" : "menys de";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Massa gran: s'esperava que ${issue$1.origin ?? "el valor"} contingus ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? "elements"}`;
				return `Massa gran: s'esperava que ${issue$1.origin ?? "el valor"} fos ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "com a mnim" : "ms de";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Massa petit: s'esperava que ${issue$1.origin} contingus ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Massa petit: s'esperava que ${issue$1.origin} fos ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Format invlid: ha d'incloure "${_issue.includes}"`;
				if (_issue.format === "regex") return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
				return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nmero invlid: ha de ser mltiple de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Clau${issue$1.keys.length > 1 ? "s" : ""} no reconeguda${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Clau invlida a ${issue$1.origin}`;
			case "invalid_union": return "Entrada invlida";
			case "invalid_element": return `Element invlid a ${issue$1.origin}`;
			default: return `Entrada invlida`;
		}
	};
};
function ca_default() {
	return { localeError: error$42() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/cs.js
const error$41 = () => {
	const Sizable = {
		string: {
			unit: "znak",
			verb: "mt"
		},
		file: {
			unit: "bajt",
			verb: "mt"
		},
		array: {
			unit: "prvk",
			verb: "mt"
		},
		set: {
			unit: "prvk",
			verb: "mt"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "regulrn vraz",
		email: "e-mailov adresa",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "datum a as ve formtu ISO",
		date: "datum ve formtu ISO",
		time: "as ve formtu ISO",
		duration: "doba trvn ISO",
		ipv4: "IPv4 adresa",
		ipv6: "IPv6 adresa",
		cidrv4: "rozsah IPv4",
		cidrv6: "rozsah IPv6",
		base64: "etzec zakdovan ve formtu base64",
		base64url: "etzec zakdovan ve formtu base64url",
		json_string: "etzec ve formtu JSON",
		e164: "slo E.164",
		jwt: "JWT",
		template_literal: "vstup"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "slo",
		string: "etzec",
		function: "funkce",
		array: "pole"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Neplatn vstup: oekvno instanceof ${issue$1.expected}, obdreno ${received}`;
				}
				return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Neplatn vstup: oekvno ${stringifyPrimitive(issue$1.values[0])}`;
				return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Hodnota je pli velk: ${issue$1.origin ?? "hodnota"} mus mt ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "prvk"}`;
				}
				return `Hodnota je pli velk: ${issue$1.origin ?? "hodnota"} mus bt ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Hodnota je pli mal: ${issue$1.origin ?? "hodnota"} mus mt ${adj}${issue$1.minimum.toString()} ${sizing.unit ?? "prvk"}`;
				}
				return `Hodnota je pli mal: ${issue$1.origin ?? "hodnota"} mus bt ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
				if (_issue.format === "regex") return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
				return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Neplatn slo: mus bt nsobkem ${issue$1.divisor}`;
			case "unrecognized_keys": return `Neznm kle: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Neplatn kl v ${issue$1.origin}`;
			case "invalid_union": return "Neplatn vstup";
			case "invalid_element": return `Neplatn hodnota v ${issue$1.origin}`;
			default: return `Neplatn vstup`;
		}
	};
};
function cs_default() {
	return { localeError: error$41() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/da.js
const error$40 = () => {
	const Sizable = {
		string: {
			unit: "tegn",
			verb: "havde"
		},
		file: {
			unit: "bytes",
			verb: "havde"
		},
		array: {
			unit: "elementer",
			verb: "indeholdt"
		},
		set: {
			unit: "elementer",
			verb: "indeholdt"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "e-mailadresse",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO dato- og klokkeslt",
		date: "ISO-dato",
		time: "ISO-klokkeslt",
		duration: "ISO-varighed",
		ipv4: "IPv4-omrde",
		ipv6: "IPv6-omrde",
		cidrv4: "IPv4-spektrum",
		cidrv6: "IPv6-spektrum",
		base64: "base64-kodet streng",
		base64url: "base64url-kodet streng",
		json_string: "JSON-streng",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		string: "streng",
		number: "tal",
		boolean: "boolean",
		array: "liste",
		object: "objekt",
		set: "st",
		file: "fil"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Ugyldigt input: forventede instanceof ${issue$1.expected}, fik ${received}`;
				}
				return `Ugyldigt input: forventede ${expected}, fik ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ugyldigt valg: forventede en af flgende ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? "elementer"}`;
				return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) {
					return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `For lille: forventede ${origin} havde ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
				if (_issue.format === "regex") return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
				return `Ugyldig ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ugyldigt tal: skal vre deleligt med ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ugyldig ngle i ${issue$1.origin}`;
			case "invalid_union": return "Ugyldigt input: matcher ingen af de tilladte typer";
			case "invalid_element": return `Ugyldig vrdi i ${issue$1.origin}`;
			default: return `Ugyldigt input`;
		}
	};
};
function da_default() {
	return { localeError: error$40() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/de.js
const error$39 = () => {
	const Sizable = {
		string: {
			unit: "Zeichen",
			verb: "zu haben"
		},
		file: {
			unit: "Bytes",
			verb: "zu haben"
		},
		array: {
			unit: "Elemente",
			verb: "zu haben"
		},
		set: {
			unit: "Elemente",
			verb: "zu haben"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "Eingabe",
		email: "E-Mail-Adresse",
		url: "URL",
		emoji: "Emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-Datum und -Uhrzeit",
		date: "ISO-Datum",
		time: "ISO-Uhrzeit",
		duration: "ISO-Dauer",
		ipv4: "IPv4-Adresse",
		ipv6: "IPv6-Adresse",
		cidrv4: "IPv4-Bereich",
		cidrv6: "IPv6-Bereich",
		base64: "Base64-codierter String",
		base64url: "Base64-URL-codierter String",
		json_string: "JSON-String",
		e164: "E.164-Nummer",
		jwt: "JWT",
		template_literal: "Eingabe"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "Zahl",
		array: "Array"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Ungltige Eingabe: erwartet instanceof ${issue$1.expected}, erhalten ${received}`;
				}
				return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ungltige Option: erwartet eine von ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Zu gro: erwartet, dass ${issue$1.origin ?? "Wert"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
				return `Zu gro: erwartet, dass ${issue$1.origin ?? "Wert"} ${adj}${issue$1.maximum.toString()} ist`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Zu klein: erwartet, dass ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit} hat`;
				}
				return `Zu klein: erwartet, dass ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ist`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
				if (_issue.format === "ends_with") return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
				if (_issue.format === "includes") return `Ungltiger String: muss "${_issue.includes}" enthalten`;
				if (_issue.format === "regex") return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
				return `Ungltig: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ungltige Zahl: muss ein Vielfaches von ${issue$1.divisor} sein`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ungltiger Schlssel in ${issue$1.origin}`;
			case "invalid_union": return "Ungltige Eingabe";
			case "invalid_element": return `Ungltiger Wert in ${issue$1.origin}`;
			default: return `Ungltige Eingabe`;
		}
	};
};
function de_default() {
	return { localeError: error$39() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/en.js
const error$38 = () => {
	const Sizable = {
		string: {
			unit: "characters",
			verb: "to have"
		},
		file: {
			unit: "bytes",
			verb: "to have"
		},
		array: {
			unit: "items",
			verb: "to have"
		},
		set: {
			unit: "items",
			verb: "to have"
		},
		map: {
			unit: "entries",
			verb: "to have"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "email address",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datetime",
		date: "ISO date",
		time: "ISO time",
		duration: "ISO duration",
		ipv4: "IPv4 address",
		ipv6: "IPv6 address",
		mac: "MAC address",
		cidrv4: "IPv4 range",
		cidrv6: "IPv6 range",
		base64: "base64-encoded string",
		base64url: "base64url-encoded string",
		json_string: "JSON string",
		e164: "E.164 number",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				return `Invalid input: expected ${expected}, received ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue$1.values[0])}`;
				return `Invalid option: expected one of ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Too big: expected ${issue$1.origin ?? "value"} to have ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elements"}`;
				return `Too big: expected ${issue$1.origin ?? "value"} to be ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Too small: expected ${issue$1.origin} to have ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Too small: expected ${issue$1.origin} to be ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `Invalid string: must start with "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `Invalid string: must end with "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Invalid string: must include "${_issue.includes}"`;
				if (_issue.format === "regex") return `Invalid string: must match pattern ${_issue.pattern}`;
				return `Invalid ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Invalid number: must be a multiple of ${issue$1.divisor}`;
			case "unrecognized_keys": return `Unrecognized key${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Invalid key in ${issue$1.origin}`;
			case "invalid_union": return "Invalid input";
			case "invalid_element": return `Invalid value in ${issue$1.origin}`;
			default: return `Invalid input`;
		}
	};
};
function en_default$1() {
	return { localeError: error$38() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/eo.js
const error$37 = () => {
	const Sizable = {
		string: {
			unit: "karaktrojn",
			verb: "havi"
		},
		file: {
			unit: "bajtojn",
			verb: "havi"
		},
		array: {
			unit: "elementojn",
			verb: "havi"
		},
		set: {
			unit: "elementojn",
			verb: "havi"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "enigo",
		email: "retadreso",
		url: "URL",
		emoji: "emoio",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-datotempo",
		date: "ISO-dato",
		time: "ISO-tempo",
		duration: "ISO-daro",
		ipv4: "IPv4-adreso",
		ipv6: "IPv6-adreso",
		cidrv4: "IPv4-rango",
		cidrv6: "IPv6-rango",
		base64: "64-ume kodita karaktraro",
		base64url: "URL-64-ume kodita karaktraro",
		json_string: "JSON-karaktraro",
		e164: "E.164-nombro",
		jwt: "JWT",
		template_literal: "enigo"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nombro",
		array: "tabelo",
		null: "senvalora"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Nevalida enigo: atendiis instanceof ${issue$1.expected}, riceviis ${received}`;
				}
				return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Nevalida enigo: atendiis ${stringifyPrimitive(issue$1.values[0])}`;
				return `Nevalida opcio: atendiis unu el ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Tro granda: atendiis ke ${issue$1.origin ?? "valoro"} havu ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
				return `Tro granda: atendiis ke ${issue$1.origin ?? "valoro"} havu ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Tro malgranda: atendiis ke ${issue$1.origin} havu ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Tro malgranda: atendiis ke ${issue$1.origin} estu ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
				if (_issue.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
				return `Nevalida ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nevalida nombro: devas esti oblo de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Nekonata${issue$1.keys.length > 1 ? "j" : ""} losilo${issue$1.keys.length > 1 ? "j" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Nevalida losilo en ${issue$1.origin}`;
			case "invalid_union": return "Nevalida enigo";
			case "invalid_element": return `Nevalida valoro en ${issue$1.origin}`;
			default: return `Nevalida enigo`;
		}
	};
};
function eo_default() {
	return { localeError: error$37() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/es.js
const error$36 = () => {
	const Sizable = {
		string: {
			unit: "caracteres",
			verb: "tener"
		},
		file: {
			unit: "bytes",
			verb: "tener"
		},
		array: {
			unit: "elementos",
			verb: "tener"
		},
		set: {
			unit: "elementos",
			verb: "tener"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entrada",
		email: "direccin de correo electrnico",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "fecha y hora ISO",
		date: "fecha ISO",
		time: "hora ISO",
		duration: "duracin ISO",
		ipv4: "direccin IPv4",
		ipv6: "direccin IPv6",
		cidrv4: "rango IPv4",
		cidrv6: "rango IPv6",
		base64: "cadena codificada en base64",
		base64url: "URL codificada en base64",
		json_string: "cadena JSON",
		e164: "nmero E.164",
		jwt: "JWT",
		template_literal: "entrada"
	};
	const TypeDictionary = {
		nan: "NaN",
		string: "texto",
		number: "nmero",
		boolean: "booleano",
		array: "arreglo",
		object: "objeto",
		set: "conjunto",
		file: "archivo",
		date: "fecha",
		bigint: "nmero grande",
		symbol: "smbolo",
		undefined: "indefinido",
		null: "nulo",
		function: "funcin",
		map: "mapa",
		record: "registro",
		tuple: "tupla",
		enum: "enumeracin",
		union: "unin",
		literal: "literal",
		promise: "promesa",
		void: "vaco",
		never: "nunca",
		unknown: "desconocido",
		any: "cualquiera"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Entrada invlida: se esperaba instanceof ${issue$1.expected}, recibido ${received}`;
				}
				return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entrada invlida: se esperaba ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opcin invlida: se esperaba una de ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementos"}`;
				return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				if (sizing) {
					return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Cadena invlida: debe incluir "${_issue.includes}"`;
				if (_issue.format === "regex") return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
				return `Invlido ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nmero invlido: debe ser mltiplo de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Llave${issue$1.keys.length > 1 ? "s" : ""} desconocida${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Llave invlida en ${TypeDictionary[issue$1.origin] ?? issue$1.origin}`;
			case "invalid_union": return "Entrada invlida";
			case "invalid_element": return `Valor invlido en ${TypeDictionary[issue$1.origin] ?? issue$1.origin}`;
			default: return `Entrada invlida`;
		}
	};
};
function es_default() {
	return { localeError: error$36() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/fa.js
const error$35 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "   ",
		date: " ",
		time: " ",
		duration: "  ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64-encoded ",
		base64url: "base64url-encoded ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :  instanceof ${issue$1.expected}  ${received}  `;
				}
				return ` :  ${expected}  ${received}  `;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) {
					return ` :  ${stringifyPrimitive(issue$1.values[0])} `;
				}
				return ` :    ${joinValues(issue$1.values, "|")} `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""} `;
				}
				return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit} `;
				}
				return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` :   "${_issue.prefix}"  `;
				}
				if (_issue.format === "ends_with") {
					return ` :   "${_issue.suffix}"  `;
				}
				if (_issue.format === "includes") {
					return ` :   "${_issue.includes}" `;
				}
				if (_issue.format === "regex") {
					return ` :    ${_issue.pattern}   `;
				}
				return `${FormatDictionary[_issue.format] ?? issue$1.format} `;
			}
			case "not_multiple_of": return ` :   ${issue$1.divisor} `;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return ` `;
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function fa_default() {
	return { localeError: error$35() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/fi.js
const error$34 = () => {
	const Sizable = {
		string: {
			unit: "merkki",
			subject: "merkkijonon"
		},
		file: {
			unit: "tavua",
			subject: "tiedoston"
		},
		array: {
			unit: "alkiota",
			subject: "listan"
		},
		set: {
			unit: "alkiota",
			subject: "joukon"
		},
		number: {
			unit: "",
			subject: "luvun"
		},
		bigint: {
			unit: "",
			subject: "suuren kokonaisluvun"
		},
		int: {
			unit: "",
			subject: "kokonaisluvun"
		},
		date: {
			unit: "",
			subject: "pivmrn"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "snnllinen lauseke",
		email: "shkpostiosoite",
		url: "URL-osoite",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-aikaleima",
		date: "ISO-pivmr",
		time: "ISO-aika",
		duration: "ISO-kesto",
		ipv4: "IPv4-osoite",
		ipv6: "IPv6-osoite",
		cidrv4: "IPv4-alue",
		cidrv6: "IPv6-alue",
		base64: "base64-koodattu merkkijono",
		base64url: "base64url-koodattu merkkijono",
		json_string: "JSON-merkkijono",
		e164: "E.164-luku",
		jwt: "JWT",
		template_literal: "templaattimerkkijono"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Virheellinen tyyppi: odotettiin instanceof ${issue$1.expected}, oli ${received}`;
				}
				return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue$1.values[0])}`;
				return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue$1.maximum.toString()} ${sizing.unit}`.trim();
				}
				return `Liian suuri: arvon tytyy olla ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue$1.minimum.toString()} ${sizing.unit}`.trim();
				}
				return `Liian pieni: arvon tytyy olla ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
				if (_issue.format === "regex") {
					return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
				}
				return `Virheellinen ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Virheellinen luku: tytyy olla luvun ${issue$1.divisor} monikerta`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return "Virheellinen avain tietueessa";
			case "invalid_union": return "Virheellinen unioni";
			case "invalid_element": return "Virheellinen arvo joukossa";
			default: return `Virheellinen syte`;
		}
	};
};
function fi_default() {
	return { localeError: error$34() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/fr.js
const error$33 = () => {
	const Sizable = {
		string: {
			unit: "caractres",
			verb: "avoir"
		},
		file: {
			unit: "octets",
			verb: "avoir"
		},
		array: {
			unit: "lments",
			verb: "avoir"
		},
		set: {
			unit: "lments",
			verb: "avoir"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entre",
		email: "adresse e-mail",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "date et heure ISO",
		date: "date ISO",
		time: "heure ISO",
		duration: "dure ISO",
		ipv4: "adresse IPv4",
		ipv6: "adresse IPv6",
		cidrv4: "plage IPv4",
		cidrv6: "plage IPv6",
		base64: "chane encode en base64",
		base64url: "chane encode en base64url",
		json_string: "chane JSON",
		e164: "numro E.164",
		jwt: "JWT",
		template_literal: "entre"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nombre",
		array: "tableau"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Entre invalide : instanceof ${issue$1.expected} attendu, ${received} reu`;
				}
				return `Entre invalide : ${expected} attendu, ${received} reu`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entre invalide : ${stringifyPrimitive(issue$1.values[0])} attendu`;
				return `Option invalide : une valeur parmi ${joinValues(issue$1.values, "|")} attendue`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Trop grand : ${issue$1.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
				return `Trop grand : ${issue$1.origin ?? "valeur"} doit tre ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Trop petit : ${issue$1.origin} doit ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Trop petit : ${issue$1.origin} doit tre ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Chane invalide : doit commencer par "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Chane invalide : doit inclure "${_issue.includes}"`;
				if (_issue.format === "regex") return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} invalide`;
			}
			case "not_multiple_of": return `Nombre invalide : doit tre un multiple de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Cl${issue$1.keys.length > 1 ? "s" : ""} non reconnue${issue$1.keys.length > 1 ? "s" : ""} : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Cl invalide dans ${issue$1.origin}`;
			case "invalid_union": return "Entre invalide";
			case "invalid_element": return `Valeur invalide dans ${issue$1.origin}`;
			default: return `Entre invalide`;
		}
	};
};
function fr_default() {
	return { localeError: error$33() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/fr-CA.js
const error$32 = () => {
	const Sizable = {
		string: {
			unit: "caractres",
			verb: "avoir"
		},
		file: {
			unit: "octets",
			verb: "avoir"
		},
		array: {
			unit: "lments",
			verb: "avoir"
		},
		set: {
			unit: "lments",
			verb: "avoir"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "entre",
		email: "adresse courriel",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "date-heure ISO",
		date: "date ISO",
		time: "heure ISO",
		duration: "dure ISO",
		ipv4: "adresse IPv4",
		ipv6: "adresse IPv6",
		cidrv4: "plage IPv4",
		cidrv6: "plage IPv6",
		base64: "chane encode en base64",
		base64url: "chane encode en base64url",
		json_string: "chane JSON",
		e164: "numro E.164",
		jwt: "JWT",
		template_literal: "entre"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Entre invalide : attendu instanceof ${issue$1.expected}, reu ${received}`;
				}
				return `Entre invalide : attendu ${expected}, reu ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entre invalide : attendu ${stringifyPrimitive(issue$1.values[0])}`;
				return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Trop grand : attendu que ${issue$1.origin ?? "la valeur"} ait ${adj}${issue$1.maximum.toString()} ${sizing.unit}`;
				return `Trop grand : attendu que ${issue$1.origin ?? "la valeur"} soit ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Trop petit : attendu que ${issue$1.origin} ait ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Trop petit : attendu que ${issue$1.origin} soit ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `Chane invalide : doit commencer par "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Chane invalide : doit inclure "${_issue.includes}"`;
				if (_issue.format === "regex") return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} invalide`;
			}
			case "not_multiple_of": return `Nombre invalide : doit tre un multiple de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Cl${issue$1.keys.length > 1 ? "s" : ""} non reconnue${issue$1.keys.length > 1 ? "s" : ""} : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Cl invalide dans ${issue$1.origin}`;
			case "invalid_union": return "Entre invalide";
			case "invalid_element": return `Valeur invalide dans ${issue$1.origin}`;
			default: return `Entre invalide`;
		}
	};
};
function fr_CA_default() {
	return { localeError: error$32() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/he.js
const error$31 = () => {
	const TypeNames = {
		string: {
			label: "",
			gender: "f"
		},
		number: {
			label: "",
			gender: "m"
		},
		boolean: {
			label: " ",
			gender: "m"
		},
		bigint: {
			label: "BigInt",
			gender: "m"
		},
		date: {
			label: "",
			gender: "m"
		},
		array: {
			label: "",
			gender: "m"
		},
		object: {
			label: "",
			gender: "m"
		},
		null: {
			label: "  (null)",
			gender: "m"
		},
		undefined: {
			label: "   (undefined)",
			gender: "m"
		},
		symbol: {
			label: " (Symbol)",
			gender: "m"
		},
		function: {
			label: "",
			gender: "f"
		},
		map: {
			label: " (Map)",
			gender: "f"
		},
		set: {
			label: " (Set)",
			gender: "f"
		},
		file: {
			label: "",
			gender: "m"
		},
		promise: {
			label: "Promise",
			gender: "m"
		},
		NaN: {
			label: "NaN",
			gender: "m"
		},
		unknown: {
			label: "  ",
			gender: "m"
		},
		value: {
			label: "",
			gender: "m"
		}
	};
	const Sizable = {
		string: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		file: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		array: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		set: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		},
		number: {
			unit: "",
			shortLabel: "",
			longLabel: ""
		}
	};
	const typeEntry = (t) => t ? TypeNames[t] : undefined;
	const typeLabel = (t) => {
		const e = typeEntry(t);
		if (e) return e.label;
		return t ?? TypeNames.unknown.label;
	};
	const withDefinite = (t) => `${typeLabel(t)}`;
	const verbFor = (t) => {
		const e = typeEntry(t);
		const gender = e?.gender ?? "m";
		return gender === "f" ? " " : " ";
	};
	const getSizing = (origin) => {
		if (!origin) return null;
		return Sizable[origin] ?? null;
	};
	const FormatDictionary = {
		regex: {
			label: "",
			gender: "m"
		},
		email: {
			label: " ",
			gender: "f"
		},
		url: {
			label: " ",
			gender: "f"
		},
		emoji: {
			label: "'",
			gender: "m"
		},
		uuid: {
			label: "UUID",
			gender: "m"
		},
		nanoid: {
			label: "nanoid",
			gender: "m"
		},
		guid: {
			label: "GUID",
			gender: "m"
		},
		cuid: {
			label: "cuid",
			gender: "m"
		},
		cuid2: {
			label: "cuid2",
			gender: "m"
		},
		ulid: {
			label: "ULID",
			gender: "m"
		},
		xid: {
			label: "XID",
			gender: "m"
		},
		ksuid: {
			label: "KSUID",
			gender: "m"
		},
		datetime: {
			label: "  ISO",
			gender: "m"
		},
		date: {
			label: " ISO",
			gender: "m"
		},
		time: {
			label: " ISO",
			gender: "m"
		},
		duration: {
			label: "  ISO",
			gender: "m"
		},
		ipv4: {
			label: " IPv4",
			gender: "f"
		},
		ipv6: {
			label: " IPv6",
			gender: "f"
		},
		cidrv4: {
			label: " IPv4",
			gender: "m"
		},
		cidrv6: {
			label: " IPv6",
			gender: "m"
		},
		base64: {
			label: "  64",
			gender: "f"
		},
		base64url: {
			label: "  64  ",
			gender: "f"
		},
		json_string: {
			label: " JSON",
			gender: "f"
		},
		e164: {
			label: " E.164",
			gender: "m"
		},
		jwt: {
			label: "JWT",
			gender: "m"
		},
		ends_with: {
			label: "",
			gender: "m"
		},
		includes: {
			label: "",
			gender: "m"
		},
		lowercase: {
			label: "",
			gender: "m"
		},
		starts_with: {
			label: "",
			gender: "m"
		},
		uppercase: {
			label: "",
			gender: "m"
		}
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expectedKey = issue$1.expected;
				const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `  :   instanceof ${issue$1.expected},  ${received}`;
				}
				return `  :   ${expected},  ${received}`;
			}
			case "invalid_value": {
				if (issue$1.values.length === 1) {
					return `  :    ${stringifyPrimitive(issue$1.values[0])}`;
				}
				const stringified = issue$1.values.map((v) => stringifyPrimitive(v));
				if (issue$1.values.length === 2) {
					return `  :    ${stringified[0]}  ${stringified[1]}`;
				}
				const lastValue = stringified[stringified.length - 1];
				const restValues = stringified.slice(0, -1).join(", ");
				return `  :    ${restValues}  ${lastValue}`;
			}
			case "too_big": {
				const sizing = getSizing(issue$1.origin);
				const subject = withDefinite(issue$1.origin ?? "value");
				if (issue$1.origin === "string") {
					return `${sizing?.longLabel ?? ""} : ${subject}   ${issue$1.maximum.toString()} ${sizing?.unit ?? ""} ${issue$1.inclusive ? " " : " "}`.trim();
				}
				if (issue$1.origin === "number") {
					const comparison = issue$1.inclusive ? `   -${issue$1.maximum}` : ` -${issue$1.maximum}`;
					return ` : ${subject}   ${comparison}`;
				}
				if (issue$1.origin === "array" || issue$1.origin === "set") {
					const verb = issue$1.origin === "set" ? "" : "";
					const comparison = issue$1.inclusive ? `${issue$1.maximum} ${sizing?.unit ?? ""}  ` : ` -${issue$1.maximum} ${sizing?.unit ?? ""}`;
					return ` : ${subject} ${verb}  ${comparison}`.trim();
				}
				const adj = issue$1.inclusive ? "<=" : "<";
				const be = verbFor(issue$1.origin ?? "value");
				if (sizing?.unit) {
					return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue$1.maximum.toString()} ${sizing.unit}`;
				}
				return `${sizing?.longLabel ?? ""} : ${subject} ${be} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const sizing = getSizing(issue$1.origin);
				const subject = withDefinite(issue$1.origin ?? "value");
				if (issue$1.origin === "string") {
					return `${sizing?.shortLabel ?? ""} : ${subject}   ${issue$1.minimum.toString()} ${sizing?.unit ?? ""} ${issue$1.inclusive ? " " : ""}`.trim();
				}
				if (issue$1.origin === "number") {
					const comparison = issue$1.inclusive ? `   -${issue$1.minimum}` : ` -${issue$1.minimum}`;
					return ` : ${subject}   ${comparison}`;
				}
				if (issue$1.origin === "array" || issue$1.origin === "set") {
					const verb = issue$1.origin === "set" ? "" : "";
					if (issue$1.minimum === 1 && issue$1.inclusive) {
						const singularPhrase = issue$1.origin === "set" ? "  " : "  ";
						return ` : ${subject} ${verb}  ${singularPhrase}`;
					}
					const comparison = issue$1.inclusive ? `${issue$1.minimum} ${sizing?.unit ?? ""}  ` : ` -${issue$1.minimum} ${sizing?.unit ?? ""}`;
					return ` : ${subject} ${verb}  ${comparison}`.trim();
				}
				const adj = issue$1.inclusive ? ">=" : ">";
				const be = verbFor(issue$1.origin ?? "value");
				if (sizing?.unit) {
					return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `${sizing?.shortLabel ?? ""} : ${subject} ${be} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `    "${_issue.suffix}"`;
				if (_issue.format === "includes") return `   "${_issue.includes}"`;
				if (_issue.format === "regex") return `    ${_issue.pattern}`;
				const nounEntry = FormatDictionary[_issue.format];
				const noun = nounEntry?.label ?? _issue.format;
				const gender = nounEntry?.gender ?? "m";
				const adjective = gender === "f" ? "" : "";
				return `${noun}  ${adjective}`;
			}
			case "not_multiple_of": return `  :     ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""}  ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": {
				return `   `;
			}
			case "invalid_union": return "  ";
			case "invalid_element": {
				const place = withDefinite(issue$1.origin ?? "array");
				return `   ${place}`;
			}
			default: return `  `;
		}
	};
};
function he_default() {
	return { localeError: error$31() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/hu.js
const error$30 = () => {
	const Sizable = {
		string: {
			unit: "karakter",
			verb: "legyen"
		},
		file: {
			unit: "byte",
			verb: "legyen"
		},
		array: {
			unit: "elem",
			verb: "legyen"
		},
		set: {
			unit: "elem",
			verb: "legyen"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "bemenet",
		email: "email cm",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO idblyeg",
		date: "ISO dtum",
		time: "ISO id",
		duration: "ISO idintervallum",
		ipv4: "IPv4 cm",
		ipv6: "IPv6 cm",
		cidrv4: "IPv4 tartomny",
		cidrv6: "IPv6 tartomny",
		base64: "base64-kdolt string",
		base64url: "base64url-kdolt string",
		json_string: "JSON string",
		e164: "E.164 szm",
		jwt: "JWT",
		template_literal: "bemenet"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "szm",
		array: "tmb"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `rvnytelen bemenet: a vrt rtk instanceof ${issue$1.expected}, a kapott rtk ${received}`;
				}
				return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue$1.values[0])}`;
				return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Tl nagy: ${issue$1.origin ?? "rtk"} mrete tl nagy ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elem"}`;
				return `Tl nagy: a bemeneti rtk ${issue$1.origin ?? "rtk"} tl nagy: ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Tl kicsi: a bemeneti rtk ${issue$1.origin} mrete tl kicsi ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Tl kicsi: a bemeneti rtk ${issue$1.origin} tl kicsi ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
				if (_issue.format === "ends_with") return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
				if (_issue.format === "includes") return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
				if (_issue.format === "regex") return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
				return `rvnytelen ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `rvnytelen szm: ${issue$1.divisor} tbbszrsnek kell lennie`;
			case "unrecognized_keys": return `Ismeretlen kulcs${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `rvnytelen kulcs ${issue$1.origin}`;
			case "invalid_union": return "rvnytelen bemenet";
			case "invalid_element": return `rvnytelen rtk: ${issue$1.origin}`;
			default: return `rvnytelen bemenet`;
		}
	};
};
function hu_default() {
	return { localeError: error$30() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
	return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
	if (!word) return "";
	const vowels = [
		"",
		"",
		"",
		"",
		"",
		"",
		""
	];
	const lastChar = word[word.length - 1];
	return word + (vowels.includes(lastChar) ? "" : "");
}
const error$29 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		},
		file: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		},
		array: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		},
		set: {
			unit: {
				one: "",
				many: ""
			},
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: ". ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64  ",
		base64url: "base64url  ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `    instanceof ${issue$1.expected},   ${received}`;
				}
				return `    ${expected},   ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `    ${stringifyPrimitive(issue$1.values[1])}`;
				return `      ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const maxValue = Number(issue$1.maximum);
					const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
					return `    ,  ${withDefiniteArticle(issue$1.origin ?? "")}  ${adj}${issue$1.maximum.toString()} ${unit}`;
				}
				return `    ,  ${withDefiniteArticle(issue$1.origin ?? "")}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const minValue = Number(issue$1.minimum);
					const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
					return `    ,  ${withDefiniteArticle(issue$1.origin)}  ${adj}${issue$1.minimum.toString()} ${unit}`;
				}
				return `    ,  ${withDefiniteArticle(issue$1.origin)}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `     "${_issue.prefix}"-`;
				if (_issue.format === "ends_with") return `     "${_issue.suffix}"-`;
				if (_issue.format === "includes") return `     "${_issue.includes}"`;
				if (_issue.format === "regex") return `     ${_issue.pattern} `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `      ${issue$1.divisor}-`;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}. ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `  ${withDefiniteArticle(issue$1.origin)}-`;
			case "invalid_union": return " ";
			case "invalid_element": return `  ${withDefiniteArticle(issue$1.origin)}-`;
			default: return ` `;
		}
	};
};
function hy_default() {
	return { localeError: error$29() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/id.js
const error$28 = () => {
	const Sizable = {
		string: {
			unit: "karakter",
			verb: "memiliki"
		},
		file: {
			unit: "byte",
			verb: "memiliki"
		},
		array: {
			unit: "item",
			verb: "memiliki"
		},
		set: {
			unit: "item",
			verb: "memiliki"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "alamat email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "tanggal dan waktu format ISO",
		date: "tanggal format ISO",
		time: "jam format ISO",
		duration: "durasi format ISO",
		ipv4: "alamat IPv4",
		ipv6: "alamat IPv6",
		cidrv4: "rentang alamat IPv4",
		cidrv6: "rentang alamat IPv6",
		base64: "string dengan enkode base64",
		base64url: "string dengan enkode base64url",
		json_string: "string JSON",
		e164: "angka E.164",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Input tidak valid: diharapkan instanceof ${issue$1.expected}, diterima ${received}`;
				}
				return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Input tidak valid: diharapkan ${stringifyPrimitive(issue$1.values[0])}`;
				return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Terlalu besar: diharapkan ${issue$1.origin ?? "value"} memiliki ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elemen"}`;
				return `Terlalu besar: diharapkan ${issue$1.origin ?? "value"} menjadi ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Terlalu kecil: diharapkan ${issue$1.origin} memiliki ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Terlalu kecil: diharapkan ${issue$1.origin} menjadi ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
				if (_issue.format === "includes") return `String tidak valid: harus menyertakan "${_issue.includes}"`;
				if (_issue.format === "regex") return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} tidak valid`;
			}
			case "not_multiple_of": return `Angka tidak valid: harus kelipatan dari ${issue$1.divisor}`;
			case "unrecognized_keys": return `Kunci tidak dikenali ${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Kunci tidak valid di ${issue$1.origin}`;
			case "invalid_union": return "Input tidak valid";
			case "invalid_element": return `Nilai tidak valid di ${issue$1.origin}`;
			default: return `Input tidak valid`;
		}
	};
};
function id_default() {
	return { localeError: error$28() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/is.js
const error$27 = () => {
	const Sizable = {
		string: {
			unit: "stafi",
			verb: "a hafa"
		},
		file: {
			unit: "bti",
			verb: "a hafa"
		},
		array: {
			unit: "hluti",
			verb: "a hafa"
		},
		set: {
			unit: "hluti",
			verb: "a hafa"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "gildi",
		email: "netfang",
		url: "vefsl",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO dagsetning og tmi",
		date: "ISO dagsetning",
		time: "ISO tmi",
		duration: "ISO tmalengd",
		ipv4: "IPv4 address",
		ipv6: "IPv6 address",
		cidrv4: "IPv4 range",
		cidrv6: "IPv6 range",
		base64: "base64-encoded strengur",
		base64url: "base64url-encoded strengur",
		json_string: "JSON strengur",
		e164: "E.164 tlugildi",
		jwt: "JWT",
		template_literal: "gildi"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nmer",
		array: "fylki"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue$1.expected}`;
				}
				return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue$1.values[0])}`;
				return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Of strt: gert er r fyrir a ${issue$1.origin ?? "gildi"} hafi ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "hluti"}`;
				return `Of strt: gert er r fyrir a ${issue$1.origin ?? "gildi"} s ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Of lti: gert er r fyrir a ${issue$1.origin} hafi ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Of lti: gert er r fyrir a ${issue$1.origin} s ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `gildur strengur: verur a enda  "${_issue.suffix}"`;
				if (_issue.format === "includes") return `gildur strengur: verur a innihalda "${_issue.includes}"`;
				if (_issue.format === "regex") return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
				return `Rangt ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Rng tala: verur a vera margfeldi af ${issue$1.divisor}`;
			case "unrecognized_keys": return `ekkt ${issue$1.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Rangur lykill  ${issue$1.origin}`;
			case "invalid_union": return "Rangt gildi";
			case "invalid_element": return `Rangt gildi  ${issue$1.origin}`;
			default: return `Rangt gildi`;
		}
	};
};
function is_default() {
	return { localeError: error$27() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/it.js
const error$26 = () => {
	const Sizable = {
		string: {
			unit: "caratteri",
			verb: "avere"
		},
		file: {
			unit: "byte",
			verb: "avere"
		},
		array: {
			unit: "elementi",
			verb: "avere"
		},
		set: {
			unit: "elementi",
			verb: "avere"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "indirizzo email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data e ora ISO",
		date: "data ISO",
		time: "ora ISO",
		duration: "durata ISO",
		ipv4: "indirizzo IPv4",
		ipv6: "indirizzo IPv6",
		cidrv4: "intervallo IPv4",
		cidrv6: "intervallo IPv6",
		base64: "stringa codificata in base64",
		base64url: "URL codificata in base64",
		json_string: "stringa JSON",
		e164: "numero E.164",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "numero",
		array: "vettore"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Input non valido: atteso instanceof ${issue$1.expected}, ricevuto ${received}`;
				}
				return `Input non valido: atteso ${expected}, ricevuto ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Input non valido: atteso ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opzione non valida: atteso uno tra ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Troppo grande: ${issue$1.origin ?? "valore"} deve avere ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementi"}`;
				return `Troppo grande: ${issue$1.origin ?? "valore"} deve essere ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Troppo piccolo: ${issue$1.origin} deve avere ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Troppo piccolo: ${issue$1.origin} deve essere ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Stringa non valida: deve includere "${_issue.includes}"`;
				if (_issue.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
				return `Invalid ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Numero non valido: deve essere un multiplo di ${issue$1.divisor}`;
			case "unrecognized_keys": return `Chiav${issue$1.keys.length > 1 ? "i" : "e"} non riconosciut${issue$1.keys.length > 1 ? "e" : "a"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Chiave non valida in ${issue$1.origin}`;
			case "invalid_union": return "Input non valido";
			case "invalid_element": return `Valore non valido in ${issue$1.origin}`;
			default: return `Input non valido`;
		}
	};
};
function it_default() {
	return { localeError: error$26() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ja.js
const error$25 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO",
		date: "ISO",
		time: "ISO",
		duration: "ISO",
		ipv4: "IPv4",
		ipv6: "IPv6",
		cidrv4: "IPv4",
		cidrv6: "IPv6",
		base64: "base64",
		base64url: "base64url",
		json_string: "JSON",
		e164: "E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `: instanceof ${issue$1.expected}${received}`;
				}
				return `: ${expected}${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `: ${stringifyPrimitive(issue$1.values[0])}`;
				return `: ${joinValues(issue$1.values, "")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `: ${issue$1.origin ?? ""}${issue$1.maximum.toString()}${sizing.unit ?? ""}${adj}`;
				return `: ${issue$1.origin ?? ""}${issue$1.maximum.toString()}${adj}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `: ${issue$1.origin}${issue$1.minimum.toString()}${sizing.unit}${adj}`;
				return `: ${issue$1.origin}${issue$1.minimum.toString()}${adj}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `: "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `: "${_issue.suffix}"`;
				if (_issue.format === "includes") return `: "${_issue.includes}"`;
				if (_issue.format === "regex") return `: ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `: ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, "")}`;
			case "invalid_key": return `${issue$1.origin}`;
			case "invalid_union": return "";
			case "invalid_element": return `${issue$1.origin}`;
			default: return ``;
		}
	};
};
function ja_default() {
	return { localeError: error$25() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ka.js
const error$24 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "- ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "-",
		date: "",
		time: "",
		duration: "",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64- ",
		base64url: "base64url- ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		string: "",
		boolean: "",
		function: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :  instanceof ${issue$1.expected},  ${received}`;
				}
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :  - ${joinValues(issue$1.values, "|")}-`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :  ${issue$1.origin ?? ""} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit}`;
				return ` :  ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` :  ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return ` :  ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` :   "${_issue.prefix}"-`;
				}
				if (_issue.format === "ends_with") return ` :   "${_issue.suffix}"-`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"-`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :   ${issue$1.divisor}- `;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `  ${issue$1.origin}-`;
			case "invalid_union": return " ";
			case "invalid_element": return `  ${issue$1.origin}-`;
			default: return ` `;
		}
	};
};
function ka_default() {
	return { localeError: error$24() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/km.js
const error$23 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "  ISO",
		date: " ISO",
		time: " ISO",
		duration: " ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: " IPv4",
		cidrv6: " IPv6",
		base64: " base64",
		base64url: " base64url",
		json_string: " JSON",
		e164: " E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: " (Array)",
		null: " (null)"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `  instanceof ${issue$1.expected}  ${received}`;
				}
				return `  ${expected}  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  ${stringifyPrimitive(issue$1.values[0])}`;
				return `  ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `  ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return `  ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `  ${issue$1.origin} ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `  ${issue$1.origin} ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `  "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `  "${_issue.suffix}"`;
				if (_issue.format === "includes") return `  "${_issue.includes}"`;
				if (_issue.format === "regex") return `  ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `  ${issue$1.divisor}`;
			case "unrecognized_keys": return ` ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return ` ${issue$1.origin}`;
			case "invalid_union": return ``;
			case "invalid_element": return ` ${issue$1.origin}`;
			default: return ``;
		}
	};
};
function km_default() {
	return { localeError: error$23() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/kh.js
/** @deprecated Use `km` instead. */
function kh_default() {
	return km_default();
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ko.js
const error$22 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: "to have"
		},
		file: {
			unit: "",
			verb: "to have"
		},
		array: {
			unit: "",
			verb: "to have"
		},
		set: {
			unit: "",
			verb: "to have"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64  ",
		base64url: "base64url  ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :   instanceof ${issue$1.expected},   ${received}`;
				}
				return ` :   ${expected},   ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}  `;
				return ` : ${joinValues(issue$1.values, " ")}   `;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "";
				const suffix = adj === "" ? " " : " ";
				const sizing = getSizing(issue$1.origin);
				const unit = sizing?.unit ?? "";
				if (sizing) return `${issue$1.origin ?? ""}  : ${issue$1.maximum.toString()}${unit} ${adj}${suffix}`;
				return `${issue$1.origin ?? ""}  : ${issue$1.maximum.toString()} ${adj}${suffix}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : "";
				const suffix = adj === "" ? " " : " ";
				const sizing = getSizing(issue$1.origin);
				const unit = sizing?.unit ?? "";
				if (sizing) {
					return `${issue$1.origin ?? ""}  : ${issue$1.minimum.toString()}${unit} ${adj}${suffix}`;
				}
				return `${issue$1.origin ?? ""}  : ${issue$1.minimum.toString()} ${adj}${suffix}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` : "${_issue.prefix}"()  `;
				}
				if (_issue.format === "ends_with") return ` : "${_issue.suffix}"()  `;
				if (_issue.format === "includes") return ` : "${_issue.includes}"()  `;
				if (_issue.format === "regex") return ` :  ${_issue.pattern}   `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` : ${issue$1.divisor}  `;
			case "unrecognized_keys": return `   : ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return ` : ${issue$1.origin}`;
			case "invalid_union": return ` `;
			case "invalid_element": return ` : ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function ko_default() {
	return { localeError: error$22() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/lt.js
const capitalizeFirstCharacter = (text) => {
	return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number$5) {
	const abs = Math.abs(number$5);
	const last = abs % 10;
	const last2 = abs % 100;
	if (last2 >= 11 && last2 <= 19 || last === 0) return "many";
	if (last === 1) return "one";
	return "few";
}
const error$21 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "simbolis",
				few: "simboliai",
				many: "simboli"
			},
			verb: {
				smaller: {
					inclusive: "turi bti ne ilgesn kaip",
					notInclusive: "turi bti trumpesn kaip"
				},
				bigger: {
					inclusive: "turi bti ne trumpesn kaip",
					notInclusive: "turi bti ilgesn kaip"
				}
			}
		},
		file: {
			unit: {
				one: "baitas",
				few: "baitai",
				many: "bait"
			},
			verb: {
				smaller: {
					inclusive: "turi bti ne didesnis kaip",
					notInclusive: "turi bti maesnis kaip"
				},
				bigger: {
					inclusive: "turi bti ne maesnis kaip",
					notInclusive: "turi bti didesnis kaip"
				}
			}
		},
		array: {
			unit: {
				one: "element",
				few: "elementus",
				many: "element"
			},
			verb: {
				smaller: {
					inclusive: "turi turti ne daugiau kaip",
					notInclusive: "turi turti maiau kaip"
				},
				bigger: {
					inclusive: "turi turti ne maiau kaip",
					notInclusive: "turi turti daugiau kaip"
				}
			}
		},
		set: {
			unit: {
				one: "element",
				few: "elementus",
				many: "element"
			},
			verb: {
				smaller: {
					inclusive: "turi turti ne daugiau kaip",
					notInclusive: "turi turti maiau kaip"
				},
				bigger: {
					inclusive: "turi turti ne maiau kaip",
					notInclusive: "turi turti daugiau kaip"
				}
			}
		}
	};
	function getSizing(origin, unitType, inclusive, targetShouldBe) {
		const result = Sizable[origin] ?? null;
		if (result === null) return result;
		return {
			unit: result.unit[unitType],
			verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
		};
	}
	const FormatDictionary = {
		regex: "vestis",
		email: "el. pato adresas",
		url: "URL",
		emoji: "jaustukas",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO data ir laikas",
		date: "ISO data",
		time: "ISO laikas",
		duration: "ISO trukm",
		ipv4: "IPv4 adresas",
		ipv6: "IPv6 adresas",
		cidrv4: "IPv4 tinklo prefiksas (CIDR)",
		cidrv6: "IPv6 tinklo prefiksas (CIDR)",
		base64: "base64 ukoduota eilut",
		base64url: "base64url ukoduota eilut",
		json_string: "JSON eilut",
		e164: "E.164 numeris",
		jwt: "JWT",
		template_literal: "vestis"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "skaiius",
		bigint: "sveikasis skaiius",
		string: "eilut",
		boolean: "login reikm",
		undefined: "neapibrta reikm",
		function: "funkcija",
		symbol: "simbolis",
		array: "masyvas",
		object: "objektas",
		null: "nulin reikm"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Gautas tipas ${received}, o tiktasi - instanceof ${issue$1.expected}`;
				}
				return `Gautas tipas ${received}, o tiktasi - ${expected}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Privalo bti ${stringifyPrimitive(issue$1.values[0])}`;
				return `Privalo bti vienas i ${joinValues(issue$1.values, "|")} pasirinkim`;
			case "too_big": {
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				const sizing = getSizing(issue$1.origin, getUnitTypeFromNumber(Number(issue$1.maximum)), issue$1.inclusive ?? false, "smaller");
				if (sizing?.verb) return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} ${sizing.verb} ${issue$1.maximum.toString()} ${sizing.unit ?? "element"}`;
				const adj = issue$1.inclusive ? "ne didesnis kaip" : "maesnis kaip";
				return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} turi bti ${adj} ${issue$1.maximum.toString()} ${sizing?.unit}`;
			}
			case "too_small": {
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				const sizing = getSizing(issue$1.origin, getUnitTypeFromNumber(Number(issue$1.minimum)), issue$1.inclusive ?? false, "bigger");
				if (sizing?.verb) return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} ${sizing.verb} ${issue$1.minimum.toString()} ${sizing.unit ?? "element"}`;
				const adj = issue$1.inclusive ? "ne maesnis kaip" : "didesnis kaip";
				return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} turi bti ${adj} ${issue$1.minimum.toString()} ${sizing?.unit}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `Eilut privalo prasidti "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `Eilut privalo pasibaigti "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Eilut privalo traukti "${_issue.includes}"`;
				if (_issue.format === "regex") return `Eilut privalo atitikti ${_issue.pattern}`;
				return `Neteisingas ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Skaiius privalo bti ${issue$1.divisor} kartotinis.`;
			case "unrecognized_keys": return `Neatpaint${issue$1.keys.length > 1 ? "i" : "as"} rakt${issue$1.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return "Rastas klaidingas raktas";
			case "invalid_union": return "Klaidinga vestis";
			case "invalid_element": {
				const origin = TypeDictionary[issue$1.origin] ?? issue$1.origin;
				return `${capitalizeFirstCharacter(origin ?? issue$1.origin ?? "reikm")} turi klaiding vest`;
			}
			default: return "Klaidinga vestis";
		}
	};
};
function lt_default() {
	return { localeError: error$21() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/mk.js
const error$20 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "  -",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64- ",
		base64url: "base64url- ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :   instanceof ${issue$1.expected},  ${received}`;
				}
				return ` :   ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` :   ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return ` :   ${issue$1.origin}   ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` :     "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return ` :     "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :    "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :      ${_issue.pattern}`;
				return `Invalid ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :      ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? " " : " "}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return " ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return ` `;
		}
	};
};
function mk_default() {
	return { localeError: error$20() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ms.js
const error$19 = () => {
	const Sizable = {
		string: {
			unit: "aksara",
			verb: "mempunyai"
		},
		file: {
			unit: "bait",
			verb: "mempunyai"
		},
		array: {
			unit: "elemen",
			verb: "mempunyai"
		},
		set: {
			unit: "elemen",
			verb: "mempunyai"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "alamat e-mel",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "tarikh masa ISO",
		date: "tarikh ISO",
		time: "masa ISO",
		duration: "tempoh ISO",
		ipv4: "alamat IPv4",
		ipv6: "alamat IPv6",
		cidrv4: "julat IPv4",
		cidrv6: "julat IPv6",
		base64: "string dikodkan base64",
		base64url: "string dikodkan base64url",
		json_string: "string JSON",
		e164: "nombor E.164",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nombor"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Input tidak sah: dijangka instanceof ${issue$1.expected}, diterima ${received}`;
				}
				return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Input tidak sah: dijangka ${stringifyPrimitive(issue$1.values[0])}`;
				return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Terlalu besar: dijangka ${issue$1.origin ?? "nilai"} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elemen"}`;
				return `Terlalu besar: dijangka ${issue$1.origin ?? "nilai"} adalah ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Terlalu kecil: dijangka ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Terlalu kecil: dijangka ${issue$1.origin} adalah ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
				if (_issue.format === "includes") return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
				if (_issue.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} tidak sah`;
			}
			case "not_multiple_of": return `Nombor tidak sah: perlu gandaan ${issue$1.divisor}`;
			case "unrecognized_keys": return `Kunci tidak dikenali: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Kunci tidak sah dalam ${issue$1.origin}`;
			case "invalid_union": return "Input tidak sah";
			case "invalid_element": return `Nilai tidak sah dalam ${issue$1.origin}`;
			default: return `Input tidak sah`;
		}
	};
};
function ms_default() {
	return { localeError: error$19() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/nl.js
const error$18 = () => {
	const Sizable = {
		string: {
			unit: "tekens",
			verb: "heeft"
		},
		file: {
			unit: "bytes",
			verb: "heeft"
		},
		array: {
			unit: "elementen",
			verb: "heeft"
		},
		set: {
			unit: "elementen",
			verb: "heeft"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "invoer",
		email: "emailadres",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datum en tijd",
		date: "ISO datum",
		time: "ISO tijd",
		duration: "ISO duur",
		ipv4: "IPv4-adres",
		ipv6: "IPv6-adres",
		cidrv4: "IPv4-bereik",
		cidrv6: "IPv6-bereik",
		base64: "base64-gecodeerde tekst",
		base64url: "base64 URL-gecodeerde tekst",
		json_string: "JSON string",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "invoer"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "getal"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Ongeldige invoer: verwacht instanceof ${issue$1.expected}, ontving ${received}`;
				}
				return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ongeldige optie: verwacht n van ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				const longName = issue$1.origin === "date" ? "laat" : issue$1.origin === "string" ? "lang" : "groot";
				if (sizing) return `Te ${longName}: verwacht dat ${issue$1.origin ?? "waarde"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
				return `Te ${longName}: verwacht dat ${issue$1.origin ?? "waarde"} ${adj}${issue$1.maximum.toString()} is`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				const shortName = issue$1.origin === "date" ? "vroeg" : issue$1.origin === "string" ? "kort" : "klein";
				if (sizing) {
					return `Te ${shortName}: verwacht dat ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
				}
				return `Te ${shortName}: verwacht dat ${issue$1.origin} ${adj}${issue$1.minimum.toString()} is`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
				}
				if (_issue.format === "ends_with") return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
				if (_issue.format === "includes") return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
				if (_issue.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
				return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ongeldig getal: moet een veelvoud van ${issue$1.divisor} zijn`;
			case "unrecognized_keys": return `Onbekende key${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ongeldige key in ${issue$1.origin}`;
			case "invalid_union": return "Ongeldige invoer";
			case "invalid_element": return `Ongeldige waarde in ${issue$1.origin}`;
			default: return `Ongeldige invoer`;
		}
	};
};
function nl_default() {
	return { localeError: error$18() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/no.js
const error$17 = () => {
	const Sizable = {
		string: {
			unit: "tegn",
			verb: " ha"
		},
		file: {
			unit: "bytes",
			verb: " ha"
		},
		array: {
			unit: "elementer",
			verb: " inneholde"
		},
		set: {
			unit: "elementer",
			verb: " inneholde"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "input",
		email: "e-postadresse",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO dato- og klokkeslett",
		date: "ISO-dato",
		time: "ISO-klokkeslett",
		duration: "ISO-varighet",
		ipv4: "IPv4-omrde",
		ipv6: "IPv6-omrde",
		cidrv4: "IPv4-spekter",
		cidrv6: "IPv6-spekter",
		base64: "base64-enkodet streng",
		base64url: "base64url-enkodet streng",
		json_string: "JSON-streng",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "tall",
		array: "liste"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Ugyldig input: forventet instanceof ${issue$1.expected}, fikk ${received}`;
				}
				return `Ugyldig input: forventet ${expected}, fikk ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ugyldig verdi: forventet ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ugyldig valg: forventet en av ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `For stor(t): forventet ${issue$1.origin ?? "value"} til  ha ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementer"}`;
				return `For stor(t): forventet ${issue$1.origin ?? "value"} til  ha ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `For lite(n): forventet ${issue$1.origin} til  ha ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `For lite(n): forventet ${issue$1.origin} til  ha ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Ugyldig streng: m starte med "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Ugyldig streng: m ende med "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Ugyldig streng: m inneholde "${_issue.includes}"`;
				if (_issue.format === "regex") return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
				return `Ugyldig ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ugyldig tall: m vre et multiplum av ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ugyldig nkkel i ${issue$1.origin}`;
			case "invalid_union": return "Ugyldig input";
			case "invalid_element": return `Ugyldig verdi i ${issue$1.origin}`;
			default: return `Ugyldig input`;
		}
	};
};
function no_default() {
	return { localeError: error$17() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ota.js
const error$16 = () => {
	const Sizable = {
		string: {
			unit: "harf",
			verb: "olmaldr"
		},
		file: {
			unit: "bayt",
			verb: "olmaldr"
		},
		array: {
			unit: "unsur",
			verb: "olmaldr"
		},
		set: {
			unit: "unsur",
			verb: "olmaldr"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "giren",
		email: "epostagh",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO hengm",
		date: "ISO tarihi",
		time: "ISO zaman",
		duration: "ISO mddeti",
		ipv4: "IPv4 nin",
		ipv6: "IPv6 nin",
		cidrv4: "IPv4 menzili",
		cidrv6: "IPv6 menzili",
		base64: "base64-ifreli metin",
		base64url: "base64url-ifreli metin",
		json_string: "JSON metin",
		e164: "E.164 says",
		jwt: "JWT",
		template_literal: "giren"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "numara",
		array: "saf",
		null: "gayb"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Fsit giren: umulan instanceof ${issue$1.expected}, alnan ${received}`;
				}
				return `Fsit giren: umulan ${expected}, alnan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Fsit giren: umulan ${stringifyPrimitive(issue$1.values[0])}`;
				return `Fsit tercih: mteberler ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Fazla byk: ${issue$1.origin ?? "value"}, ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
				return `Fazla byk: ${issue$1.origin ?? "value"}, ${adj}${issue$1.maximum.toString()} olmalyd.`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Fazla kk: ${issue$1.origin}, ${adj}${issue$1.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
				}
				return `Fazla kk: ${issue$1.origin}, ${adj}${issue$1.minimum.toString()} olmalyd.`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Fsit metin: "${_issue.prefix}" ile balamal.`;
				if (_issue.format === "ends_with") return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
				if (_issue.format === "includes") return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
				if (_issue.format === "regex") return `Fsit metin: ${_issue.pattern} nakna uymal.`;
				return `Fsit ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Fsit say: ${issue$1.divisor} kat olmalyd.`;
			case "unrecognized_keys": return `Tannmayan anahtar ${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} iin tannmayan anahtar var.`;
			case "invalid_union": return "Giren tannamad.";
			case "invalid_element": return `${issue$1.origin} iin tannmayan kymet var.`;
			default: return `Kymet tannamad.`;
		}
	};
};
function ota_default() {
	return { localeError: error$16() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ps.js
const error$15 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "  ",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "  ",
		date: "",
		time: "",
		duration: "",
		ipv4: " IPv4 ",
		ipv6: " IPv6 ",
		cidrv4: " IPv4 ",
		cidrv6: " IPv6 ",
		base64: "base64-encoded ",
		base64url: "base64url-encoded ",
		json_string: "JSON ",
		e164: " E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :  instanceof ${issue$1.expected} ,  ${received}  `;
				}
				return ` :  ${expected} ,  ${received}  `;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) {
					return ` :  ${stringifyPrimitive(issue$1.values[0])} `;
				}
				return ` :    ${joinValues(issue$1.values, "|")}  `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""} `;
				}
				return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit} `;
				}
				return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` :   "${_issue.prefix}"   `;
				}
				if (_issue.format === "ends_with") {
					return ` :   "${_issue.suffix}"    `;
				}
				if (_issue.format === "includes") {
					return ` :  "${_issue.includes}" `;
				}
				if (_issue.format === "regex") {
					return ` :   ${_issue.pattern}   `;
				}
				return `${FormatDictionary[_issue.format] ?? issue$1.format}  `;
			}
			case "not_multiple_of": return ` :   ${issue$1.divisor}  `;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin} `;
			case "invalid_union": return ` `;
			case "invalid_element": return `   ${issue$1.origin} `;
			default: return ` `;
		}
	};
};
function ps_default() {
	return { localeError: error$15() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/pl.js
const error$14 = () => {
	const Sizable = {
		string: {
			unit: "znakw",
			verb: "mie"
		},
		file: {
			unit: "bajtw",
			verb: "mie"
		},
		array: {
			unit: "elementw",
			verb: "mie"
		},
		set: {
			unit: "elementw",
			verb: "mie"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "wyraenie",
		email: "adres email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data i godzina w formacie ISO",
		date: "data w formacie ISO",
		time: "godzina w formacie ISO",
		duration: "czas trwania ISO",
		ipv4: "adres IPv4",
		ipv6: "adres IPv6",
		cidrv4: "zakres IPv4",
		cidrv6: "zakres IPv6",
		base64: "cig znakw zakodowany w formacie base64",
		base64url: "cig znakw zakodowany w formacie base64url",
		json_string: "cig znakw w formacie JSON",
		e164: "liczba E.164",
		jwt: "JWT",
		template_literal: "wejcie"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "liczba",
		array: "tablica"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue$1.expected}, otrzymano ${received}`;
				}
				return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue$1.values[0])}`;
				return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Za dua warto: oczekiwano, e ${issue$1.origin ?? "warto"} bdzie mie ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementw"}`;
				}
				return `Zbyt du(y/a/e): oczekiwano, e ${issue$1.origin ?? "warto"} bdzie wynosi ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Za maa warto: oczekiwano, e ${issue$1.origin ?? "warto"} bdzie mie ${adj}${issue$1.minimum.toString()} ${sizing.unit ?? "elementw"}`;
				}
				return `Zbyt ma(y/a/e): oczekiwano, e ${issue$1.origin ?? "warto"} bdzie wynosi ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
				if (_issue.format === "regex") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
				return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nieprawidowa liczba: musi by wielokrotnoci ${issue$1.divisor}`;
			case "unrecognized_keys": return `Nierozpoznane klucze${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Nieprawidowy klucz w ${issue$1.origin}`;
			case "invalid_union": return "Nieprawidowe dane wejciowe";
			case "invalid_element": return `Nieprawidowa warto w ${issue$1.origin}`;
			default: return `Nieprawidowe dane wejciowe`;
		}
	};
};
function pl_default() {
	return { localeError: error$14() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/pt.js
const error$13 = () => {
	const Sizable = {
		string: {
			unit: "caracteres",
			verb: "ter"
		},
		file: {
			unit: "bytes",
			verb: "ter"
		},
		array: {
			unit: "itens",
			verb: "ter"
		},
		set: {
			unit: "itens",
			verb: "ter"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "padro",
		email: "endereo de e-mail",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "data e hora ISO",
		date: "data ISO",
		time: "hora ISO",
		duration: "durao ISO",
		ipv4: "endereo IPv4",
		ipv6: "endereo IPv6",
		cidrv4: "faixa de IPv4",
		cidrv6: "faixa de IPv6",
		base64: "texto codificado em base64",
		base64url: "URL codificada em base64",
		json_string: "texto JSON",
		e164: "nmero E.164",
		jwt: "JWT",
		template_literal: "entrada"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nmero",
		null: "nulo"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Tipo invlido: esperado instanceof ${issue$1.expected}, recebido ${received}`;
				}
				return `Tipo invlido: esperado ${expected}, recebido ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Entrada invlida: esperado ${stringifyPrimitive(issue$1.values[0])}`;
				return `Opo invlida: esperada uma das ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Muito grande: esperado que ${issue$1.origin ?? "valor"} tivesse ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementos"}`;
				return `Muito grande: esperado que ${issue$1.origin ?? "valor"} fosse ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Muito pequeno: esperado que ${issue$1.origin} tivesse ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Muito pequeno: esperado que ${issue$1.origin} fosse ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Texto invlido: deve comear com "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Texto invlido: deve terminar com "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Texto invlido: deve incluir "${_issue.includes}"`;
				if (_issue.format === "regex") return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} invlido`;
			}
			case "not_multiple_of": return `Nmero invlido: deve ser mltiplo de ${issue$1.divisor}`;
			case "unrecognized_keys": return `Chave${issue$1.keys.length > 1 ? "s" : ""} desconhecida${issue$1.keys.length > 1 ? "s" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Chave invlida em ${issue$1.origin}`;
			case "invalid_union": return "Entrada invlida";
			case "invalid_element": return `Valor invlido em ${issue$1.origin}`;
			default: return `Campo invlido`;
		}
	};
};
function pt_default() {
	return { localeError: error$13() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
	const absCount = Math.abs(count);
	const lastDigit = absCount % 10;
	const lastTwoDigits = absCount % 100;
	if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
		return many;
	}
	if (lastDigit === 1) {
		return one;
	}
	if (lastDigit >= 2 && lastDigit <= 4) {
		return few;
	}
	return many;
}
const error$12 = () => {
	const Sizable = {
		string: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		file: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		array: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		},
		set: {
			unit: {
				one: "",
				few: "",
				many: ""
			},
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "email ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO   ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "   base64",
		base64url: "   base64url",
		json_string: "JSON ",
		e164: " E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :  instanceof ${issue$1.expected},  ${received}`;
				}
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const maxValue = Number(issue$1.maximum);
					const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return `  : ,  ${issue$1.origin ?? ""}   ${adj}${issue$1.maximum.toString()} ${unit}`;
				}
				return `  : ,  ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					const minValue = Number(issue$1.minimum);
					const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
					return `  : ,  ${issue$1.origin}   ${adj}${issue$1.minimum.toString()} ${unit}`;
				}
				return `  : ,  ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :    "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :    ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""} ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return "  ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return `  `;
		}
	};
};
function ru_default() {
	return { localeError: error$12() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/sl.js
const error$11 = () => {
	const Sizable = {
		string: {
			unit: "znakov",
			verb: "imeti"
		},
		file: {
			unit: "bajtov",
			verb: "imeti"
		},
		array: {
			unit: "elementov",
			verb: "imeti"
		},
		set: {
			unit: "elementov",
			verb: "imeti"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "vnos",
		email: "e-potni naslov",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO datum in as",
		date: "ISO datum",
		time: "ISO as",
		duration: "ISO trajanje",
		ipv4: "IPv4 naslov",
		ipv6: "IPv6 naslov",
		cidrv4: "obseg IPv4",
		cidrv6: "obseg IPv6",
		base64: "base64 kodiran niz",
		base64url: "base64url kodiran niz",
		json_string: "JSON niz",
		e164: "E.164 tevilka",
		jwt: "JWT",
		template_literal: "vnos"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "tevilo",
		array: "tabela"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Neveljaven vnos: priakovano instanceof ${issue$1.expected}, prejeto ${received}`;
				}
				return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue$1.values[0])}`;
				return `Neveljavna monost: priakovano eno izmed ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Preveliko: priakovano, da bo ${issue$1.origin ?? "vrednost"} imelo ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "elementov"}`;
				return `Preveliko: priakovano, da bo ${issue$1.origin ?? "vrednost"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Premajhno: priakovano, da bo ${issue$1.origin} imelo ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Premajhno: priakovano, da bo ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
				if (_issue.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
				return `Neveljaven ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Neveljavno tevilo: mora biti vekratnik ${issue$1.divisor}`;
			case "unrecognized_keys": return `Neprepoznan${issue$1.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Neveljaven klju v ${issue$1.origin}`;
			case "invalid_union": return "Neveljaven vnos";
			case "invalid_element": return `Neveljavna vrednost v ${issue$1.origin}`;
			default: return "Neveljaven vnos";
		}
	};
};
function sl_default() {
	return { localeError: error$11() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/sv.js
const error$10 = () => {
	const Sizable = {
		string: {
			unit: "tecken",
			verb: "att ha"
		},
		file: {
			unit: "bytes",
			verb: "att ha"
		},
		array: {
			unit: "objekt",
			verb: "att innehlla"
		},
		set: {
			unit: "objekt",
			verb: "att innehlla"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "reguljrt uttryck",
		email: "e-postadress",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO-datum och tid",
		date: "ISO-datum",
		time: "ISO-tid",
		duration: "ISO-varaktighet",
		ipv4: "IPv4-intervall",
		ipv6: "IPv6-intervall",
		cidrv4: "IPv4-spektrum",
		cidrv6: "IPv6-spektrum",
		base64: "base64-kodad strng",
		base64url: "base64url-kodad strng",
		json_string: "JSON-strng",
		e164: "E.164-nummer",
		jwt: "JWT",
		template_literal: "mall-literal"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "antal",
		array: "lista"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Ogiltig inmatning: frvntat instanceof ${issue$1.expected}, fick ${received}`;
				}
				return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ogiltigt val: frvntade en av ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Fr stor(t): frvntade ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "element"}`;
				}
				return `Fr stor(t): frvntat ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Fr lite(t): frvntade ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Fr lite(t): frvntade ${issue$1.origin ?? "vrdet"} att ha ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
				if (_issue.format === "regex") return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
				return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Ogiltigt tal: mste vara en multipel av ${issue$1.divisor}`;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Ogiltig nyckel i ${issue$1.origin ?? "vrdet"}`;
			case "invalid_union": return "Ogiltig input";
			case "invalid_element": return `Ogiltigt vrde i ${issue$1.origin ?? "vrdet"}`;
			default: return `Ogiltig input`;
		}
	};
};
function sv_default() {
	return { localeError: error$10() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ta.js
const error$9 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: " "
		},
		file: {
			unit: "",
			verb: " "
		},
		array: {
			unit: "",
			verb: " "
		},
		set: {
			unit: "",
			verb: " "
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: " ",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO  ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO  ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64-encoded ",
		base64url: "base64url-encoded ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: "input"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: "",
		null: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` :  instanceof ${issue$1.expected},  ${received}`;
				}
				return ` :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :  ${joinValues(issue$1.values, "|")}  `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` :  ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}   `;
				}
				return ` :  ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()}   `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` :  ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}   `;
				}
				return ` :  ${issue$1.origin} ${adj}${issue$1.minimum.toString()}   `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` : "${_issue.prefix}"   `;
				if (_issue.format === "ends_with") return ` : "${_issue.suffix}"   `;
				if (_issue.format === "includes") return ` : "${_issue.includes}"   `;
				if (_issue.format === "regex") return ` : ${_issue.pattern}   `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` : ${issue$1.divisor}    `;
			case "unrecognized_keys": return `  ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin}   `;
			case "invalid_union": return " ";
			case "invalid_element": return `${issue$1.origin}   `;
			default: return ` `;
		}
	};
};
function ta_default() {
	return { localeError: error$9() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/th.js
const error$8 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: " ISO",
		date: " ISO",
		time: " ISO",
		duration: " ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: " IP  IPv4",
		cidrv6: " IP  IPv6",
		base64: " Base64",
		base64url: " Base64  URL",
		json_string: " JSON",
		e164: " (E.164)",
		jwt: " JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: " (Array)",
		null: " (null)"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `:  instanceof ${issue$1.expected}  ${received}`;
				}
				return `:  ${expected}  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `:  ${stringifyPrimitive(issue$1.values[0])}`;
				return `:  ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `: ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return `: ${issue$1.origin ?? ""} ${adj} ${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? "" : "";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `: ${issue$1.origin} ${adj} ${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `: ${issue$1.origin} ${adj} ${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return `:  "${_issue.prefix}"`;
				}
				if (_issue.format === "ends_with") return `:  "${_issue.suffix}"`;
				if (_issue.format === "includes") return `:  "${_issue.includes}" `;
				if (_issue.format === "regex") return `:  ${_issue.pattern}`;
				return `: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `:  ${issue$1.divisor} `;
			case "unrecognized_keys": return `: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return ` ${issue$1.origin}`;
			case "invalid_union": return ": ";
			case "invalid_element": return ` ${issue$1.origin}`;
			default: return ``;
		}
	};
};
function th_default() {
	return { localeError: error$8() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/tr.js
const error$7 = () => {
	const Sizable = {
		string: {
			unit: "karakter",
			verb: "olmal"
		},
		file: {
			unit: "bayt",
			verb: "olmal"
		},
		array: {
			unit: "e",
			verb: "olmal"
		},
		set: {
			unit: "e",
			verb: "olmal"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "girdi",
		email: "e-posta adresi",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO tarih ve saat",
		date: "ISO tarih",
		time: "ISO saat",
		duration: "ISO sre",
		ipv4: "IPv4 adresi",
		ipv6: "IPv6 adresi",
		cidrv4: "IPv4 aral",
		cidrv6: "IPv6 aral",
		base64: "base64 ile ifrelenmi metin",
		base64url: "base64url ile ifrelenmi metin",
		json_string: "JSON dizesi",
		e164: "E.164 says",
		jwt: "JWT",
		template_literal: "ablon dizesi"
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Geersiz deer: beklenen instanceof ${issue$1.expected}, alnan ${received}`;
				}
				return `Geersiz deer: beklenen ${expected}, alnan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Geersiz deer: beklenen ${stringifyPrimitive(issue$1.values[0])}`;
				return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ok byk: beklenen ${issue$1.origin ?? "deer"} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "e"}`;
				return `ok byk: beklenen ${issue$1.origin ?? "deer"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `ok kk: beklenen ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				return `ok kk: beklenen ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Geersiz metin: "${_issue.prefix}" ile balamal`;
				if (_issue.format === "ends_with") return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
				if (_issue.format === "includes") return `Geersiz metin: "${_issue.includes}" iermeli`;
				if (_issue.format === "regex") return `Geersiz metin: ${_issue.pattern} desenine uymal`;
				return `Geersiz ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Geersiz say: ${issue$1.divisor} ile tam blnebilmeli`;
			case "unrecognized_keys": return `Tannmayan anahtar${issue$1.keys.length > 1 ? "lar" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} iinde geersiz anahtar`;
			case "invalid_union": return "Geersiz deer";
			case "invalid_element": return `${issue$1.origin} iinde geersiz deer`;
			default: return `Geersiz deer`;
		}
	};
};
function tr_default() {
	return { localeError: error$7() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/uk.js
const error$6 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: " ",
		email: "  ",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "   ISO",
		date: " ISO",
		time: " ISO",
		duration: " ISO",
		ipv4: " IPv4",
		ipv6: " IPv6",
		cidrv4: " IPv4",
		cidrv6: " IPv6",
		base64: "   base64",
		base64url: "   base64url",
		json_string: " JSON",
		e164: " E.164",
		jwt: "JWT",
		template_literal: " "
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `  :  instanceof ${issue$1.expected},  ${received}`;
				}
				return `  :  ${expected},  ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  :  ${stringifyPrimitive(issue$1.values[0])}`;
				return ` :    ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ,  ${issue$1.origin ?? ""} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` : ,  ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` : ,  ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return ` : ,  ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` :    "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return ` :    "${_issue.suffix}"`;
				if (_issue.format === "includes") return ` :   "${_issue.includes}"`;
				if (_issue.format === "regex") return ` :    ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` :    ${issue$1.divisor}`;
			case "unrecognized_keys": return ` ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `   ${issue$1.origin}`;
			case "invalid_union": return "  ";
			case "invalid_element": return `   ${issue$1.origin}`;
			default: return `  `;
		}
	};
};
function uk_default() {
	return { localeError: error$6() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ua.js
/** @deprecated Use `uk` instead. */
function ua_default() {
	return uk_default();
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/ur.js
const error$5 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: " ",
		email: "  ",
		url: "  ",
		emoji: "",
		uuid: "   ",
		uuidv4: "     4",
		uuidv6: "     6",
		nanoid: "  ",
		guid: "   ",
		cuid: "   ",
		cuid2: "    2",
		ulid: "   ",
		xid: "  ",
		ksuid: "    ",
		datetime: "    ",
		date: "   ",
		time: "   ",
		duration: "   ",
		ipv4: "   4 ",
		ipv6: "   6 ",
		cidrv4: "   4 ",
		cidrv6: "   6 ",
		base64: " 64   ",
		base64url: " 64      ",
		json_string: "    ",
		e164: " 164 ",
		jwt: "  ",
		template_literal: " "
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: "",
		null: ""
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `  : instanceof ${issue$1.expected}   ${received}  `;
				}
				return `  : ${expected}   ${received}  `;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `  : ${stringifyPrimitive(issue$1.values[0])}  `;
				return ` : ${joinValues(issue$1.values, "|")}     `;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}   `;
				return ` : ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}   `;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit}   `;
				}
				return ` : ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}   `;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` : "${_issue.prefix}"    `;
				}
				if (_issue.format === "ends_with") return ` : "${_issue.suffix}"    `;
				if (_issue.format === "includes") return ` : "${_issue.includes}"   `;
				if (_issue.format === "regex") return ` :  ${_issue.pattern}    `;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` : ${issue$1.divisor}    `;
			case "unrecognized_keys": return `   ${issue$1.keys.length > 1 ? "" : ""}: ${joinValues(issue$1.keys, " ")}`;
			case "invalid_key": return `${issue$1.origin}   `;
			case "invalid_union": return "  ";
			case "invalid_element": return `${issue$1.origin}   `;
			default: return `  `;
		}
	};
};
function ur_default() {
	return { localeError: error$5() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/uz.js
const error$4 = () => {
	const Sizable = {
		string: {
			unit: "belgi",
			verb: "bolishi kerak"
		},
		file: {
			unit: "bayt",
			verb: "bolishi kerak"
		},
		array: {
			unit: "element",
			verb: "bolishi kerak"
		},
		set: {
			unit: "element",
			verb: "bolishi kerak"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "kirish",
		email: "elektron pochta manzili",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO sana va vaqti",
		date: "ISO sana",
		time: "ISO vaqt",
		duration: "ISO davomiylik",
		ipv4: "IPv4 manzil",
		ipv6: "IPv6 manzil",
		mac: "MAC manzil",
		cidrv4: "IPv4 diapazon",
		cidrv6: "IPv6 diapazon",
		base64: "base64 kodlangan satr",
		base64url: "base64url kodlangan satr",
		json_string: "JSON satr",
		e164: "E.164 raqam",
		jwt: "JWT",
		template_literal: "kirish"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "raqam",
		array: "massiv"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `Notogri kirish: kutilgan instanceof ${issue$1.expected}, qabul qilingan ${received}`;
				}
				return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `Notogri kirish: kutilgan ${stringifyPrimitive(issue$1.values[0])}`;
				return `Notogri variant: quyidagilardan biri kutilgan ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Juda katta: kutilgan ${issue$1.origin ?? "qiymat"} ${adj}${issue$1.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
				return `Juda katta: kutilgan ${issue$1.origin ?? "qiymat"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Juda kichik: kutilgan ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
				}
				return `Juda kichik: kutilgan ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Notogri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
				if (_issue.format === "ends_with") return `Notogri satr: "${_issue.suffix}" bilan tugashi kerak`;
				if (_issue.format === "includes") return `Notogri satr: "${_issue.includes}" ni oz ichiga olishi kerak`;
				if (_issue.format === "regex") return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
				return `Notogri ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Notogri raqam: ${issue$1.divisor} ning karralisi bolishi kerak`;
			case "unrecognized_keys": return `Nomalum kalit${issue$1.keys.length > 1 ? "lar" : ""}: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} dagi kalit notogri`;
			case "invalid_union": return "Notogri kirish";
			case "invalid_element": return `${issue$1.origin} da notogri qiymat`;
			default: return `Notogri kirish`;
		}
	};
};
function uz_default() {
	return { localeError: error$4() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/vi.js
const error$3 = () => {
	const Sizable = {
		string: {
			unit: "k t",
			verb: "c"
		},
		file: {
			unit: "byte",
			verb: "c"
		},
		array: {
			unit: "phn t",
			verb: "c"
		},
		set: {
			unit: "phn t",
			verb: "c"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "u vo",
		email: "a ch email",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ngy gi ISO",
		date: "ngy ISO",
		time: "gi ISO",
		duration: "khong thi gian ISO",
		ipv4: "a ch IPv4",
		ipv6: "a ch IPv6",
		cidrv4: "di IPv4",
		cidrv6: "di IPv6",
		base64: "chui m ha base64",
		base64url: "chui m ha base64url",
		json_string: "chui JSON",
		e164: "s E.164",
		jwt: "JWT",
		template_literal: "u vo"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "s",
		array: "mng"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `u vo khng hp l: mong i instanceof ${issue$1.expected}, nhn c ${received}`;
				}
				return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `u vo khng hp l: mong i ${stringifyPrimitive(issue$1.values[0])}`;
				return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Qu ln: mong i ${issue$1.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? "phn t"}`;
				return `Qu ln: mong i ${issue$1.origin ?? "gi tr"} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return `Qu nh: mong i ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return `Qu nh: mong i ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
				if (_issue.format === "includes") return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
				if (_issue.format === "regex") return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format} khng hp l`;
			}
			case "not_multiple_of": return `S khng hp l: phi l bi s ca ${issue$1.divisor}`;
			case "unrecognized_keys": return `Kha khng c nhn dng: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Kha khng hp l trong ${issue$1.origin}`;
			case "invalid_union": return "u vo khng hp l";
			case "invalid_element": return `Gi tr khng hp l trong ${issue$1.origin}`;
			default: return `u vo khng hp l`;
		}
	};
};
function vi_default() {
	return { localeError: error$3() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/zh-CN.js
const error$2 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO",
		date: "ISO",
		time: "ISO",
		duration: "ISO",
		ipv4: "IPv4",
		ipv6: "IPv6",
		cidrv4: "IPv4",
		cidrv6: "IPv6",
		base64: "base64",
		base64url: "base64url",
		json_string: "JSON",
		e164: "E.164",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "",
		array: "",
		null: "(null)"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` instanceof ${issue$1.expected} ${received}`;
				}
				return ` ${expected} ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` ${stringifyPrimitive(issue$1.values[0])}`;
				return ` ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` ${issue$1.origin ?? ""} ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` ${issue$1.origin} ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return ` ${issue$1.origin} ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return ` "${_issue.prefix}" `;
				if (_issue.format === "ends_with") return ` "${_issue.suffix}" `;
				if (_issue.format === "includes") return ` "${_issue.includes}"`;
				if (_issue.format === "regex") return ` ${_issue.pattern}`;
				return `${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` ${issue$1.divisor} `;
			case "unrecognized_keys": return `(key): ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `${issue$1.origin} (key)`;
			case "invalid_union": return "";
			case "invalid_element": return `${issue$1.origin} (value)`;
			default: return ``;
		}
	};
};
function zh_CN_default() {
	return { localeError: error$2() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/zh-TW.js
const error$1 = () => {
	const Sizable = {
		string: {
			unit: "",
			verb: ""
		},
		file: {
			unit: "",
			verb: ""
		},
		array: {
			unit: "",
			verb: ""
		},
		set: {
			unit: "",
			verb: ""
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "",
		email: "",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "ISO ",
		date: "ISO ",
		time: "ISO ",
		duration: "ISO ",
		ipv4: "IPv4 ",
		ipv6: "IPv6 ",
		cidrv4: "IPv4 ",
		cidrv6: "IPv6 ",
		base64: "base64 ",
		base64url: "base64url ",
		json_string: "JSON ",
		e164: "E.164 ",
		jwt: "JWT",
		template_literal: ""
	};
	const TypeDictionary = { nan: "NaN" };
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return ` instanceof ${issue$1.expected} ${received}`;
				}
				return ` ${expected} ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return ` ${stringifyPrimitive(issue$1.values[0])}`;
				return ` ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return ` ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()} ${sizing.unit ?? ""}`;
				return ` ${issue$1.origin ?? ""}  ${adj}${issue$1.maximum.toString()}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) {
					return ` ${issue$1.origin}  ${adj}${issue$1.minimum.toString()} ${sizing.unit}`;
				}
				return ` ${issue$1.origin}  ${adj}${issue$1.minimum.toString()}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") {
					return ` "${_issue.prefix}" `;
				}
				if (_issue.format === "ends_with") return ` "${_issue.suffix}" `;
				if (_issue.format === "includes") return ` "${_issue.includes}"`;
				if (_issue.format === "regex") return ` ${_issue.pattern}`;
				return ` ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return ` ${issue$1.divisor} `;
			case "unrecognized_keys": return `${issue$1.keys.length > 1 ? "" : ""}${joinValues(issue$1.keys, "")}`;
			case "invalid_key": return `${issue$1.origin} `;
			case "invalid_union": return "";
			case "invalid_element": return `${issue$1.origin} `;
			default: return ``;
		}
	};
};
function zh_TW_default() {
	return { localeError: error$1() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/yo.js
const error = () => {
	const Sizable = {
		string: {
			unit: "mi",
			verb: "n"
		},
		file: {
			unit: "bytes",
			verb: "n"
		},
		array: {
			unit: "nkan",
			verb: "n"
		},
		set: {
			unit: "nkan",
			verb: "n"
		}
	};
	function getSizing(origin) {
		return Sizable[origin] ?? null;
	}
	const FormatDictionary = {
		regex: "r bwl",
		email: "drs ml",
		url: "URL",
		emoji: "emoji",
		uuid: "UUID",
		uuidv4: "UUIDv4",
		uuidv6: "UUIDv6",
		nanoid: "nanoid",
		guid: "GUID",
		cuid: "cuid",
		cuid2: "cuid2",
		ulid: "ULID",
		xid: "XID",
		ksuid: "KSUID",
		datetime: "kk ISO",
		date: "j ISO",
		time: "kk ISO",
		duration: "kk t p ISO",
		ipv4: "drs IPv4",
		ipv6: "drs IPv6",
		cidrv4: "gbgb IPv4",
		cidrv6: "gbgb IPv6",
		base64: "r t a k n base64",
		base64url: "r base64url",
		json_string: "r JSON",
		e164: "nmb E.164",
		jwt: "JWT",
		template_literal: "r bwl"
	};
	const TypeDictionary = {
		nan: "NaN",
		number: "nmb",
		array: "akop"
	};
	return (issue$1) => {
		switch (issue$1.code) {
			case "invalid_type": {
				const expected = TypeDictionary[issue$1.expected] ?? issue$1.expected;
				const receivedType = parsedType(issue$1.input);
				const received = TypeDictionary[receivedType] ?? receivedType;
				if (/^[A-Z]/.test(issue$1.expected)) {
					return `bwl ae: a n lti fi instanceof ${issue$1.expected}, m a r ${received}`;
				}
				return `bwl ae: a n lti fi ${expected}, m a r ${received}`;
			}
			case "invalid_value":
				if (issue$1.values.length === 1) return `bwl ae: a n lti fi ${stringifyPrimitive(issue$1.values[0])}`;
				return `yn ae: yan kan lra ${joinValues(issue$1.values, "|")}`;
			case "too_big": {
				const adj = issue$1.inclusive ? "<=" : "<";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `T p j: a n lti j p ${issue$1.origin ?? "iye"} ${sizing.verb} ${adj}${issue$1.maximum} ${sizing.unit}`;
				return `T p j: a n lti j ${adj}${issue$1.maximum}`;
			}
			case "too_small": {
				const adj = issue$1.inclusive ? ">=" : ">";
				const sizing = getSizing(issue$1.origin);
				if (sizing) return `Kr ju: a n lti j p ${issue$1.origin} ${sizing.verb} ${adj}${issue$1.minimum} ${sizing.unit}`;
				return `Kr ju: a n lti j ${adj}${issue$1.minimum}`;
			}
			case "invalid_format": {
				const _issue = issue$1;
				if (_issue.format === "starts_with") return `r ae: gbd br pl "${_issue.prefix}"`;
				if (_issue.format === "ends_with") return `r ae: gbd par pl "${_issue.suffix}"`;
				if (_issue.format === "includes") return `r ae: gbd n "${_issue.includes}"`;
				if (_issue.format === "regex") return `r ae: gbd b pr mu ${_issue.pattern}`;
				return `Ae: ${FormatDictionary[_issue.format] ?? issue$1.format}`;
			}
			case "not_multiple_of": return `Nmb ae: gbd j y ppn ti ${issue$1.divisor}`;
			case "unrecognized_keys": return `Btn m: ${joinValues(issue$1.keys, ", ")}`;
			case "invalid_key": return `Btn ae nn ${issue$1.origin}`;
			case "invalid_union": return "bwl ae";
			case "invalid_element": return `Iye ae nn ${issue$1.origin}`;
			default: return "bwl ae";
		}
	};
};
function yo_default() {
	return { localeError: error() };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/locales/index.js
var locales_exports = /* @__PURE__ */ __exportAll({
	ar: () => ar_default,
	az: () => az_default,
	be: () => be_default,
	bg: () => bg_default,
	ca: () => ca_default,
	cs: () => cs_default,
	da: () => da_default,
	de: () => de_default,
	en: () => en_default$1,
	eo: () => eo_default,
	es: () => es_default,
	fa: () => fa_default,
	fi: () => fi_default,
	fr: () => fr_default,
	frCA: () => fr_CA_default,
	he: () => he_default,
	hu: () => hu_default,
	hy: () => hy_default,
	id: () => id_default,
	is: () => is_default,
	it: () => it_default,
	ja: () => ja_default,
	ka: () => ka_default,
	kh: () => kh_default,
	km: () => km_default,
	ko: () => ko_default,
	lt: () => lt_default,
	mk: () => mk_default,
	ms: () => ms_default,
	nl: () => nl_default,
	no: () => no_default,
	ota: () => ota_default,
	pl: () => pl_default,
	ps: () => ps_default,
	pt: () => pt_default,
	ru: () => ru_default,
	sl: () => sl_default,
	sv: () => sv_default,
	ta: () => ta_default,
	th: () => th_default,
	tr: () => tr_default,
	ua: () => ua_default,
	uk: () => uk_default,
	ur: () => ur_default,
	uz: () => uz_default,
	vi: () => vi_default,
	yo: () => yo_default,
	zhCN: () => zh_CN_default,
	zhTW: () => zh_TW_default
});

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/registries.js
var _a;
const $output = Symbol("ZodOutput");
const $input = Symbol("ZodInput");
var $ZodRegistry = class {
	constructor() {
		this._map = new WeakMap();
		this._idmap = new Map();
	}
	add(schema, ..._meta) {
		const meta$3 = _meta[0];
		this._map.set(schema, meta$3);
		if (meta$3 && typeof meta$3 === "object" && "id" in meta$3) {
			this._idmap.set(meta$3.id, schema);
		}
		return this;
	}
	clear() {
		this._map = new WeakMap();
		this._idmap = new Map();
		return this;
	}
	remove(schema) {
		const meta$3 = this._map.get(schema);
		if (meta$3 && typeof meta$3 === "object" && "id" in meta$3) {
			this._idmap.delete(meta$3.id);
		}
		this._map.delete(schema);
		return this;
	}
	get(schema) {
		const p = schema._zod.parent;
		if (p) {
			const pm = { ...this.get(p) ?? {} };
			delete pm.id;
			const f = {
				...pm,
				...this._map.get(schema)
			};
			return Object.keys(f).length ? f : undefined;
		}
		return this._map.get(schema);
	}
	has(schema) {
		return this._map.has(schema);
	}
};
function registry() {
	return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/api.js
/* @__NO_SIDE_EFFECTS__ */
function _string(Class$3, params) {
	return new Class$3({
		type: "string",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedString(Class$3, params) {
	return new Class$3({
		type: "string",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _email(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "email",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _guid(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "guid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuid(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv4(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v4",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv6(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v6",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv7(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v7",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _url$1(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _emoji(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "emoji",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nanoid(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "nanoid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cuid(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "cuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cuid2(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "cuid2",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ulid(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "ulid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _xid(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "xid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ksuid(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "ksuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ipv4(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "ipv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ipv6(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "ipv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _mac(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "mac",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cidrv4(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "cidrv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cidrv6(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "cidrv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _base64(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "base64",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _base64url(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "base64url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _e164(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "e164",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _jwt(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "jwt",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
const TimePrecision = {
	Any: null,
	Minute: -1,
	Second: 0,
	Millisecond: 3,
	Microsecond: 6
};
/* @__NO_SIDE_EFFECTS__ */
function _isoDateTime(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "datetime",
		check: "string_format",
		offset: false,
		local: false,
		precision: null,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoDate(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "date",
		check: "string_format",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoTime(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "time",
		check: "string_format",
		precision: null,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoDuration(Class$3, params) {
	return new Class$3({
		type: "string",
		format: "duration",
		check: "string_format",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _number(Class$3, params) {
	return new Class$3({
		type: "number",
		checks: [],
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedNumber(Class$3, params) {
	return new Class$3({
		type: "number",
		coerce: true,
		checks: [],
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _int(Class$3, params) {
	return new Class$3({
		type: "number",
		check: "number_format",
		abort: false,
		format: "safeint",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _float32(Class$3, params) {
	return new Class$3({
		type: "number",
		check: "number_format",
		abort: false,
		format: "float32",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _float64(Class$3, params) {
	return new Class$3({
		type: "number",
		check: "number_format",
		abort: false,
		format: "float64",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _int32(Class$3, params) {
	return new Class$3({
		type: "number",
		check: "number_format",
		abort: false,
		format: "int32",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uint32(Class$3, params) {
	return new Class$3({
		type: "number",
		check: "number_format",
		abort: false,
		format: "uint32",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _boolean(Class$3, params) {
	return new Class$3({
		type: "boolean",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedBoolean(Class$3, params) {
	return new Class$3({
		type: "boolean",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _bigint(Class$3, params) {
	return new Class$3({
		type: "bigint",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedBigint(Class$3, params) {
	return new Class$3({
		type: "bigint",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _int64(Class$3, params) {
	return new Class$3({
		type: "bigint",
		check: "bigint_format",
		abort: false,
		format: "int64",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uint64(Class$3, params) {
	return new Class$3({
		type: "bigint",
		check: "bigint_format",
		abort: false,
		format: "uint64",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _symbol(Class$3, params) {
	return new Class$3({
		type: "symbol",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _undefined$2(Class$3, params) {
	return new Class$3({
		type: "undefined",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _null$2(Class$3, params) {
	return new Class$3({
		type: "null",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _any(Class$3) {
	return new Class$3({ type: "any" });
}
/* @__NO_SIDE_EFFECTS__ */
function _unknown(Class$3) {
	return new Class$3({ type: "unknown" });
}
/* @__NO_SIDE_EFFECTS__ */
function _never(Class$3, params) {
	return new Class$3({
		type: "never",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _void$2(Class$3, params) {
	return new Class$3({
		type: "void",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _date(Class$3, params) {
	return new Class$3({
		type: "date",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _coercedDate(Class$3, params) {
	return new Class$3({
		type: "date",
		coerce: true,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nan(Class$3, params) {
	return new Class$3({
		type: "nan",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lt(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lte(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _gt(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _gte(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _positive(params) {
	return /* @__PURE__ */ _gt(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _negative(params) {
	return /* @__PURE__ */ _lt(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _nonpositive(params) {
	return /* @__PURE__ */ _lte(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _nonnegative(params) {
	return /* @__PURE__ */ _gte(0, params);
}
/* @__NO_SIDE_EFFECTS__ */
function _multipleOf(value, params) {
	return new $ZodCheckMultipleOf({
		check: "multiple_of",
		...normalizeParams(params),
		value
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _maxSize(maximum, params) {
	return new $ZodCheckMaxSize({
		check: "max_size",
		...normalizeParams(params),
		maximum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _minSize(minimum, params) {
	return new $ZodCheckMinSize({
		check: "min_size",
		...normalizeParams(params),
		minimum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _size(size, params) {
	return new $ZodCheckSizeEquals({
		check: "size_equals",
		...normalizeParams(params),
		size
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _maxLength(maximum, params) {
	const ch = new $ZodCheckMaxLength({
		check: "max_length",
		...normalizeParams(params),
		maximum
	});
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function _minLength(minimum, params) {
	return new $ZodCheckMinLength({
		check: "min_length",
		...normalizeParams(params),
		minimum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _length(length, params) {
	return new $ZodCheckLengthEquals({
		check: "length_equals",
		...normalizeParams(params),
		length
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _regex(pattern, params) {
	return new $ZodCheckRegex({
		check: "string_format",
		format: "regex",
		...normalizeParams(params),
		pattern
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lowercase(params) {
	return new $ZodCheckLowerCase({
		check: "string_format",
		format: "lowercase",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uppercase(params) {
	return new $ZodCheckUpperCase({
		check: "string_format",
		format: "uppercase",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _includes(includes, params) {
	return new $ZodCheckIncludes({
		check: "string_format",
		format: "includes",
		...normalizeParams(params),
		includes
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _startsWith(prefix, params) {
	return new $ZodCheckStartsWith({
		check: "string_format",
		format: "starts_with",
		...normalizeParams(params),
		prefix
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _endsWith(suffix, params) {
	return new $ZodCheckEndsWith({
		check: "string_format",
		format: "ends_with",
		...normalizeParams(params),
		suffix
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _property(property, schema, params) {
	return new $ZodCheckProperty({
		check: "property",
		property,
		schema,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _mime(types, params) {
	return new $ZodCheckMimeType({
		check: "mime_type",
		mime: types,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _overwrite(tx) {
	return new $ZodCheckOverwrite({
		check: "overwrite",
		tx
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _normalize(form) {
	return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
/* @__NO_SIDE_EFFECTS__ */
function _trim() {
	return /* @__PURE__ */ _overwrite((input) => input.trim());
}
/* @__NO_SIDE_EFFECTS__ */
function _toLowerCase() {
	return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
/* @__NO_SIDE_EFFECTS__ */
function _toUpperCase() {
	return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
/* @__NO_SIDE_EFFECTS__ */
function _slugify() {
	return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
/* @__NO_SIDE_EFFECTS__ */
function _array(Class$3, element, params) {
	return new Class$3({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _union(Class$3, options, params) {
	return new Class$3({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
function _xor(Class$3, options, params) {
	return new Class$3({
		type: "union",
		options,
		inclusive: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _discriminatedUnion(Class$3, discriminator, options, params) {
	return new Class$3({
		type: "union",
		options,
		discriminator,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _intersection(Class$3, left, right) {
	return new Class$3({
		type: "intersection",
		left,
		right
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _tuple(Class$3, items, _paramsOrRest, _params) {
	const hasRest = _paramsOrRest instanceof $ZodType;
	const params = hasRest ? _params : _paramsOrRest;
	const rest = hasRest ? _paramsOrRest : null;
	return new Class$3({
		type: "tuple",
		items,
		rest,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _record(Class$3, keyType, valueType, params) {
	return new Class$3({
		type: "record",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _map(Class$3, keyType, valueType, params) {
	return new Class$3({
		type: "map",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _set(Class$3, valueType, params) {
	return new Class$3({
		type: "set",
		valueType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _enum$2(Class$3, values, params) {
	const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
	return new Class$3({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
*
* ```ts
* enum Colors { red, green, blue }
* z.enum(Colors);
* ```
*/
/* @__NO_SIDE_EFFECTS__ */
function _nativeEnum(Class$3, entries, params) {
	return new Class$3({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _literal(Class$3, value, params) {
	return new Class$3({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _file(Class$3, params) {
	return new Class$3({
		type: "file",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _transform(Class$3, fn) {
	return new Class$3({
		type: "transform",
		transform: fn
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _optional(Class$3, innerType) {
	return new Class$3({
		type: "optional",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nullable(Class$3, innerType) {
	return new Class$3({
		type: "nullable",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _default$2(Class$3, innerType, defaultValue) {
	return new Class$3({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nonoptional(Class$3, innerType, params) {
	return new Class$3({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _success(Class$3, innerType) {
	return new Class$3({
		type: "success",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _catch$2(Class$3, innerType, catchValue) {
	return new Class$3({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _pipe(Class$3, in_, out) {
	return new Class$3({
		type: "pipe",
		in: in_,
		out
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _readonly(Class$3, innerType) {
	return new Class$3({
		type: "readonly",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _templateLiteral(Class$3, parts, params) {
	return new Class$3({
		type: "template_literal",
		parts,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lazy$1(Class$3, getter) {
	return new Class$3({
		type: "lazy",
		getter
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _promise(Class$3, innerType) {
	return new Class$3({
		type: "promise",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _custom(Class$3, fn, _params) {
	const norm = normalizeParams(_params);
	norm.abort ?? (norm.abort = true);
	const schema = new Class$3({
		type: "custom",
		check: "custom",
		fn,
		...norm
	});
	return schema;
}
/* @__NO_SIDE_EFFECTS__ */
function _refine(Class$3, fn, _params) {
	const schema = new Class$3({
		type: "custom",
		check: "custom",
		fn,
		...normalizeParams(_params)
	});
	return schema;
}
/* @__NO_SIDE_EFFECTS__ */
function _superRefine(fn) {
	const ch = /* @__PURE__ */ _check((payload) => {
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") {
				payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
			} else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = ch);
				_issue.continue ?? (_issue.continue = !ch._zod.def.abort);
				payload.issues.push(issue(_issue));
			}
		};
		return fn(payload.value, payload);
	});
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function _check(fn, params) {
	const ch = new $ZodCheck({
		check: "custom",
		...normalizeParams(params)
	});
	ch._zod.check = fn;
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function describe$2(description) {
	const ch = new $ZodCheck({ check: "describe" });
	ch._zod.onattach = [(inst) => {
		const existing = globalRegistry.get(inst) ?? {};
		globalRegistry.add(inst, {
			...existing,
			description
		});
	}];
	ch._zod.check = () => {};
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function meta$2(metadata) {
	const ch = new $ZodCheck({ check: "meta" });
	ch._zod.onattach = [(inst) => {
		const existing = globalRegistry.get(inst) ?? {};
		globalRegistry.add(inst, {
			...existing,
			...metadata
		});
	}];
	ch._zod.check = () => {};
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function _stringbool(Classes, _params) {
	const params = normalizeParams(_params);
	let truthyArray = params.truthy ?? [
		"true",
		"1",
		"yes",
		"on",
		"y",
		"enabled"
	];
	let falsyArray = params.falsy ?? [
		"false",
		"0",
		"no",
		"off",
		"n",
		"disabled"
	];
	if (params.case !== "sensitive") {
		truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
		falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
	}
	const truthySet = new Set(truthyArray);
	const falsySet = new Set(falsyArray);
	const _Codec = Classes.Codec ?? $ZodCodec;
	const _Boolean = Classes.Boolean ?? $ZodBoolean;
	const _String = Classes.String ?? $ZodString;
	const stringSchema = new _String({
		type: "string",
		error: params.error
	});
	const booleanSchema = new _Boolean({
		type: "boolean",
		error: params.error
	});
	const codec$2 = new _Codec({
		type: "pipe",
		in: stringSchema,
		out: booleanSchema,
		transform: ((input, payload) => {
			let data = input;
			if (params.case !== "sensitive") data = data.toLowerCase();
			if (truthySet.has(data)) {
				return true;
			} else if (falsySet.has(data)) {
				return false;
			} else {
				payload.issues.push({
					code: "invalid_value",
					expected: "stringbool",
					values: [...truthySet, ...falsySet],
					input: payload.value,
					inst: codec$2,
					continue: false
				});
				return {};
			}
		}),
		reverseTransform: ((input, _payload) => {
			if (input === true) {
				return truthyArray[0] || "true";
			} else {
				return falsyArray[0] || "false";
			}
		}),
		error: params.error
	});
	return codec$2;
}
/* @__NO_SIDE_EFFECTS__ */
function _stringFormat(Class$3, format$2, fnOrRegex, _params = {}) {
	const params = normalizeParams(_params);
	const def = {
		...normalizeParams(_params),
		check: "string_format",
		type: "string",
		format: format$2,
		fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
		...params
	};
	if (fnOrRegex instanceof RegExp) {
		def.pattern = fnOrRegex;
	}
	const inst = new Class$3(def);
	return inst;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
	let target = params?.target ?? "draft-2020-12";
	if (target === "draft-4") target = "draft-04";
	if (target === "draft-7") target = "draft-07";
	return {
		processors: params.processors ?? {},
		metadataRegistry: params?.metadata ?? globalRegistry,
		target,
		unrepresentable: params?.unrepresentable ?? "throw",
		override: params?.override ?? (() => {}),
		io: params?.io ?? "output",
		counter: 0,
		seen: new Map(),
		cycles: params?.cycles ?? "ref",
		reused: params?.reused ?? "inline",
		external: params?.external ?? undefined
	};
}
function process$2(schema, ctx, _params = {
	path: [],
	schemaPath: []
}) {
	var _a$1;
	const def = schema._zod.def;
	const seen = ctx.seen.get(schema);
	if (seen) {
		seen.count++;
		const isCycle = _params.schemaPath.includes(schema);
		if (isCycle) {
			seen.cycle = _params.path;
		}
		return seen.schema;
	}
	const result = {
		schema: {},
		count: 1,
		cycle: undefined,
		path: _params.path
	};
	ctx.seen.set(schema, result);
	const overrideSchema = schema._zod.toJSONSchema?.();
	if (overrideSchema) {
		result.schema = overrideSchema;
	} else {
		const params = {
			..._params,
			schemaPath: [..._params.schemaPath, schema],
			path: _params.path
		};
		if (schema._zod.processJSONSchema) {
			schema._zod.processJSONSchema(ctx, result.schema, params);
		} else {
			const _json = result.schema;
			const processor = ctx.processors[def.type];
			if (!processor) {
				throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
			}
			processor(schema, ctx, _json, params);
		}
		const parent = schema._zod.parent;
		if (parent) {
			if (!result.ref) result.ref = parent;
			process$2(parent, ctx, params);
			ctx.seen.get(parent).isParent = true;
		}
	}
	const meta$3 = ctx.metadataRegistry.get(schema);
	if (meta$3) Object.assign(result.schema, meta$3);
	if (ctx.io === "input" && isTransforming(schema)) {
		delete result.schema.examples;
		delete result.schema.default;
	}
	if (ctx.io === "input" && result.schema._prefault) (_a$1 = result.schema).default ?? (_a$1.default = result.schema._prefault);
	delete result.schema._prefault;
	const _result = ctx.seen.get(schema);
	return _result.schema;
}
function extractDefs(ctx, schema) {
	const root = ctx.seen.get(schema);
	if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const idToSchema = new Map();
	for (const entry of ctx.seen.entries()) {
		const id = ctx.metadataRegistry.get(entry[0])?.id;
		if (id) {
			const existing = idToSchema.get(id);
			if (existing && existing !== entry[0]) {
				throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
			}
			idToSchema.set(id, entry[0]);
		}
	}
	const makeURI = (entry) => {
		const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
		if (ctx.external) {
			const externalId = ctx.external.registry.get(entry[0])?.id;
			const uriGenerator = ctx.external.uri ?? ((id$1) => id$1);
			if (externalId) {
				return { ref: uriGenerator(externalId) };
			}
			const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
			entry[1].defId = id;
			return {
				defId: id,
				ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}`
			};
		}
		if (entry[1] === root) {
			return { ref: "#" };
		}
		const uriPrefix = `#`;
		const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
		const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
		return {
			defId,
			ref: defUriPrefix + defId
		};
	};
	const extractToDef = (entry) => {
		if (entry[1].schema.$ref) {
			return;
		}
		const seen = entry[1];
		const { ref, defId } = makeURI(entry);
		seen.def = { ...seen.schema };
		if (defId) seen.defId = defId;
		const schema$1 = seen.schema;
		for (const key in schema$1) {
			delete schema$1[key];
		}
		schema$1.$ref = ref;
	};
	if (ctx.cycles === "throw") {
		for (const entry of ctx.seen.entries()) {
			const seen = entry[1];
			if (seen.cycle) {
				throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + "\n\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.");
			}
		}
	}
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (schema === entry[0]) {
			extractToDef(entry);
			continue;
		}
		if (ctx.external) {
			const ext = ctx.external.registry.get(entry[0])?.id;
			if (schema !== entry[0] && ext) {
				extractToDef(entry);
				continue;
			}
		}
		const id = ctx.metadataRegistry.get(entry[0])?.id;
		if (id) {
			extractToDef(entry);
			continue;
		}
		if (seen.cycle) {
			extractToDef(entry);
			continue;
		}
		if (seen.count > 1) {
			if (ctx.reused === "ref") {
				extractToDef(entry);
				continue;
			}
		}
	}
}
function finalize(ctx, schema) {
	const root = ctx.seen.get(schema);
	if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const flattenRef = (zodSchema) => {
		const seen = ctx.seen.get(zodSchema);
		if (seen.ref === null) return;
		const schema$1 = seen.def ?? seen.schema;
		const _cached = { ...schema$1 };
		const ref = seen.ref;
		seen.ref = null;
		if (ref) {
			flattenRef(ref);
			const refSeen = ctx.seen.get(ref);
			const refSchema = refSeen.schema;
			if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
				schema$1.allOf = schema$1.allOf ?? [];
				schema$1.allOf.push(refSchema);
			} else {
				Object.assign(schema$1, refSchema);
			}
			Object.assign(schema$1, _cached);
			const isParentRef = zodSchema._zod.parent === ref;
			if (isParentRef) {
				for (const key in schema$1) {
					if (key === "$ref" || key === "allOf") continue;
					if (!(key in _cached)) {
						delete schema$1[key];
					}
				}
			}
			if (refSchema.$ref) {
				for (const key in schema$1) {
					if (key === "$ref" || key === "allOf") continue;
					if (key in refSeen.def && JSON.stringify(schema$1[key]) === JSON.stringify(refSeen.def[key])) {
						delete schema$1[key];
					}
				}
			}
		}
		const parent = zodSchema._zod.parent;
		if (parent && parent !== ref) {
			flattenRef(parent);
			const parentSeen = ctx.seen.get(parent);
			if (parentSeen?.schema.$ref) {
				schema$1.$ref = parentSeen.schema.$ref;
				if (parentSeen.def) {
					for (const key in schema$1) {
						if (key === "$ref" || key === "allOf") continue;
						if (key in parentSeen.def && JSON.stringify(schema$1[key]) === JSON.stringify(parentSeen.def[key])) {
							delete schema$1[key];
						}
					}
				}
			}
		}
		ctx.override({
			zodSchema,
			jsonSchema: schema$1,
			path: seen.path ?? []
		});
	};
	for (const entry of [...ctx.seen.entries()].reverse()) {
		flattenRef(entry[0]);
	}
	const result = {};
	if (ctx.target === "draft-2020-12") {
		result.$schema = "https://json-schema.org/draft/2020-12/schema";
	} else if (ctx.target === "draft-07") {
		result.$schema = "http://json-schema.org/draft-07/schema#";
	} else if (ctx.target === "draft-04") {
		result.$schema = "http://json-schema.org/draft-04/schema#";
	} else if (ctx.target === "openapi-3.0") {} else {}
	if (ctx.external?.uri) {
		const id = ctx.external.registry.get(schema)?.id;
		if (!id) throw new Error("Schema is missing an `id` property");
		result.$id = ctx.external.uri(id);
	}
	Object.assign(result, root.def ?? root.schema);
	const defs = ctx.external?.defs ?? {};
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (seen.def && seen.defId) {
			defs[seen.defId] = seen.def;
		}
	}
	if (ctx.external) {} else {
		if (Object.keys(defs).length > 0) {
			if (ctx.target === "draft-2020-12") {
				result.$defs = defs;
			} else {
				result.definitions = defs;
			}
		}
	}
	try {
		const finalized = JSON.parse(JSON.stringify(result));
		Object.defineProperty(finalized, "~standard", {
			value: {
				...schema["~standard"],
				jsonSchema: {
					input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
					output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
				}
			},
			enumerable: false,
			writable: false
		});
		return finalized;
	} catch (_err) {
		throw new Error("Error converting schema to JSON.");
	}
}
function isTransforming(_schema, _ctx) {
	const ctx = _ctx ?? { seen: new Set() };
	if (ctx.seen.has(_schema)) return false;
	ctx.seen.add(_schema);
	const def = _schema._zod.def;
	if (def.type === "transform") return true;
	if (def.type === "array") return isTransforming(def.element, ctx);
	if (def.type === "set") return isTransforming(def.valueType, ctx);
	if (def.type === "lazy") return isTransforming(def.getter(), ctx);
	if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
		return isTransforming(def.innerType, ctx);
	}
	if (def.type === "intersection") {
		return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
	}
	if (def.type === "record" || def.type === "map") {
		return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
	}
	if (def.type === "pipe") {
		return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
	}
	if (def.type === "object") {
		for (const key in def.shape) {
			if (isTransforming(def.shape[key], ctx)) return true;
		}
		return false;
	}
	if (def.type === "union") {
		for (const option of def.options) {
			if (isTransforming(option, ctx)) return true;
		}
		return false;
	}
	if (def.type === "tuple") {
		for (const item of def.items) {
			if (isTransforming(item, ctx)) return true;
		}
		if (def.rest && isTransforming(def.rest, ctx)) return true;
		return false;
	}
	return false;
}
/**
* Creates a toJSONSchema method for a schema instance.
* This encapsulates the logic of initializing context, processing, extracting defs, and finalizing.
*/
const createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
	const ctx = initializeContext({
		...params,
		processors
	});
	process$2(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};
const createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
	const { libraryOptions, target } = params ?? {};
	const ctx = initializeContext({
		...libraryOptions ?? {},
		target,
		io,
		processors
	});
	process$2(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/json-schema-processors.js
const formatMap = {
	guid: "uuid",
	url: "uri",
	datetime: "date-time",
	json_string: "json-string",
	regex: ""
};
const stringProcessor = (schema, ctx, _json, _params) => {
	const json$2 = _json;
	json$2.type = "string";
	const { minimum, maximum, format: format$2, patterns, contentEncoding } = schema._zod.bag;
	if (typeof minimum === "number") json$2.minLength = minimum;
	if (typeof maximum === "number") json$2.maxLength = maximum;
	if (format$2) {
		json$2.format = formatMap[format$2] ?? format$2;
		if (json$2.format === "") delete json$2.format;
		if (format$2 === "time") {
			delete json$2.format;
		}
	}
	if (contentEncoding) json$2.contentEncoding = contentEncoding;
	if (patterns && patterns.size > 0) {
		const regexes = [...patterns];
		if (regexes.length === 1) json$2.pattern = regexes[0].source;
		else if (regexes.length > 1) {
			json$2.allOf = [...regexes.map((regex) => ({
				...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
				pattern: regex.source
			}))];
		}
	}
};
const numberProcessor = (schema, ctx, _json, _params) => {
	const json$2 = _json;
	const { minimum, maximum, format: format$2, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
	if (typeof format$2 === "string" && format$2.includes("int")) json$2.type = "integer";
	else json$2.type = "number";
	if (typeof exclusiveMinimum === "number") {
		if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
			json$2.minimum = exclusiveMinimum;
			json$2.exclusiveMinimum = true;
		} else {
			json$2.exclusiveMinimum = exclusiveMinimum;
		}
	}
	if (typeof minimum === "number") {
		json$2.minimum = minimum;
		if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
			if (exclusiveMinimum >= minimum) delete json$2.minimum;
			else delete json$2.exclusiveMinimum;
		}
	}
	if (typeof exclusiveMaximum === "number") {
		if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
			json$2.maximum = exclusiveMaximum;
			json$2.exclusiveMaximum = true;
		} else {
			json$2.exclusiveMaximum = exclusiveMaximum;
		}
	}
	if (typeof maximum === "number") {
		json$2.maximum = maximum;
		if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
			if (exclusiveMaximum <= maximum) delete json$2.maximum;
			else delete json$2.exclusiveMaximum;
		}
	}
	if (typeof multipleOf === "number") json$2.multipleOf = multipleOf;
};
const booleanProcessor = (_schema, _ctx, json$2, _params) => {
	json$2.type = "boolean";
};
const bigintProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("BigInt cannot be represented in JSON Schema");
	}
};
const symbolProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Symbols cannot be represented in JSON Schema");
	}
};
const nullProcessor = (_schema, ctx, json$2, _params) => {
	if (ctx.target === "openapi-3.0") {
		json$2.type = "string";
		json$2.nullable = true;
		json$2.enum = [null];
	} else {
		json$2.type = "null";
	}
};
const undefinedProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Undefined cannot be represented in JSON Schema");
	}
};
const voidProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Void cannot be represented in JSON Schema");
	}
};
const neverProcessor = (_schema, _ctx, json$2, _params) => {
	json$2.not = {};
};
const anyProcessor = (_schema, _ctx, _json, _params) => {};
const unknownProcessor = (_schema, _ctx, _json, _params) => {};
const dateProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Date cannot be represented in JSON Schema");
	}
};
const enumProcessor = (schema, _ctx, json$2, _params) => {
	const def = schema._zod.def;
	const values = getEnumValues(def.entries);
	if (values.every((v) => typeof v === "number")) json$2.type = "number";
	if (values.every((v) => typeof v === "string")) json$2.type = "string";
	json$2.enum = values;
};
const literalProcessor = (schema, ctx, json$2, _params) => {
	const def = schema._zod.def;
	const vals = [];
	for (const val of def.values) {
		if (val === undefined) {
			if (ctx.unrepresentable === "throw") {
				throw new Error("Literal `undefined` cannot be represented in JSON Schema");
			} else {}
		} else if (typeof val === "bigint") {
			if (ctx.unrepresentable === "throw") {
				throw new Error("BigInt literals cannot be represented in JSON Schema");
			} else {
				vals.push(Number(val));
			}
		} else {
			vals.push(val);
		}
	}
	if (vals.length === 0) {} else if (vals.length === 1) {
		const val = vals[0];
		json$2.type = val === null ? "null" : typeof val;
		if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
			json$2.enum = [val];
		} else {
			json$2.const = val;
		}
	} else {
		if (vals.every((v) => typeof v === "number")) json$2.type = "number";
		if (vals.every((v) => typeof v === "string")) json$2.type = "string";
		if (vals.every((v) => typeof v === "boolean")) json$2.type = "boolean";
		if (vals.every((v) => v === null)) json$2.type = "null";
		json$2.enum = vals;
	}
};
const nanProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("NaN cannot be represented in JSON Schema");
	}
};
const templateLiteralProcessor = (schema, _ctx, json$2, _params) => {
	const _json = json$2;
	const pattern = schema._zod.pattern;
	if (!pattern) throw new Error("Pattern not found in template literal");
	_json.type = "string";
	_json.pattern = pattern.source;
};
const fileProcessor = (schema, _ctx, json$2, _params) => {
	const _json = json$2;
	const file$2 = {
		type: "string",
		format: "binary",
		contentEncoding: "binary"
	};
	const { minimum, maximum, mime } = schema._zod.bag;
	if (minimum !== undefined) file$2.minLength = minimum;
	if (maximum !== undefined) file$2.maxLength = maximum;
	if (mime) {
		if (mime.length === 1) {
			file$2.contentMediaType = mime[0];
			Object.assign(_json, file$2);
		} else {
			Object.assign(_json, file$2);
			_json.anyOf = mime.map((m) => ({ contentMediaType: m }));
		}
	} else {
		Object.assign(_json, file$2);
	}
};
const successProcessor = (_schema, _ctx, json$2, _params) => {
	json$2.type = "boolean";
};
const customProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Custom types cannot be represented in JSON Schema");
	}
};
const functionProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Function types cannot be represented in JSON Schema");
	}
};
const transformProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Transforms cannot be represented in JSON Schema");
	}
};
const mapProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Map cannot be represented in JSON Schema");
	}
};
const setProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") {
		throw new Error("Set cannot be represented in JSON Schema");
	}
};
const arrayProcessor = (schema, ctx, _json, params) => {
	const json$2 = _json;
	const def = schema._zod.def;
	const { minimum, maximum } = schema._zod.bag;
	if (typeof minimum === "number") json$2.minItems = minimum;
	if (typeof maximum === "number") json$2.maxItems = maximum;
	json$2.type = "array";
	json$2.items = process$2(def.element, ctx, {
		...params,
		path: [...params.path, "items"]
	});
};
const objectProcessor = (schema, ctx, _json, params) => {
	const json$2 = _json;
	const def = schema._zod.def;
	json$2.type = "object";
	json$2.properties = {};
	const shape = def.shape;
	for (const key in shape) {
		json$2.properties[key] = process$2(shape[key], ctx, {
			...params,
			path: [
				...params.path,
				"properties",
				key
			]
		});
	}
	const allKeys = new Set(Object.keys(shape));
	const requiredKeys = new Set([...allKeys].filter((key) => {
		const v = def.shape[key]._zod;
		if (ctx.io === "input") {
			return v.optin === undefined;
		} else {
			return v.optout === undefined;
		}
	}));
	if (requiredKeys.size > 0) {
		json$2.required = Array.from(requiredKeys);
	}
	if (def.catchall?._zod.def.type === "never") {
		json$2.additionalProperties = false;
	} else if (!def.catchall) {
		if (ctx.io === "output") json$2.additionalProperties = false;
	} else if (def.catchall) {
		json$2.additionalProperties = process$2(def.catchall, ctx, {
			...params,
			path: [...params.path, "additionalProperties"]
		});
	}
};
const unionProcessor = (schema, ctx, json$2, params) => {
	const def = schema._zod.def;
	const isExclusive = def.inclusive === false;
	const options = def.options.map((x, i) => process$2(x, ctx, {
		...params,
		path: [
			...params.path,
			isExclusive ? "oneOf" : "anyOf",
			i
		]
	}));
	if (isExclusive) {
		json$2.oneOf = options;
	} else {
		json$2.anyOf = options;
	}
};
const intersectionProcessor = (schema, ctx, json$2, params) => {
	const def = schema._zod.def;
	const a = process$2(def.left, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			0
		]
	});
	const b = process$2(def.right, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			1
		]
	});
	const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
	const allOf = [...isSimpleIntersection(a) ? a.allOf : [a], ...isSimpleIntersection(b) ? b.allOf : [b]];
	json$2.allOf = allOf;
};
const tupleProcessor = (schema, ctx, _json, params) => {
	const json$2 = _json;
	const def = schema._zod.def;
	json$2.type = "array";
	const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
	const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
	const prefixItems = def.items.map((x, i) => process$2(x, ctx, {
		...params,
		path: [
			...params.path,
			prefixPath,
			i
		]
	}));
	const rest = def.rest ? process$2(def.rest, ctx, {
		...params,
		path: [
			...params.path,
			restPath,
			...ctx.target === "openapi-3.0" ? [def.items.length] : []
		]
	}) : null;
	if (ctx.target === "draft-2020-12") {
		json$2.prefixItems = prefixItems;
		if (rest) {
			json$2.items = rest;
		}
	} else if (ctx.target === "openapi-3.0") {
		json$2.items = { anyOf: prefixItems };
		if (rest) {
			json$2.items.anyOf.push(rest);
		}
		json$2.minItems = prefixItems.length;
		if (!rest) {
			json$2.maxItems = prefixItems.length;
		}
	} else {
		json$2.items = prefixItems;
		if (rest) {
			json$2.additionalItems = rest;
		}
	}
	const { minimum, maximum } = schema._zod.bag;
	if (typeof minimum === "number") json$2.minItems = minimum;
	if (typeof maximum === "number") json$2.maxItems = maximum;
};
const recordProcessor = (schema, ctx, _json, params) => {
	const json$2 = _json;
	const def = schema._zod.def;
	json$2.type = "object";
	const keyType = def.keyType;
	const keyBag = keyType._zod.bag;
	const patterns = keyBag?.patterns;
	if (def.mode === "loose" && patterns && patterns.size > 0) {
		const valueSchema = process$2(def.valueType, ctx, {
			...params,
			path: [
				...params.path,
				"patternProperties",
				"*"
			]
		});
		json$2.patternProperties = {};
		for (const pattern of patterns) {
			json$2.patternProperties[pattern.source] = valueSchema;
		}
	} else {
		if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
			json$2.propertyNames = process$2(def.keyType, ctx, {
				...params,
				path: [...params.path, "propertyNames"]
			});
		}
		json$2.additionalProperties = process$2(def.valueType, ctx, {
			...params,
			path: [...params.path, "additionalProperties"]
		});
	}
	const keyValues = keyType._zod.values;
	if (keyValues) {
		const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
		if (validKeyValues.length > 0) {
			json$2.required = validKeyValues;
		}
	}
};
const nullableProcessor = (schema, ctx, json$2, params) => {
	const def = schema._zod.def;
	const inner = process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	if (ctx.target === "openapi-3.0") {
		seen.ref = def.innerType;
		json$2.nullable = true;
	} else {
		json$2.anyOf = [inner, { type: "null" }];
	}
};
const nonoptionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const defaultProcessor = (schema, ctx, json$2, params) => {
	const def = schema._zod.def;
	process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json$2.default = JSON.parse(JSON.stringify(def.defaultValue));
};
const prefaultProcessor = (schema, ctx, json$2, params) => {
	const def = schema._zod.def;
	process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	if (ctx.io === "input") json$2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
const catchProcessor = (schema, ctx, json$2, params) => {
	const def = schema._zod.def;
	process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	let catchValue;
	try {
		catchValue = def.catchValue(undefined);
	} catch {
		throw new Error("Dynamic catch values are not supported in JSON Schema");
	}
	json$2.default = catchValue;
};
const pipeProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
	process$2(innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = innerType;
};
const readonlyProcessor = (schema, ctx, json$2, params) => {
	const def = schema._zod.def;
	process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json$2.readOnly = true;
};
const promiseProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const optionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$2(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const lazyProcessor = (schema, ctx, _json, params) => {
	const innerType = schema._zod.innerType;
	process$2(innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = innerType;
};
const allProcessors = {
	string: stringProcessor,
	number: numberProcessor,
	boolean: booleanProcessor,
	bigint: bigintProcessor,
	symbol: symbolProcessor,
	null: nullProcessor,
	undefined: undefinedProcessor,
	void: voidProcessor,
	never: neverProcessor,
	any: anyProcessor,
	unknown: unknownProcessor,
	date: dateProcessor,
	enum: enumProcessor,
	literal: literalProcessor,
	nan: nanProcessor,
	template_literal: templateLiteralProcessor,
	file: fileProcessor,
	success: successProcessor,
	custom: customProcessor,
	function: functionProcessor,
	transform: transformProcessor,
	map: mapProcessor,
	set: setProcessor,
	array: arrayProcessor,
	object: objectProcessor,
	union: unionProcessor,
	intersection: intersectionProcessor,
	tuple: tupleProcessor,
	record: recordProcessor,
	nullable: nullableProcessor,
	nonoptional: nonoptionalProcessor,
	default: defaultProcessor,
	prefault: prefaultProcessor,
	catch: catchProcessor,
	pipe: pipeProcessor,
	readonly: readonlyProcessor,
	promise: promiseProcessor,
	optional: optionalProcessor,
	lazy: lazyProcessor
};
function toJSONSchema(input, params) {
	if ("_idmap" in input) {
		const registry$1 = input;
		const ctx$1 = initializeContext({
			...params,
			processors: allProcessors
		});
		const defs = {};
		for (const entry of registry$1._idmap.entries()) {
			const [_, schema] = entry;
			process$2(schema, ctx$1);
		}
		const schemas = {};
		const external = {
			registry: registry$1,
			uri: params?.uri,
			defs
		};
		ctx$1.external = external;
		for (const entry of registry$1._idmap.entries()) {
			const [key, schema] = entry;
			extractDefs(ctx$1, schema);
			schemas[key] = finalize(ctx$1, schema);
		}
		if (Object.keys(defs).length > 0) {
			const defsSegment = ctx$1.target === "draft-2020-12" ? "$defs" : "definitions";
			schemas.__shared = { [defsSegment]: defs };
		}
		return { schemas };
	}
	const ctx = initializeContext({
		...params,
		processors: allProcessors
	});
	process$2(input, ctx);
	extractDefs(ctx, input);
	return finalize(ctx, input);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/json-schema-generator.js
/**
* Legacy class-based interface for JSON Schema generation.
* This class wraps the new functional implementation to provide backward compatibility.
*
* @deprecated Use the `toJSONSchema` function instead for new code.
*
* @example
* ```typescript
* // Legacy usage (still supported)
* const gen = new JSONSchemaGenerator({ target: "draft-07" });
* gen.process(schema);
* const result = gen.emit(schema);
*
* // Preferred modern usage
* const result = toJSONSchema(schema, { target: "draft-07" });
* ```
*/
var JSONSchemaGenerator = class {
	/** @deprecated Access via ctx instead */
	get metadataRegistry() {
		return this.ctx.metadataRegistry;
	}
	/** @deprecated Access via ctx instead */
	get target() {
		return this.ctx.target;
	}
	/** @deprecated Access via ctx instead */
	get unrepresentable() {
		return this.ctx.unrepresentable;
	}
	/** @deprecated Access via ctx instead */
	get override() {
		return this.ctx.override;
	}
	/** @deprecated Access via ctx instead */
	get io() {
		return this.ctx.io;
	}
	/** @deprecated Access via ctx instead */
	get counter() {
		return this.ctx.counter;
	}
	set counter(value) {
		this.ctx.counter = value;
	}
	/** @deprecated Access via ctx instead */
	get seen() {
		return this.ctx.seen;
	}
	constructor(params) {
		let normalizedTarget = params?.target ?? "draft-2020-12";
		if (normalizedTarget === "draft-4") normalizedTarget = "draft-04";
		if (normalizedTarget === "draft-7") normalizedTarget = "draft-07";
		this.ctx = initializeContext({
			processors: allProcessors,
			target: normalizedTarget,
			...params?.metadata && { metadata: params.metadata },
			...params?.unrepresentable && { unrepresentable: params.unrepresentable },
			...params?.override && { override: params.override },
			...params?.io && { io: params.io }
		});
	}
	/**
	* Process a schema to prepare it for JSON Schema generation.
	* This must be called before emit().
	*/
	process(schema, _params = {
		path: [],
		schemaPath: []
	}) {
		return process$2(schema, this.ctx, _params);
	}
	/**
	* Emit the final JSON Schema after processing.
	* Must call process() first.
	*/
	emit(schema, _params) {
		if (_params) {
			if (_params.cycles) this.ctx.cycles = _params.cycles;
			if (_params.reused) this.ctx.reused = _params.reused;
			if (_params.external) this.ctx.external = _params.external;
		}
		extractDefs(this.ctx, schema);
		const result = finalize(this.ctx, schema);
		const { "~standard": _, ...plainResult } = result;
		return plainResult;
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/core/index.js
var core_exports = /* @__PURE__ */ __exportAll({
	$ZodAny: () => $ZodAny,
	$ZodArray: () => $ZodArray,
	$ZodAsyncError: () => $ZodAsyncError,
	$ZodBase64: () => $ZodBase64,
	$ZodBase64URL: () => $ZodBase64URL,
	$ZodBigInt: () => $ZodBigInt,
	$ZodBigIntFormat: () => $ZodBigIntFormat,
	$ZodBoolean: () => $ZodBoolean,
	$ZodCIDRv4: () => $ZodCIDRv4,
	$ZodCIDRv6: () => $ZodCIDRv6,
	$ZodCUID: () => $ZodCUID,
	$ZodCUID2: () => $ZodCUID2,
	$ZodCatch: () => $ZodCatch,
	$ZodCheck: () => $ZodCheck,
	$ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
	$ZodCheckEndsWith: () => $ZodCheckEndsWith,
	$ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
	$ZodCheckIncludes: () => $ZodCheckIncludes,
	$ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
	$ZodCheckLessThan: () => $ZodCheckLessThan,
	$ZodCheckLowerCase: () => $ZodCheckLowerCase,
	$ZodCheckMaxLength: () => $ZodCheckMaxLength,
	$ZodCheckMaxSize: () => $ZodCheckMaxSize,
	$ZodCheckMimeType: () => $ZodCheckMimeType,
	$ZodCheckMinLength: () => $ZodCheckMinLength,
	$ZodCheckMinSize: () => $ZodCheckMinSize,
	$ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
	$ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
	$ZodCheckOverwrite: () => $ZodCheckOverwrite,
	$ZodCheckProperty: () => $ZodCheckProperty,
	$ZodCheckRegex: () => $ZodCheckRegex,
	$ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
	$ZodCheckStartsWith: () => $ZodCheckStartsWith,
	$ZodCheckStringFormat: () => $ZodCheckStringFormat,
	$ZodCheckUpperCase: () => $ZodCheckUpperCase,
	$ZodCodec: () => $ZodCodec,
	$ZodCustom: () => $ZodCustom,
	$ZodCustomStringFormat: () => $ZodCustomStringFormat,
	$ZodDate: () => $ZodDate,
	$ZodDefault: () => $ZodDefault,
	$ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
	$ZodE164: () => $ZodE164,
	$ZodEmail: () => $ZodEmail,
	$ZodEmoji: () => $ZodEmoji,
	$ZodEncodeError: () => $ZodEncodeError,
	$ZodEnum: () => $ZodEnum,
	$ZodError: () => $ZodError,
	$ZodExactOptional: () => $ZodExactOptional,
	$ZodFile: () => $ZodFile,
	$ZodFunction: () => $ZodFunction,
	$ZodGUID: () => $ZodGUID,
	$ZodIPv4: () => $ZodIPv4,
	$ZodIPv6: () => $ZodIPv6,
	$ZodISODate: () => $ZodISODate,
	$ZodISODateTime: () => $ZodISODateTime,
	$ZodISODuration: () => $ZodISODuration,
	$ZodISOTime: () => $ZodISOTime,
	$ZodIntersection: () => $ZodIntersection,
	$ZodJWT: () => $ZodJWT,
	$ZodKSUID: () => $ZodKSUID,
	$ZodLazy: () => $ZodLazy,
	$ZodLiteral: () => $ZodLiteral,
	$ZodMAC: () => $ZodMAC,
	$ZodMap: () => $ZodMap,
	$ZodNaN: () => $ZodNaN,
	$ZodNanoID: () => $ZodNanoID,
	$ZodNever: () => $ZodNever,
	$ZodNonOptional: () => $ZodNonOptional,
	$ZodNull: () => $ZodNull,
	$ZodNullable: () => $ZodNullable,
	$ZodNumber: () => $ZodNumber,
	$ZodNumberFormat: () => $ZodNumberFormat,
	$ZodObject: () => $ZodObject,
	$ZodObjectJIT: () => $ZodObjectJIT,
	$ZodOptional: () => $ZodOptional,
	$ZodPipe: () => $ZodPipe,
	$ZodPrefault: () => $ZodPrefault,
	$ZodPromise: () => $ZodPromise,
	$ZodReadonly: () => $ZodReadonly,
	$ZodRealError: () => $ZodRealError,
	$ZodRecord: () => $ZodRecord,
	$ZodRegistry: () => $ZodRegistry,
	$ZodSet: () => $ZodSet,
	$ZodString: () => $ZodString,
	$ZodStringFormat: () => $ZodStringFormat,
	$ZodSuccess: () => $ZodSuccess,
	$ZodSymbol: () => $ZodSymbol,
	$ZodTemplateLiteral: () => $ZodTemplateLiteral,
	$ZodTransform: () => $ZodTransform,
	$ZodTuple: () => $ZodTuple,
	$ZodType: () => $ZodType,
	$ZodULID: () => $ZodULID,
	$ZodURL: () => $ZodURL,
	$ZodUUID: () => $ZodUUID,
	$ZodUndefined: () => $ZodUndefined,
	$ZodUnion: () => $ZodUnion,
	$ZodUnknown: () => $ZodUnknown,
	$ZodVoid: () => $ZodVoid,
	$ZodXID: () => $ZodXID,
	$ZodXor: () => $ZodXor,
	$brand: () => $brand,
	$constructor: () => $constructor,
	$input: () => $input,
	$output: () => $output,
	Doc: () => Doc,
	JSONSchema: () => json_schema_exports,
	JSONSchemaGenerator: () => JSONSchemaGenerator,
	NEVER: () => NEVER$1,
	TimePrecision: () => TimePrecision,
	_any: () => _any,
	_array: () => _array,
	_base64: () => _base64,
	_base64url: () => _base64url,
	_bigint: () => _bigint,
	_boolean: () => _boolean,
	_catch: () => _catch$2,
	_check: () => _check,
	_cidrv4: () => _cidrv4,
	_cidrv6: () => _cidrv6,
	_coercedBigint: () => _coercedBigint,
	_coercedBoolean: () => _coercedBoolean,
	_coercedDate: () => _coercedDate,
	_coercedNumber: () => _coercedNumber,
	_coercedString: () => _coercedString,
	_cuid: () => _cuid,
	_cuid2: () => _cuid2,
	_custom: () => _custom,
	_date: () => _date,
	_decode: () => _decode,
	_decodeAsync: () => _decodeAsync,
	_default: () => _default$2,
	_discriminatedUnion: () => _discriminatedUnion,
	_e164: () => _e164,
	_email: () => _email,
	_emoji: () => _emoji,
	_encode: () => _encode,
	_encodeAsync: () => _encodeAsync,
	_endsWith: () => _endsWith,
	_enum: () => _enum$2,
	_file: () => _file,
	_float32: () => _float32,
	_float64: () => _float64,
	_gt: () => _gt,
	_gte: () => _gte,
	_guid: () => _guid,
	_includes: () => _includes,
	_int: () => _int,
	_int32: () => _int32,
	_int64: () => _int64,
	_intersection: () => _intersection,
	_ipv4: () => _ipv4,
	_ipv6: () => _ipv6,
	_isoDate: () => _isoDate,
	_isoDateTime: () => _isoDateTime,
	_isoDuration: () => _isoDuration,
	_isoTime: () => _isoTime,
	_jwt: () => _jwt,
	_ksuid: () => _ksuid,
	_lazy: () => _lazy$1,
	_length: () => _length,
	_literal: () => _literal,
	_lowercase: () => _lowercase,
	_lt: () => _lt,
	_lte: () => _lte,
	_mac: () => _mac,
	_map: () => _map,
	_max: () => _lte,
	_maxLength: () => _maxLength,
	_maxSize: () => _maxSize,
	_mime: () => _mime,
	_min: () => _gte,
	_minLength: () => _minLength,
	_minSize: () => _minSize,
	_multipleOf: () => _multipleOf,
	_nan: () => _nan,
	_nanoid: () => _nanoid,
	_nativeEnum: () => _nativeEnum,
	_negative: () => _negative,
	_never: () => _never,
	_nonnegative: () => _nonnegative,
	_nonoptional: () => _nonoptional,
	_nonpositive: () => _nonpositive,
	_normalize: () => _normalize,
	_null: () => _null$2,
	_nullable: () => _nullable,
	_number: () => _number,
	_optional: () => _optional,
	_overwrite: () => _overwrite,
	_parse: () => _parse,
	_parseAsync: () => _parseAsync,
	_pipe: () => _pipe,
	_positive: () => _positive,
	_promise: () => _promise,
	_property: () => _property,
	_readonly: () => _readonly,
	_record: () => _record,
	_refine: () => _refine,
	_regex: () => _regex,
	_safeDecode: () => _safeDecode,
	_safeDecodeAsync: () => _safeDecodeAsync,
	_safeEncode: () => _safeEncode,
	_safeEncodeAsync: () => _safeEncodeAsync,
	_safeParse: () => _safeParse,
	_safeParseAsync: () => _safeParseAsync,
	_set: () => _set,
	_size: () => _size,
	_slugify: () => _slugify,
	_startsWith: () => _startsWith,
	_string: () => _string,
	_stringFormat: () => _stringFormat,
	_stringbool: () => _stringbool,
	_success: () => _success,
	_superRefine: () => _superRefine,
	_symbol: () => _symbol,
	_templateLiteral: () => _templateLiteral,
	_toLowerCase: () => _toLowerCase,
	_toUpperCase: () => _toUpperCase,
	_transform: () => _transform,
	_trim: () => _trim,
	_tuple: () => _tuple,
	_uint32: () => _uint32,
	_uint64: () => _uint64,
	_ulid: () => _ulid,
	_undefined: () => _undefined$2,
	_union: () => _union,
	_unknown: () => _unknown,
	_uppercase: () => _uppercase,
	_url: () => _url$1,
	_uuid: () => _uuid,
	_uuidv4: () => _uuidv4,
	_uuidv6: () => _uuidv6,
	_uuidv7: () => _uuidv7,
	_void: () => _void$2,
	_xid: () => _xid,
	_xor: () => _xor,
	clone: () => clone,
	config: () => config,
	createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
	createToJSONSchemaMethod: () => createToJSONSchemaMethod,
	decode: () => decode$1,
	decodeAsync: () => decodeAsync$1,
	describe: () => describe$2,
	encode: () => encode$1,
	encodeAsync: () => encodeAsync$1,
	extractDefs: () => extractDefs,
	finalize: () => finalize,
	flattenError: () => flattenError$1,
	formatError: () => formatError,
	globalConfig: () => globalConfig,
	globalRegistry: () => globalRegistry,
	initializeContext: () => initializeContext,
	isValidBase64: () => isValidBase64,
	isValidBase64URL: () => isValidBase64URL,
	isValidJWT: () => isValidJWT$1,
	locales: () => locales_exports,
	meta: () => meta$2,
	parse: () => parse$3,
	parseAsync: () => parseAsync$1,
	prettifyError: () => prettifyError,
	process: () => process$2,
	regexes: () => regexes_exports,
	registry: () => registry,
	safeDecode: () => safeDecode$1,
	safeDecodeAsync: () => safeDecodeAsync$1,
	safeEncode: () => safeEncode$1,
	safeEncodeAsync: () => safeEncodeAsync$1,
	safeParse: () => safeParse$2,
	safeParseAsync: () => safeParseAsync$2,
	toDotPath: () => toDotPath,
	toJSONSchema: () => toJSONSchema,
	treeifyError: () => treeifyError,
	util: () => util_exports,
	version: () => version
});

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/checks.js
var checks_exports = /* @__PURE__ */ __exportAll({
	endsWith: () => _endsWith,
	gt: () => _gt,
	gte: () => _gte,
	includes: () => _includes,
	length: () => _length,
	lowercase: () => _lowercase,
	lt: () => _lt,
	lte: () => _lte,
	maxLength: () => _maxLength,
	maxSize: () => _maxSize,
	mime: () => _mime,
	minLength: () => _minLength,
	minSize: () => _minSize,
	multipleOf: () => _multipleOf,
	negative: () => _negative,
	nonnegative: () => _nonnegative,
	nonpositive: () => _nonpositive,
	normalize: () => _normalize,
	overwrite: () => _overwrite,
	positive: () => _positive,
	property: () => _property,
	regex: () => _regex,
	size: () => _size,
	slugify: () => _slugify,
	startsWith: () => _startsWith,
	toLowerCase: () => _toLowerCase,
	toUpperCase: () => _toUpperCase,
	trim: () => _trim,
	uppercase: () => _uppercase
});

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/iso.js
var iso_exports$1 = /* @__PURE__ */ __exportAll({
	ZodISODate: () => ZodISODate,
	ZodISODateTime: () => ZodISODateTime,
	ZodISODuration: () => ZodISODuration,
	ZodISOTime: () => ZodISOTime,
	date: () => date$5,
	datetime: () => datetime$1,
	duration: () => duration$1,
	time: () => time$1
});
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
	$ZodISODateTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function datetime$1(params) {
	return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
	$ZodISODate.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function date$5(params) {
	return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
	$ZodISOTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function time$1(params) {
	return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
	$ZodISODuration.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function duration$1(params) {
	return _isoDuration(ZodISODuration, params);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/errors.js
const initializer = (inst, issues) => {
	$ZodError.init(inst, issues);
	inst.name = "ZodError";
	Object.defineProperties(inst, {
		format: { value: (mapper) => formatError(inst, mapper) },
		flatten: { value: (mapper) => flattenError$1(inst, mapper) },
		addIssue: { value: (issue$1) => {
			inst.issues.push(issue$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		addIssues: { value: (issues$1) => {
			inst.issues.push(...issues$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		isEmpty: { get() {
			return inst.issues.length === 0;
		} }
	});
};
const ZodError$1 = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, { Parent: Error });

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/parse.js
const parse$2 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse$1 = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/schemas.js
var schemas_exports = /* @__PURE__ */ __exportAll({
	ZodAny: () => ZodAny$1,
	ZodArray: () => ZodArray$1,
	ZodBase64: () => ZodBase64,
	ZodBase64URL: () => ZodBase64URL,
	ZodBigInt: () => ZodBigInt$1,
	ZodBigIntFormat: () => ZodBigIntFormat,
	ZodBoolean: () => ZodBoolean$1,
	ZodCIDRv4: () => ZodCIDRv4,
	ZodCIDRv6: () => ZodCIDRv6,
	ZodCUID: () => ZodCUID,
	ZodCUID2: () => ZodCUID2,
	ZodCatch: () => ZodCatch$1,
	ZodCodec: () => ZodCodec,
	ZodCustom: () => ZodCustom,
	ZodCustomStringFormat: () => ZodCustomStringFormat,
	ZodDate: () => ZodDate$1,
	ZodDefault: () => ZodDefault$1,
	ZodDiscriminatedUnion: () => ZodDiscriminatedUnion$1,
	ZodE164: () => ZodE164,
	ZodEmail: () => ZodEmail,
	ZodEmoji: () => ZodEmoji,
	ZodEnum: () => ZodEnum$1,
	ZodExactOptional: () => ZodExactOptional,
	ZodFile: () => ZodFile,
	ZodFunction: () => ZodFunction$1,
	ZodGUID: () => ZodGUID,
	ZodIPv4: () => ZodIPv4,
	ZodIPv6: () => ZodIPv6,
	ZodIntersection: () => ZodIntersection$1,
	ZodJWT: () => ZodJWT,
	ZodKSUID: () => ZodKSUID,
	ZodLazy: () => ZodLazy$1,
	ZodLiteral: () => ZodLiteral$1,
	ZodMAC: () => ZodMAC,
	ZodMap: () => ZodMap$1,
	ZodNaN: () => ZodNaN$1,
	ZodNanoID: () => ZodNanoID,
	ZodNever: () => ZodNever$1,
	ZodNonOptional: () => ZodNonOptional,
	ZodNull: () => ZodNull$1,
	ZodNullable: () => ZodNullable$1,
	ZodNumber: () => ZodNumber$1,
	ZodNumberFormat: () => ZodNumberFormat,
	ZodObject: () => ZodObject$1,
	ZodOptional: () => ZodOptional$1,
	ZodPipe: () => ZodPipe,
	ZodPrefault: () => ZodPrefault,
	ZodPromise: () => ZodPromise$1,
	ZodReadonly: () => ZodReadonly$1,
	ZodRecord: () => ZodRecord$1,
	ZodSet: () => ZodSet$1,
	ZodString: () => ZodString$1,
	ZodStringFormat: () => ZodStringFormat,
	ZodSuccess: () => ZodSuccess,
	ZodSymbol: () => ZodSymbol$1,
	ZodTemplateLiteral: () => ZodTemplateLiteral,
	ZodTransform: () => ZodTransform,
	ZodTuple: () => ZodTuple$1,
	ZodType: () => ZodType$1,
	ZodULID: () => ZodULID,
	ZodURL: () => ZodURL,
	ZodUUID: () => ZodUUID,
	ZodUndefined: () => ZodUndefined$1,
	ZodUnion: () => ZodUnion$1,
	ZodUnknown: () => ZodUnknown$1,
	ZodVoid: () => ZodVoid$1,
	ZodXID: () => ZodXID,
	ZodXor: () => ZodXor,
	_ZodString: () => _ZodString,
	_default: () => _default$1,
	_function: () => _function$1,
	any: () => any$1,
	array: () => array$1,
	base64: () => base64$1,
	base64url: () => base64url$1,
	bigint: () => bigint$3,
	boolean: () => boolean$3,
	catch: () => _catch$1,
	check: () => check$1,
	cidrv4: () => cidrv4$1,
	cidrv6: () => cidrv6$1,
	codec: () => codec$1,
	cuid: () => cuid$1,
	cuid2: () => cuid2$1,
	custom: () => custom$2,
	date: () => date$4,
	describe: () => describe$1,
	discriminatedUnion: () => discriminatedUnion$1,
	e164: () => e164$1,
	email: () => email$1,
	emoji: () => emoji$1,
	enum: () => _enum$1,
	exactOptional: () => exactOptional$1,
	file: () => file$1,
	float32: () => float32$1,
	float64: () => float64$1,
	function: () => _function$1,
	guid: () => guid$1,
	hash: () => hash$1,
	hex: () => hex$1,
	hostname: () => hostname$1,
	httpUrl: () => httpUrl$1,
	instanceof: () => _instanceof$1,
	int: () => int$1,
	int32: () => int32$1,
	int64: () => int64$1,
	intersection: () => intersection$1,
	ipv4: () => ipv4$1,
	ipv6: () => ipv6$1,
	json: () => json$1,
	jwt: () => jwt$1,
	keyof: () => keyof$1,
	ksuid: () => ksuid$1,
	lazy: () => lazy,
	literal: () => literal$1,
	looseObject: () => looseObject$1,
	looseRecord: () => looseRecord$1,
	mac: () => mac$1,
	map: () => map$1,
	meta: () => meta$1,
	nan: () => nan$1,
	nanoid: () => nanoid$1,
	nativeEnum: () => nativeEnum$1,
	never: () => never$1,
	nonoptional: () => nonoptional$1,
	null: () => _null$1,
	nullable: () => nullable$1,
	nullish: () => nullish$1,
	number: () => number$3,
	object: () => object$1,
	optional: () => optional$1,
	partialRecord: () => partialRecord$1,
	pipe: () => pipe$1,
	prefault: () => prefault$1,
	preprocess: () => preprocess,
	promise: () => promise$1,
	readonly: () => readonly$1,
	record: () => record$1,
	refine: () => refine$1,
	set: () => set$1,
	strictObject: () => strictObject$1,
	string: () => string$3,
	stringFormat: () => stringFormat$1,
	stringbool: () => stringbool$1,
	success: () => success$1,
	superRefine: () => superRefine$1,
	symbol: () => symbol$1,
	templateLiteral: () => templateLiteral$1,
	transform: () => transform$1,
	tuple: () => tuple$1,
	uint32: () => uint32$1,
	uint64: () => uint64$1,
	ulid: () => ulid$1,
	undefined: () => _undefined$1,
	union: () => union$1,
	unknown: () => unknown$1,
	url: () => url$1,
	uuid: () => uuid$1,
	uuidv4: () => uuidv4$1,
	uuidv6: () => uuidv6$1,
	uuidv7: () => uuidv7$1,
	void: () => _void$1,
	xid: () => xid$1,
	xor: () => xor$1
});
const ZodType$1 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
	$ZodType.init(inst, def);
	Object.assign(inst["~standard"], { jsonSchema: {
		input: createStandardJSONSchemaMethod(inst, "input"),
		output: createStandardJSONSchemaMethod(inst, "output")
	} });
	inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
	inst.def = def;
	inst.type = def.type;
	Object.defineProperty(inst, "_def", { value: def });
	inst.check = (...checks) => {
		return inst.clone(mergeDefs(def, { checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
			check: ch,
			def: { check: "custom" },
			onattach: []
		} } : ch)] }), { parent: true });
	};
	inst.with = inst.check;
	inst.clone = (def$1, params) => clone(inst, def$1, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta$3) => {
		reg.add(inst, meta$3);
		return inst;
	});
	inst.parse = (data, params) => parse$2(inst, data, params, { callee: inst.parse });
	inst.safeParse = (data, params) => safeParse$1(inst, data, params);
	inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data, params) => safeParseAsync$1(inst, data, params);
	inst.spa = inst.safeParseAsync;
	inst.encode = (data, params) => encode(inst, data, params);
	inst.decode = (data, params) => decode(inst, data, params);
	inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
	inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
	inst.safeEncode = (data, params) => safeEncode(inst, data, params);
	inst.safeDecode = (data, params) => safeDecode(inst, data, params);
	inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
	inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
	inst.refine = (check$2, params) => inst.check(refine$1(check$2, params));
	inst.superRefine = (refinement) => inst.check(superRefine$1(refinement));
	inst.overwrite = (fn) => inst.check(_overwrite(fn));
	inst.optional = () => optional$1(inst);
	inst.exactOptional = () => exactOptional$1(inst);
	inst.nullable = () => nullable$1(inst);
	inst.nullish = () => optional$1(nullable$1(inst));
	inst.nonoptional = (params) => nonoptional$1(inst, params);
	inst.array = () => array$1(inst);
	inst.or = (arg) => union$1([inst, arg]);
	inst.and = (arg) => intersection$1(inst, arg);
	inst.transform = (tx) => pipe$1(inst, transform$1(tx));
	inst.default = (def$1) => _default$1(inst, def$1);
	inst.prefault = (def$1) => prefault$1(inst, def$1);
	inst.catch = (params) => _catch$1(inst, params);
	inst.pipe = (target) => pipe$1(inst, target);
	inst.readonly = () => readonly$1(inst);
	inst.describe = (description) => {
		const cl = inst.clone();
		globalRegistry.add(cl, { description });
		return cl;
	};
	Object.defineProperty(inst, "description", {
		get() {
			return globalRegistry.get(inst)?.description;
		},
		configurable: true
	});
	inst.meta = (...args) => {
		if (args.length === 0) {
			return globalRegistry.get(inst);
		}
		const cl = inst.clone();
		globalRegistry.add(cl, args[0]);
		return cl;
	};
	inst.isOptional = () => inst.safeParse(undefined).success;
	inst.isNullable = () => inst.safeParse(null).success;
	inst.apply = (fn) => fn(inst);
	return inst;
});
/** @internal */
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => stringProcessor(inst, ctx, json$2, params);
	const bag = inst._zod.bag;
	inst.format = bag.format ?? null;
	inst.minLength = bag.minimum ?? null;
	inst.maxLength = bag.maximum ?? null;
	inst.regex = (...args) => inst.check(_regex(...args));
	inst.includes = (...args) => inst.check(_includes(...args));
	inst.startsWith = (...args) => inst.check(_startsWith(...args));
	inst.endsWith = (...args) => inst.check(_endsWith(...args));
	inst.min = (...args) => inst.check(_minLength(...args));
	inst.max = (...args) => inst.check(_maxLength(...args));
	inst.length = (...args) => inst.check(_length(...args));
	inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
	inst.lowercase = (params) => inst.check(_lowercase(params));
	inst.uppercase = (params) => inst.check(_uppercase(params));
	inst.trim = () => inst.check(_trim());
	inst.normalize = (...args) => inst.check(_normalize(...args));
	inst.toLowerCase = () => inst.check(_toLowerCase());
	inst.toUpperCase = () => inst.check(_toUpperCase());
	inst.slugify = () => inst.check(_slugify());
});
const ZodString$1 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	_ZodString.init(inst, def);
	inst.email = (params) => inst.check(_email(ZodEmail, params));
	inst.url = (params) => inst.check(_url$1(ZodURL, params));
	inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
	inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
	inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
	inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
	inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
	inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
	inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
	inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
	inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
	inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
	inst.xid = (params) => inst.check(_xid(ZodXID, params));
	inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
	inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
	inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
	inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
	inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
	inst.e164 = (params) => inst.check(_e164(ZodE164, params));
	inst.datetime = (params) => inst.check(datetime$1(params));
	inst.date = (params) => inst.check(date$5(params));
	inst.time = (params) => inst.check(time$1(params));
	inst.duration = (params) => inst.check(duration$1(params));
});
function string$3(params) {
	return _string(ZodString$1, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	_ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
	$ZodEmail.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function email$1(params) {
	return _email(ZodEmail, params);
}
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
	$ZodGUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function guid$1(params) {
	return _guid(ZodGUID, params);
}
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
	$ZodUUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function uuid$1(params) {
	return _uuid(ZodUUID, params);
}
function uuidv4$1(params) {
	return _uuidv4(ZodUUID, params);
}
function uuidv6$1(params) {
	return _uuidv6(ZodUUID, params);
}
function uuidv7$1(params) {
	return _uuidv7(ZodUUID, params);
}
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
	$ZodURL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function url$1(params) {
	return _url$1(ZodURL, params);
}
function httpUrl$1(params) {
	return _url$1(ZodURL, {
		protocol: /^https?$/,
		hostname: domain,
		...normalizeParams(params)
	});
}
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
	$ZodEmoji.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function emoji$1(params) {
	return _emoji(ZodEmoji, params);
}
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
	$ZodNanoID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function nanoid$1(params) {
	return _nanoid(ZodNanoID, params);
}
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
	$ZodCUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cuid$1(params) {
	return _cuid(ZodCUID, params);
}
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
	$ZodCUID2.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cuid2$1(params) {
	return _cuid2(ZodCUID2, params);
}
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
	$ZodULID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ulid$1(params) {
	return _ulid(ZodULID, params);
}
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
	$ZodXID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function xid$1(params) {
	return _xid(ZodXID, params);
}
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
	$ZodKSUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ksuid$1(params) {
	return _ksuid(ZodKSUID, params);
}
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
	$ZodIPv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ipv4$1(params) {
	return _ipv4(ZodIPv4, params);
}
const ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
	$ZodMAC.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function mac$1(params) {
	return _mac(ZodMAC, params);
}
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
	$ZodIPv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function ipv6$1(params) {
	return _ipv6(ZodIPv6, params);
}
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
	$ZodCIDRv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cidrv4$1(params) {
	return _cidrv4(ZodCIDRv4, params);
}
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
	$ZodCIDRv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function cidrv6$1(params) {
	return _cidrv6(ZodCIDRv6, params);
}
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
	$ZodBase64.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function base64$1(params) {
	return _base64(ZodBase64, params);
}
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
	$ZodBase64URL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function base64url$1(params) {
	return _base64url(ZodBase64URL, params);
}
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
	$ZodE164.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function e164$1(params) {
	return _e164(ZodE164, params);
}
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
	$ZodJWT.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function jwt$1(params) {
	return _jwt(ZodJWT, params);
}
const ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
	$ZodCustomStringFormat.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function stringFormat$1(format$2, fnOrRegex, _params = {}) {
	return _stringFormat(ZodCustomStringFormat, format$2, fnOrRegex, _params);
}
function hostname$1(_params) {
	return _stringFormat(ZodCustomStringFormat, "hostname", hostname$2, _params);
}
function hex$1(_params) {
	return _stringFormat(ZodCustomStringFormat, "hex", hex$2, _params);
}
function hash$1(alg, params) {
	const enc = params?.enc ?? "hex";
	const format$2 = `${alg}_${enc}`;
	const regex = regexes_exports[format$2];
	if (!regex) throw new Error(`Unrecognized hash format: ${format$2}`);
	return _stringFormat(ZodCustomStringFormat, format$2, regex, params);
}
const ZodNumber$1 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
	$ZodNumber.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => numberProcessor(inst, ctx, json$2, params);
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.int = (params) => inst.check(int$1(params));
	inst.safe = (params) => inst.check(int$1(params));
	inst.positive = (params) => inst.check(_gt(0, params));
	inst.nonnegative = (params) => inst.check(_gte(0, params));
	inst.negative = (params) => inst.check(_lt(0, params));
	inst.nonpositive = (params) => inst.check(_lte(0, params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	inst.step = (value, params) => inst.check(_multipleOf(value, params));
	inst.finite = () => inst;
	const bag = inst._zod.bag;
	inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
	inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
	inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? .5);
	inst.isFinite = true;
	inst.format = bag.format ?? null;
});
function number$3(params) {
	return _number(ZodNumber$1, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
	$ZodNumberFormat.init(inst, def);
	ZodNumber$1.init(inst, def);
});
function int$1(params) {
	return _int(ZodNumberFormat, params);
}
function float32$1(params) {
	return _float32(ZodNumberFormat, params);
}
function float64$1(params) {
	return _float64(ZodNumberFormat, params);
}
function int32$1(params) {
	return _int32(ZodNumberFormat, params);
}
function uint32$1(params) {
	return _uint32(ZodNumberFormat, params);
}
const ZodBoolean$1 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
	$ZodBoolean.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => booleanProcessor(inst, ctx, json$2, params);
});
function boolean$3(params) {
	return _boolean(ZodBoolean$1, params);
}
const ZodBigInt$1 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
	$ZodBigInt.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => bigintProcessor(inst, ctx, json$2, params);
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.positive = (params) => inst.check(_gt(BigInt(0), params));
	inst.negative = (params) => inst.check(_lt(BigInt(0), params));
	inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
	inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	const bag = inst._zod.bag;
	inst.minValue = bag.minimum ?? null;
	inst.maxValue = bag.maximum ?? null;
	inst.format = bag.format ?? null;
});
function bigint$3(params) {
	return _bigint(ZodBigInt$1, params);
}
const ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
	$ZodBigIntFormat.init(inst, def);
	ZodBigInt$1.init(inst, def);
});
function int64$1(params) {
	return _int64(ZodBigIntFormat, params);
}
function uint64$1(params) {
	return _uint64(ZodBigIntFormat, params);
}
const ZodSymbol$1 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
	$ZodSymbol.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => symbolProcessor(inst, ctx, json$2, params);
});
function symbol$1(params) {
	return _symbol(ZodSymbol$1, params);
}
const ZodUndefined$1 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
	$ZodUndefined.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => undefinedProcessor(inst, ctx, json$2, params);
});
function _undefined$1(params) {
	return _undefined$2(ZodUndefined$1, params);
}
const ZodNull$1 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
	$ZodNull.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => nullProcessor(inst, ctx, json$2, params);
});
function _null$1(params) {
	return _null$2(ZodNull$1, params);
}
const ZodAny$1 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
	$ZodAny.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => anyProcessor(inst, ctx, json$2, params);
});
function any$1() {
	return _any(ZodAny$1);
}
const ZodUnknown$1 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
	$ZodUnknown.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => unknownProcessor(inst, ctx, json$2, params);
});
function unknown$1() {
	return _unknown(ZodUnknown$1);
}
const ZodNever$1 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
	$ZodNever.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => neverProcessor(inst, ctx, json$2, params);
});
function never$1(params) {
	return _never(ZodNever$1, params);
}
const ZodVoid$1 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
	$ZodVoid.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => voidProcessor(inst, ctx, json$2, params);
});
function _void$1(params) {
	return _void$2(ZodVoid$1, params);
}
const ZodDate$1 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
	$ZodDate.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => dateProcessor(inst, ctx, json$2, params);
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	const c = inst._zod.bag;
	inst.minDate = c.minimum ? new Date(c.minimum) : null;
	inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date$4(params) {
	return _date(ZodDate$1, params);
}
const ZodArray$1 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
	$ZodArray.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => arrayProcessor(inst, ctx, json$2, params);
	inst.element = def.element;
	inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
	inst.nonempty = (params) => inst.check(_minLength(1, params));
	inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
	inst.length = (len, params) => inst.check(_length(len, params));
	inst.unwrap = () => inst.element;
});
function array$1(element, params) {
	return _array(ZodArray$1, element, params);
}
function keyof$1(schema) {
	const shape = schema._zod.def.shape;
	return _enum$1(Object.keys(shape));
}
const ZodObject$1 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
	$ZodObjectJIT.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => objectProcessor(inst, ctx, json$2, params);
	defineLazy(inst, "shape", () => {
		return def.shape;
	});
	inst.keyof = () => _enum$1(Object.keys(inst._zod.def.shape));
	inst.catchall = (catchall$1) => inst.clone({
		...inst._zod.def,
		catchall: catchall$1
	});
	inst.passthrough = () => inst.clone({
		...inst._zod.def,
		catchall: unknown$1()
	});
	inst.loose = () => inst.clone({
		...inst._zod.def,
		catchall: unknown$1()
	});
	inst.strict = () => inst.clone({
		...inst._zod.def,
		catchall: never$1()
	});
	inst.strip = () => inst.clone({
		...inst._zod.def,
		catchall: undefined
	});
	inst.extend = (incoming) => {
		return extend$1(inst, incoming);
	};
	inst.safeExtend = (incoming) => {
		return safeExtend$1(inst, incoming);
	};
	inst.merge = (other) => merge$1(inst, other);
	inst.pick = (mask) => pick$1(inst, mask);
	inst.omit = (mask) => omit$1(inst, mask);
	inst.partial = (...args) => partial$1(ZodOptional$1, inst, args[0]);
	inst.required = (...args) => required$1(ZodNonOptional, inst, args[0]);
});
function object$1(shape, params) {
	const def = {
		type: "object",
		shape: shape ?? {},
		...normalizeParams(params)
	};
	return new ZodObject$1(def);
}
function strictObject$1(shape, params) {
	return new ZodObject$1({
		type: "object",
		shape,
		catchall: never$1(),
		...normalizeParams(params)
	});
}
function looseObject$1(shape, params) {
	return new ZodObject$1({
		type: "object",
		shape,
		catchall: unknown$1(),
		...normalizeParams(params)
	});
}
const ZodUnion$1 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
	$ZodUnion.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => unionProcessor(inst, ctx, json$2, params);
	inst.options = def.options;
});
function union$1(options, params) {
	return new ZodUnion$1({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
	ZodUnion$1.init(inst, def);
	$ZodXor.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => unionProcessor(inst, ctx, json$2, params);
	inst.options = def.options;
});
/** Creates an exclusive union (XOR) where exactly one option must match.
* Unlike regular unions that succeed when any option matches, xor fails if
* zero or more than one option matches the input. */
function xor$1(options, params) {
	return new ZodXor({
		type: "union",
		options,
		inclusive: false,
		...normalizeParams(params)
	});
}
const ZodDiscriminatedUnion$1 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
	ZodUnion$1.init(inst, def);
	$ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion$1(discriminator, options, params) {
	return new ZodDiscriminatedUnion$1({
		type: "union",
		options,
		discriminator,
		...normalizeParams(params)
	});
}
const ZodIntersection$1 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
	$ZodIntersection.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => intersectionProcessor(inst, ctx, json$2, params);
});
function intersection$1(left, right) {
	return new ZodIntersection$1({
		type: "intersection",
		left,
		right
	});
}
const ZodTuple$1 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
	$ZodTuple.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => tupleProcessor(inst, ctx, json$2, params);
	inst.rest = (rest) => inst.clone({
		...inst._zod.def,
		rest
	});
});
function tuple$1(items, _paramsOrRest, _params) {
	const hasRest = _paramsOrRest instanceof $ZodType;
	const params = hasRest ? _params : _paramsOrRest;
	const rest = hasRest ? _paramsOrRest : null;
	return new ZodTuple$1({
		type: "tuple",
		items,
		rest,
		...normalizeParams(params)
	});
}
const ZodRecord$1 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
	$ZodRecord.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => recordProcessor(inst, ctx, json$2, params);
	inst.keyType = def.keyType;
	inst.valueType = def.valueType;
});
function record$1(keyType, valueType, params) {
	return new ZodRecord$1({
		type: "record",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
function partialRecord$1(keyType, valueType, params) {
	const k = clone(keyType);
	k._zod.values = undefined;
	return new ZodRecord$1({
		type: "record",
		keyType: k,
		valueType,
		...normalizeParams(params)
	});
}
function looseRecord$1(keyType, valueType, params) {
	return new ZodRecord$1({
		type: "record",
		keyType,
		valueType,
		mode: "loose",
		...normalizeParams(params)
	});
}
const ZodMap$1 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
	$ZodMap.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => mapProcessor(inst, ctx, json$2, params);
	inst.keyType = def.keyType;
	inst.valueType = def.valueType;
	inst.min = (...args) => inst.check(_minSize(...args));
	inst.nonempty = (params) => inst.check(_minSize(1, params));
	inst.max = (...args) => inst.check(_maxSize(...args));
	inst.size = (...args) => inst.check(_size(...args));
});
function map$1(keyType, valueType, params) {
	return new ZodMap$1({
		type: "map",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
const ZodSet$1 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
	$ZodSet.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => setProcessor(inst, ctx, json$2, params);
	inst.min = (...args) => inst.check(_minSize(...args));
	inst.nonempty = (params) => inst.check(_minSize(1, params));
	inst.max = (...args) => inst.check(_maxSize(...args));
	inst.size = (...args) => inst.check(_size(...args));
});
function set$1(valueType, params) {
	return new ZodSet$1({
		type: "set",
		valueType,
		...normalizeParams(params)
	});
}
const ZodEnum$1 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
	$ZodEnum.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => enumProcessor(inst, ctx, json$2, params);
	inst.enum = def.entries;
	inst.options = Object.values(def.entries);
	const keys = new Set(Object.keys(def.entries));
	inst.extract = (values, params) => {
		const newEntries = {};
		for (const value of values) {
			if (keys.has(value)) {
				newEntries[value] = def.entries[value];
			} else throw new Error(`Key ${value} not found in enum`);
		}
		return new ZodEnum$1({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
	inst.exclude = (values, params) => {
		const newEntries = { ...def.entries };
		for (const value of values) {
			if (keys.has(value)) {
				delete newEntries[value];
			} else throw new Error(`Key ${value} not found in enum`);
		}
		return new ZodEnum$1({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
});
function _enum$1(values, params) {
	const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
	return new ZodEnum$1({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
*
* ```ts
* enum Colors { red, green, blue }
* z.enum(Colors);
* ```
*/
function nativeEnum$1(entries, params) {
	return new ZodEnum$1({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
const ZodLiteral$1 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
	$ZodLiteral.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => literalProcessor(inst, ctx, json$2, params);
	inst.values = new Set(def.values);
	Object.defineProperty(inst, "value", { get() {
		if (def.values.length > 1) {
			throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
		}
		return def.values[0];
	} });
});
function literal$1(value, params) {
	return new ZodLiteral$1({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
const ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
	$ZodFile.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => fileProcessor(inst, ctx, json$2, params);
	inst.min = (size, params) => inst.check(_minSize(size, params));
	inst.max = (size, params) => inst.check(_maxSize(size, params));
	inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file$1(params) {
	return _file(ZodFile, params);
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
	$ZodTransform.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => transformProcessor(inst, ctx, json$2, params);
	inst._zod.parse = (payload, _ctx) => {
		if (_ctx.direction === "backward") {
			throw new $ZodEncodeError(inst.constructor.name);
		}
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") {
				payload.issues.push(issue(issue$1, payload.value, def));
			} else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = inst);
				payload.issues.push(issue(_issue));
			}
		};
		const output = def.transform(payload.value, payload);
		if (output instanceof Promise) {
			return output.then((output$1) => {
				payload.value = output$1;
				return payload;
			});
		}
		payload.value = output;
		return payload;
	};
});
function transform$1(fn) {
	return new ZodTransform({
		type: "transform",
		transform: fn
	});
}
const ZodOptional$1 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => optionalProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function optional$1(innerType) {
	return new ZodOptional$1({
		type: "optional",
		innerType
	});
}
const ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
	$ZodExactOptional.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => optionalProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional$1(innerType) {
	return new ZodExactOptional({
		type: "optional",
		innerType
	});
}
const ZodNullable$1 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
	$ZodNullable.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => nullableProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nullable$1(innerType) {
	return new ZodNullable$1({
		type: "nullable",
		innerType
	});
}
function nullish$1(innerType) {
	return optional$1(nullable$1(innerType));
}
const ZodDefault$1 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
	$ZodDefault.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => defaultProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeDefault = inst.unwrap;
});
function _default$1(innerType, defaultValue) {
	return new ZodDefault$1({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
	$ZodPrefault.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => prefaultProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function prefault$1(innerType, defaultValue) {
	return new ZodPrefault({
		type: "prefault",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
	$ZodNonOptional.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => nonoptionalProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional$1(innerType, params) {
	return new ZodNonOptional({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
const ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
	$ZodSuccess.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => successProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function success$1(innerType) {
	return new ZodSuccess({
		type: "success",
		innerType
	});
}
const ZodCatch$1 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
	$ZodCatch.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => catchProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeCatch = inst.unwrap;
});
function _catch$1(innerType, catchValue) {
	return new ZodCatch$1({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
const ZodNaN$1 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
	$ZodNaN.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => nanProcessor(inst, ctx, json$2, params);
});
function nan$1(params) {
	return _nan(ZodNaN$1, params);
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
	$ZodPipe.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => pipeProcessor(inst, ctx, json$2, params);
	inst.in = def.in;
	inst.out = def.out;
});
function pipe$1(in_, out) {
	return new ZodPipe({
		type: "pipe",
		in: in_,
		out
	});
}
const ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
	ZodPipe.init(inst, def);
	$ZodCodec.init(inst, def);
});
function codec$1(in_, out, params) {
	return new ZodCodec({
		type: "pipe",
		in: in_,
		out,
		transform: params.decode,
		reverseTransform: params.encode
	});
}
const ZodReadonly$1 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
	$ZodReadonly.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => readonlyProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function readonly$1(innerType) {
	return new ZodReadonly$1({
		type: "readonly",
		innerType
	});
}
const ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
	$ZodTemplateLiteral.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => templateLiteralProcessor(inst, ctx, json$2, params);
});
function templateLiteral$1(parts, params) {
	return new ZodTemplateLiteral({
		type: "template_literal",
		parts,
		...normalizeParams(params)
	});
}
const ZodLazy$1 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
	$ZodLazy.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => lazyProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
	return new ZodLazy$1({
		type: "lazy",
		getter
	});
}
const ZodPromise$1 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
	$ZodPromise.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => promiseProcessor(inst, ctx, json$2, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function promise$1(innerType) {
	return new ZodPromise$1({
		type: "promise",
		innerType
	});
}
const ZodFunction$1 = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
	$ZodFunction.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => functionProcessor(inst, ctx, json$2, params);
});
function _function$1(params) {
	return new ZodFunction$1({
		type: "function",
		input: Array.isArray(params?.input) ? tuple$1(params?.input) : params?.input ?? array$1(unknown$1()),
		output: params?.output ?? unknown$1()
	});
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
	$ZodCustom.init(inst, def);
	ZodType$1.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json$2, params) => customProcessor(inst, ctx, json$2, params);
});
function check$1(fn) {
	const ch = new $ZodCheck({ check: "custom" });
	ch._zod.check = fn;
	return ch;
}
function custom$2(fn, _params) {
	return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine$1(fn, _params = {}) {
	return _refine(ZodCustom, fn, _params);
}
function superRefine$1(fn) {
	return _superRefine(fn);
}
const describe$1 = describe$2;
const meta$1 = meta$2;
function _instanceof$1(cls, params = {}) {
	const inst = new ZodCustom({
		type: "custom",
		check: "custom",
		fn: (data) => data instanceof cls,
		abort: true,
		...normalizeParams(params)
	});
	inst._zod.bag.Class = cls;
	inst._zod.check = (payload) => {
		if (!(payload.value instanceof cls)) {
			payload.issues.push({
				code: "invalid_type",
				expected: cls.name,
				input: payload.value,
				inst,
				path: [...inst._zod.def.path ?? []]
			});
		}
	};
	return inst;
}
const stringbool$1 = (...args) => _stringbool({
	Codec: ZodCodec,
	Boolean: ZodBoolean$1,
	String: ZodString$1
}, ...args);
function json$1(params) {
	const jsonSchema = lazy(() => {
		return union$1([
			string$3(params),
			number$3(),
			boolean$3(),
			_null$1(),
			array$1(jsonSchema),
			record$1(string$3(), jsonSchema)
		]);
	});
	return jsonSchema;
}
function preprocess(fn, schema) {
	return pipe$1(transform$1(fn), schema);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/compat.js
/** @deprecated Use the raw string literal codes instead, e.g. "invalid_type". */
const ZodIssueCode$1 = {
	invalid_type: "invalid_type",
	too_big: "too_big",
	too_small: "too_small",
	invalid_format: "invalid_format",
	not_multiple_of: "not_multiple_of",
	unrecognized_keys: "unrecognized_keys",
	invalid_union: "invalid_union",
	invalid_key: "invalid_key",
	invalid_element: "invalid_element",
	invalid_value: "invalid_value",
	custom: "custom"
};
/** @deprecated Use `z.config(params)` instead. */
function setErrorMap$1(map$2) {
	config({ customError: map$2 });
}
/** @deprecated Use `z.config()` instead. */
function getErrorMap$1() {
	return config().customError;
}
/** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */
var ZodFirstPartyTypeKind$1;
(function(ZodFirstPartyTypeKind$2) {})(ZodFirstPartyTypeKind$1 || (ZodFirstPartyTypeKind$1 = {}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/from-json-schema.js
const z = {
	...schemas_exports,
	...checks_exports,
	iso: iso_exports$1
};
const RECOGNIZED_KEYS = new Set([
	"$schema",
	"$ref",
	"$defs",
	"definitions",
	"$id",
	"id",
	"$comment",
	"$anchor",
	"$vocabulary",
	"$dynamicRef",
	"$dynamicAnchor",
	"type",
	"enum",
	"const",
	"anyOf",
	"oneOf",
	"allOf",
	"not",
	"properties",
	"required",
	"additionalProperties",
	"patternProperties",
	"propertyNames",
	"minProperties",
	"maxProperties",
	"items",
	"prefixItems",
	"additionalItems",
	"minItems",
	"maxItems",
	"uniqueItems",
	"contains",
	"minContains",
	"maxContains",
	"minLength",
	"maxLength",
	"pattern",
	"format",
	"minimum",
	"maximum",
	"exclusiveMinimum",
	"exclusiveMaximum",
	"multipleOf",
	"description",
	"default",
	"contentEncoding",
	"contentMediaType",
	"contentSchema",
	"unevaluatedItems",
	"unevaluatedProperties",
	"if",
	"then",
	"else",
	"dependentSchemas",
	"dependentRequired",
	"nullable",
	"readOnly"
]);
function detectVersion(schema, defaultTarget) {
	const $schema = schema.$schema;
	if ($schema === "https://json-schema.org/draft/2020-12/schema") {
		return "draft-2020-12";
	}
	if ($schema === "http://json-schema.org/draft-07/schema#") {
		return "draft-7";
	}
	if ($schema === "http://json-schema.org/draft-04/schema#") {
		return "draft-4";
	}
	return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
	if (!ref.startsWith("#")) {
		throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
	}
	const path$12 = ref.slice(1).split("/").filter(Boolean);
	if (path$12.length === 0) {
		return ctx.rootSchema;
	}
	const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
	if (path$12[0] === defsKey) {
		const key = path$12[1];
		if (!key || !ctx.defs[key]) {
			throw new Error(`Reference not found: ${ref}`);
		}
		return ctx.defs[key];
	}
	throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
	if (schema.not !== undefined) {
		if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
			return z.never();
		}
		throw new Error("not is not supported in Zod (except { not: {} } for never)");
	}
	if (schema.unevaluatedItems !== undefined) {
		throw new Error("unevaluatedItems is not supported");
	}
	if (schema.unevaluatedProperties !== undefined) {
		throw new Error("unevaluatedProperties is not supported");
	}
	if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {
		throw new Error("Conditional schemas (if/then/else) are not supported");
	}
	if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {
		throw new Error("dependentSchemas and dependentRequired are not supported");
	}
	if (schema.$ref) {
		const refPath = schema.$ref;
		if (ctx.refs.has(refPath)) {
			return ctx.refs.get(refPath);
		}
		if (ctx.processing.has(refPath)) {
			return z.lazy(() => {
				if (!ctx.refs.has(refPath)) {
					throw new Error(`Circular reference not resolved: ${refPath}`);
				}
				return ctx.refs.get(refPath);
			});
		}
		ctx.processing.add(refPath);
		const resolved = resolveRef(refPath, ctx);
		const zodSchema$1 = convertSchema(resolved, ctx);
		ctx.refs.set(refPath, zodSchema$1);
		ctx.processing.delete(refPath);
		return zodSchema$1;
	}
	if (schema.enum !== undefined) {
		const enumValues = schema.enum;
		if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
			return z.null();
		}
		if (enumValues.length === 0) {
			return z.never();
		}
		if (enumValues.length === 1) {
			return z.literal(enumValues[0]);
		}
		if (enumValues.every((v) => typeof v === "string")) {
			return z.enum(enumValues);
		}
		const literalSchemas = enumValues.map((v) => z.literal(v));
		if (literalSchemas.length < 2) {
			return literalSchemas[0];
		}
		return z.union([
			literalSchemas[0],
			literalSchemas[1],
			...literalSchemas.slice(2)
		]);
	}
	if (schema.const !== undefined) {
		return z.literal(schema.const);
	}
	const type = schema.type;
	if (Array.isArray(type)) {
		const typeSchemas = type.map((t) => {
			const typeSchema = {
				...schema,
				type: t
			};
			return convertBaseSchema(typeSchema, ctx);
		});
		if (typeSchemas.length === 0) {
			return z.never();
		}
		if (typeSchemas.length === 1) {
			return typeSchemas[0];
		}
		return z.union(typeSchemas);
	}
	if (!type) {
		return z.any();
	}
	let zodSchema;
	switch (type) {
		case "string": {
			let stringSchema = z.string();
			if (schema.format) {
				const format$2 = schema.format;
				if (format$2 === "email") {
					stringSchema = stringSchema.check(z.email());
				} else if (format$2 === "uri" || format$2 === "uri-reference") {
					stringSchema = stringSchema.check(z.url());
				} else if (format$2 === "uuid" || format$2 === "guid") {
					stringSchema = stringSchema.check(z.uuid());
				} else if (format$2 === "date-time") {
					stringSchema = stringSchema.check(z.iso.datetime());
				} else if (format$2 === "date") {
					stringSchema = stringSchema.check(z.iso.date());
				} else if (format$2 === "time") {
					stringSchema = stringSchema.check(z.iso.time());
				} else if (format$2 === "duration") {
					stringSchema = stringSchema.check(z.iso.duration());
				} else if (format$2 === "ipv4") {
					stringSchema = stringSchema.check(z.ipv4());
				} else if (format$2 === "ipv6") {
					stringSchema = stringSchema.check(z.ipv6());
				} else if (format$2 === "mac") {
					stringSchema = stringSchema.check(z.mac());
				} else if (format$2 === "cidr") {
					stringSchema = stringSchema.check(z.cidrv4());
				} else if (format$2 === "cidr-v6") {
					stringSchema = stringSchema.check(z.cidrv6());
				} else if (format$2 === "base64") {
					stringSchema = stringSchema.check(z.base64());
				} else if (format$2 === "base64url") {
					stringSchema = stringSchema.check(z.base64url());
				} else if (format$2 === "e164") {
					stringSchema = stringSchema.check(z.e164());
				} else if (format$2 === "jwt") {
					stringSchema = stringSchema.check(z.jwt());
				} else if (format$2 === "emoji") {
					stringSchema = stringSchema.check(z.emoji());
				} else if (format$2 === "nanoid") {
					stringSchema = stringSchema.check(z.nanoid());
				} else if (format$2 === "cuid") {
					stringSchema = stringSchema.check(z.cuid());
				} else if (format$2 === "cuid2") {
					stringSchema = stringSchema.check(z.cuid2());
				} else if (format$2 === "ulid") {
					stringSchema = stringSchema.check(z.ulid());
				} else if (format$2 === "xid") {
					stringSchema = stringSchema.check(z.xid());
				} else if (format$2 === "ksuid") {
					stringSchema = stringSchema.check(z.ksuid());
				}
			}
			if (typeof schema.minLength === "number") {
				stringSchema = stringSchema.min(schema.minLength);
			}
			if (typeof schema.maxLength === "number") {
				stringSchema = stringSchema.max(schema.maxLength);
			}
			if (schema.pattern) {
				stringSchema = stringSchema.regex(new RegExp(schema.pattern));
			}
			zodSchema = stringSchema;
			break;
		}
		case "number":
		case "integer": {
			let numberSchema = type === "integer" ? z.number().int() : z.number();
			if (typeof schema.minimum === "number") {
				numberSchema = numberSchema.min(schema.minimum);
			}
			if (typeof schema.maximum === "number") {
				numberSchema = numberSchema.max(schema.maximum);
			}
			if (typeof schema.exclusiveMinimum === "number") {
				numberSchema = numberSchema.gt(schema.exclusiveMinimum);
			} else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
				numberSchema = numberSchema.gt(schema.minimum);
			}
			if (typeof schema.exclusiveMaximum === "number") {
				numberSchema = numberSchema.lt(schema.exclusiveMaximum);
			} else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
				numberSchema = numberSchema.lt(schema.maximum);
			}
			if (typeof schema.multipleOf === "number") {
				numberSchema = numberSchema.multipleOf(schema.multipleOf);
			}
			zodSchema = numberSchema;
			break;
		}
		case "boolean": {
			zodSchema = z.boolean();
			break;
		}
		case "null": {
			zodSchema = z.null();
			break;
		}
		case "object": {
			const shape = {};
			const properties = schema.properties || {};
			const requiredSet = new Set(schema.required || []);
			for (const [key, propSchema] of Object.entries(properties)) {
				const propZodSchema = convertSchema(propSchema, ctx);
				shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
			}
			if (schema.propertyNames) {
				const keySchema = convertSchema(schema.propertyNames, ctx);
				const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
				if (Object.keys(shape).length === 0) {
					zodSchema = z.record(keySchema, valueSchema);
					break;
				}
				const objectSchema$1 = z.object(shape).passthrough();
				const recordSchema = z.looseRecord(keySchema, valueSchema);
				zodSchema = z.intersection(objectSchema$1, recordSchema);
				break;
			}
			if (schema.patternProperties) {
				const patternProps = schema.patternProperties;
				const patternKeys = Object.keys(patternProps);
				const looseRecords = [];
				for (const pattern of patternKeys) {
					const patternValue = convertSchema(patternProps[pattern], ctx);
					const keySchema = z.string().regex(new RegExp(pattern));
					looseRecords.push(z.looseRecord(keySchema, patternValue));
				}
				const schemasToIntersect = [];
				if (Object.keys(shape).length > 0) {
					schemasToIntersect.push(z.object(shape).passthrough());
				}
				schemasToIntersect.push(...looseRecords);
				if (schemasToIntersect.length === 0) {
					zodSchema = z.object({}).passthrough();
				} else if (schemasToIntersect.length === 1) {
					zodSchema = schemasToIntersect[0];
				} else {
					let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
					for (let i = 2; i < schemasToIntersect.length; i++) {
						result = z.intersection(result, schemasToIntersect[i]);
					}
					zodSchema = result;
				}
				break;
			}
			const objectSchema = z.object(shape);
			if (schema.additionalProperties === false) {
				zodSchema = objectSchema.strict();
			} else if (typeof schema.additionalProperties === "object") {
				zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
			} else {
				zodSchema = objectSchema.passthrough();
			}
			break;
		}
		case "array": {
			const prefixItems = schema.prefixItems;
			const items = schema.items;
			if (prefixItems && Array.isArray(prefixItems)) {
				const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
				const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : undefined;
				if (rest) {
					zodSchema = z.tuple(tupleItems).rest(rest);
				} else {
					zodSchema = z.tuple(tupleItems);
				}
				if (typeof schema.minItems === "number") {
					zodSchema = zodSchema.check(z.minLength(schema.minItems));
				}
				if (typeof schema.maxItems === "number") {
					zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
				}
			} else if (Array.isArray(items)) {
				const tupleItems = items.map((item) => convertSchema(item, ctx));
				const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : undefined;
				if (rest) {
					zodSchema = z.tuple(tupleItems).rest(rest);
				} else {
					zodSchema = z.tuple(tupleItems);
				}
				if (typeof schema.minItems === "number") {
					zodSchema = zodSchema.check(z.minLength(schema.minItems));
				}
				if (typeof schema.maxItems === "number") {
					zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
				}
			} else if (items !== undefined) {
				const element = convertSchema(items, ctx);
				let arraySchema = z.array(element);
				if (typeof schema.minItems === "number") {
					arraySchema = arraySchema.min(schema.minItems);
				}
				if (typeof schema.maxItems === "number") {
					arraySchema = arraySchema.max(schema.maxItems);
				}
				zodSchema = arraySchema;
			} else {
				zodSchema = z.array(z.any());
			}
			break;
		}
		default: throw new Error(`Unsupported type: ${type}`);
	}
	if (schema.description) {
		zodSchema = zodSchema.describe(schema.description);
	}
	if (schema.default !== undefined) {
		zodSchema = zodSchema.default(schema.default);
	}
	return zodSchema;
}
function convertSchema(schema, ctx) {
	if (typeof schema === "boolean") {
		return schema ? z.any() : z.never();
	}
	let baseSchema = convertBaseSchema(schema, ctx);
	const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;
	if (schema.anyOf && Array.isArray(schema.anyOf)) {
		const options = schema.anyOf.map((s) => convertSchema(s, ctx));
		const anyOfUnion = z.union(options);
		baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
	}
	if (schema.oneOf && Array.isArray(schema.oneOf)) {
		const options = schema.oneOf.map((s) => convertSchema(s, ctx));
		const oneOfUnion = z.xor(options);
		baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
	}
	if (schema.allOf && Array.isArray(schema.allOf)) {
		if (schema.allOf.length === 0) {
			baseSchema = hasExplicitType ? baseSchema : z.any();
		} else {
			let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
			const startIdx = hasExplicitType ? 0 : 1;
			for (let i = startIdx; i < schema.allOf.length; i++) {
				result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
			}
			baseSchema = result;
		}
	}
	if (schema.nullable === true && ctx.version === "openapi-3.0") {
		baseSchema = z.nullable(baseSchema);
	}
	if (schema.readOnly === true) {
		baseSchema = z.readonly(baseSchema);
	}
	const extraMeta = {};
	const coreMetadataKeys = [
		"$id",
		"id",
		"$comment",
		"$anchor",
		"$vocabulary",
		"$dynamicRef",
		"$dynamicAnchor"
	];
	for (const key of coreMetadataKeys) {
		if (key in schema) {
			extraMeta[key] = schema[key];
		}
	}
	const contentMetadataKeys = [
		"contentEncoding",
		"contentMediaType",
		"contentSchema"
	];
	for (const key of contentMetadataKeys) {
		if (key in schema) {
			extraMeta[key] = schema[key];
		}
	}
	for (const key of Object.keys(schema)) {
		if (!RECOGNIZED_KEYS.has(key)) {
			extraMeta[key] = schema[key];
		}
	}
	if (Object.keys(extraMeta).length > 0) {
		ctx.registry.add(baseSchema, extraMeta);
	}
	return baseSchema;
}
/**
* Converts a JSON Schema to a Zod schema. This function should be considered semi-experimental. It's behavior is liable to change. */
function fromJSONSchema(schema, params) {
	if (typeof schema === "boolean") {
		return schema ? z.any() : z.never();
	}
	const version$1 = detectVersion(schema, params?.defaultTarget);
	const defs = schema.$defs || schema.definitions || {};
	const ctx = {
		version: version$1,
		defs,
		refs: new Map(),
		processing: new Set(),
		rootSchema: schema,
		registry: params?.registry ?? globalRegistry
	};
	return convertSchema(schema, ctx);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/coerce.js
var coerce_exports$1 = /* @__PURE__ */ __exportAll({
	bigint: () => bigint$2,
	boolean: () => boolean$2,
	date: () => date$3,
	number: () => number$2,
	string: () => string$2
});
function string$2(params) {
	return _coercedString(ZodString$1, params);
}
function number$2(params) {
	return _coercedNumber(ZodNumber$1, params);
}
function boolean$2(params) {
	return _coercedBoolean(ZodBoolean$1, params);
}
function bigint$2(params) {
	return _coercedBigint(ZodBigInt$1, params);
}
function date$3(params) {
	return _coercedDate(ZodDate$1, params);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/external.js
var external_exports$2 = /* @__PURE__ */ __exportAll({
	$brand: () => $brand,
	$input: () => $input,
	$output: () => $output,
	NEVER: () => NEVER$1,
	TimePrecision: () => TimePrecision,
	ZodAny: () => ZodAny$1,
	ZodArray: () => ZodArray$1,
	ZodBase64: () => ZodBase64,
	ZodBase64URL: () => ZodBase64URL,
	ZodBigInt: () => ZodBigInt$1,
	ZodBigIntFormat: () => ZodBigIntFormat,
	ZodBoolean: () => ZodBoolean$1,
	ZodCIDRv4: () => ZodCIDRv4,
	ZodCIDRv6: () => ZodCIDRv6,
	ZodCUID: () => ZodCUID,
	ZodCUID2: () => ZodCUID2,
	ZodCatch: () => ZodCatch$1,
	ZodCodec: () => ZodCodec,
	ZodCustom: () => ZodCustom,
	ZodCustomStringFormat: () => ZodCustomStringFormat,
	ZodDate: () => ZodDate$1,
	ZodDefault: () => ZodDefault$1,
	ZodDiscriminatedUnion: () => ZodDiscriminatedUnion$1,
	ZodE164: () => ZodE164,
	ZodEmail: () => ZodEmail,
	ZodEmoji: () => ZodEmoji,
	ZodEnum: () => ZodEnum$1,
	ZodError: () => ZodError$1,
	ZodExactOptional: () => ZodExactOptional,
	ZodFile: () => ZodFile,
	ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind$1,
	ZodFunction: () => ZodFunction$1,
	ZodGUID: () => ZodGUID,
	ZodIPv4: () => ZodIPv4,
	ZodIPv6: () => ZodIPv6,
	ZodISODate: () => ZodISODate,
	ZodISODateTime: () => ZodISODateTime,
	ZodISODuration: () => ZodISODuration,
	ZodISOTime: () => ZodISOTime,
	ZodIntersection: () => ZodIntersection$1,
	ZodIssueCode: () => ZodIssueCode$1,
	ZodJWT: () => ZodJWT,
	ZodKSUID: () => ZodKSUID,
	ZodLazy: () => ZodLazy$1,
	ZodLiteral: () => ZodLiteral$1,
	ZodMAC: () => ZodMAC,
	ZodMap: () => ZodMap$1,
	ZodNaN: () => ZodNaN$1,
	ZodNanoID: () => ZodNanoID,
	ZodNever: () => ZodNever$1,
	ZodNonOptional: () => ZodNonOptional,
	ZodNull: () => ZodNull$1,
	ZodNullable: () => ZodNullable$1,
	ZodNumber: () => ZodNumber$1,
	ZodNumberFormat: () => ZodNumberFormat,
	ZodObject: () => ZodObject$1,
	ZodOptional: () => ZodOptional$1,
	ZodPipe: () => ZodPipe,
	ZodPrefault: () => ZodPrefault,
	ZodPromise: () => ZodPromise$1,
	ZodReadonly: () => ZodReadonly$1,
	ZodRealError: () => ZodRealError,
	ZodRecord: () => ZodRecord$1,
	ZodSet: () => ZodSet$1,
	ZodString: () => ZodString$1,
	ZodStringFormat: () => ZodStringFormat,
	ZodSuccess: () => ZodSuccess,
	ZodSymbol: () => ZodSymbol$1,
	ZodTemplateLiteral: () => ZodTemplateLiteral,
	ZodTransform: () => ZodTransform,
	ZodTuple: () => ZodTuple$1,
	ZodType: () => ZodType$1,
	ZodULID: () => ZodULID,
	ZodURL: () => ZodURL,
	ZodUUID: () => ZodUUID,
	ZodUndefined: () => ZodUndefined$1,
	ZodUnion: () => ZodUnion$1,
	ZodUnknown: () => ZodUnknown$1,
	ZodVoid: () => ZodVoid$1,
	ZodXID: () => ZodXID,
	ZodXor: () => ZodXor,
	_ZodString: () => _ZodString,
	_default: () => _default$1,
	_function: () => _function$1,
	any: () => any$1,
	array: () => array$1,
	base64: () => base64$1,
	base64url: () => base64url$1,
	bigint: () => bigint$3,
	boolean: () => boolean$3,
	catch: () => _catch$1,
	check: () => check$1,
	cidrv4: () => cidrv4$1,
	cidrv6: () => cidrv6$1,
	clone: () => clone,
	codec: () => codec$1,
	coerce: () => coerce_exports$1,
	config: () => config,
	core: () => core_exports,
	cuid: () => cuid$1,
	cuid2: () => cuid2$1,
	custom: () => custom$2,
	date: () => date$4,
	decode: () => decode,
	decodeAsync: () => decodeAsync,
	describe: () => describe$1,
	discriminatedUnion: () => discriminatedUnion$1,
	e164: () => e164$1,
	email: () => email$1,
	emoji: () => emoji$1,
	encode: () => encode,
	encodeAsync: () => encodeAsync,
	endsWith: () => _endsWith,
	enum: () => _enum$1,
	exactOptional: () => exactOptional$1,
	file: () => file$1,
	flattenError: () => flattenError$1,
	float32: () => float32$1,
	float64: () => float64$1,
	formatError: () => formatError,
	fromJSONSchema: () => fromJSONSchema,
	function: () => _function$1,
	getErrorMap: () => getErrorMap$1,
	globalRegistry: () => globalRegistry,
	gt: () => _gt,
	gte: () => _gte,
	guid: () => guid$1,
	hash: () => hash$1,
	hex: () => hex$1,
	hostname: () => hostname$1,
	httpUrl: () => httpUrl$1,
	includes: () => _includes,
	instanceof: () => _instanceof$1,
	int: () => int$1,
	int32: () => int32$1,
	int64: () => int64$1,
	intersection: () => intersection$1,
	ipv4: () => ipv4$1,
	ipv6: () => ipv6$1,
	iso: () => iso_exports$1,
	json: () => json$1,
	jwt: () => jwt$1,
	keyof: () => keyof$1,
	ksuid: () => ksuid$1,
	lazy: () => lazy,
	length: () => _length,
	literal: () => literal$1,
	locales: () => locales_exports,
	looseObject: () => looseObject$1,
	looseRecord: () => looseRecord$1,
	lowercase: () => _lowercase,
	lt: () => _lt,
	lte: () => _lte,
	mac: () => mac$1,
	map: () => map$1,
	maxLength: () => _maxLength,
	maxSize: () => _maxSize,
	meta: () => meta$1,
	mime: () => _mime,
	minLength: () => _minLength,
	minSize: () => _minSize,
	multipleOf: () => _multipleOf,
	nan: () => nan$1,
	nanoid: () => nanoid$1,
	nativeEnum: () => nativeEnum$1,
	negative: () => _negative,
	never: () => never$1,
	nonnegative: () => _nonnegative,
	nonoptional: () => nonoptional$1,
	nonpositive: () => _nonpositive,
	normalize: () => _normalize,
	null: () => _null$1,
	nullable: () => nullable$1,
	nullish: () => nullish$1,
	number: () => number$3,
	object: () => object$1,
	optional: () => optional$1,
	overwrite: () => _overwrite,
	parse: () => parse$2,
	parseAsync: () => parseAsync,
	partialRecord: () => partialRecord$1,
	pipe: () => pipe$1,
	positive: () => _positive,
	prefault: () => prefault$1,
	preprocess: () => preprocess,
	prettifyError: () => prettifyError,
	promise: () => promise$1,
	property: () => _property,
	readonly: () => readonly$1,
	record: () => record$1,
	refine: () => refine$1,
	regex: () => _regex,
	regexes: () => regexes_exports,
	registry: () => registry,
	safeDecode: () => safeDecode,
	safeDecodeAsync: () => safeDecodeAsync,
	safeEncode: () => safeEncode,
	safeEncodeAsync: () => safeEncodeAsync,
	safeParse: () => safeParse$1,
	safeParseAsync: () => safeParseAsync$1,
	set: () => set$1,
	setErrorMap: () => setErrorMap$1,
	size: () => _size,
	slugify: () => _slugify,
	startsWith: () => _startsWith,
	strictObject: () => strictObject$1,
	string: () => string$3,
	stringFormat: () => stringFormat$1,
	stringbool: () => stringbool$1,
	success: () => success$1,
	superRefine: () => superRefine$1,
	symbol: () => symbol$1,
	templateLiteral: () => templateLiteral$1,
	toJSONSchema: () => toJSONSchema,
	toLowerCase: () => _toLowerCase,
	toUpperCase: () => _toUpperCase,
	transform: () => transform$1,
	treeifyError: () => treeifyError,
	trim: () => _trim,
	tuple: () => tuple$1,
	uint32: () => uint32$1,
	uint64: () => uint64$1,
	ulid: () => ulid$1,
	undefined: () => _undefined$1,
	union: () => union$1,
	unknown: () => unknown$1,
	uppercase: () => _uppercase,
	url: () => url$1,
	util: () => util_exports,
	uuid: () => uuid$1,
	uuidv4: () => uuidv4$1,
	uuidv6: () => uuidv6$1,
	uuidv7: () => uuidv7$1,
	void: () => _void$1,
	xid: () => xid$1,
	xor: () => xor$1
});
config(en_default$1());

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/index.js
var zod_default = external_exports$2;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config-schema.js
const ImportKindSchema = _enum$1([
	"cursor",
	"claude-code",
	"claude-desktop",
	"codex",
	"windsurf",
	"opencode",
	"vscode"
]);
const DEFAULT_IMPORTS = [
	"cursor",
	"claude-code",
	"claude-desktop",
	"codex",
	"windsurf",
	"opencode",
	"vscode"
];
const RawLifecycleSchema = union$1([
	literal$1("keep-alive"),
	literal$1("ephemeral"),
	object$1({
		mode: union$1([literal$1("keep-alive"), literal$1("ephemeral")]),
		idleTimeoutMs: number$3().int().positive().optional()
	})
]);
const RawLoggingSchema = object$1({ daemon: object$1({ enabled: boolean$3().optional() }).optional() }).optional();
const RawEntrySchema = object$1({
	description: string$3().optional(),
	baseUrl: string$3().optional(),
	base_url: string$3().optional(),
	url: string$3().optional(),
	serverUrl: string$3().optional(),
	server_url: string$3().optional(),
	command: union$1([string$3(), array$1(string$3())]).optional(),
	executable: string$3().optional(),
	args: array$1(string$3()).optional(),
	headers: record$1(string$3(), string$3()).optional(),
	env: record$1(string$3(), string$3()).optional(),
	auth: string$3().optional(),
	tokenCacheDir: string$3().optional(),
	token_cache_dir: string$3().optional(),
	clientName: string$3().optional(),
	client_name: string$3().optional(),
	oauthRedirectUrl: string$3().optional(),
	oauth_redirect_url: string$3().optional(),
	oauthCommand: object$1({ args: array$1(string$3()) }).optional(),
	oauth_command: object$1({ args: array$1(string$3()) }).optional(),
	bearerToken: string$3().optional(),
	bearer_token: string$3().optional(),
	bearerTokenEnv: string$3().optional(),
	bearer_token_env: string$3().optional(),
	lifecycle: RawLifecycleSchema.optional(),
	logging: RawLoggingSchema
});
const RawConfigSchema = object$1({
	mcpServers: record$1(string$3(), RawEntrySchema),
	imports: array$1(ImportKindSchema).optional()
});

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config/imports/paths-utils.js
function normalizeProjectPath(input) {
	if (!input || typeof input !== "string") {
		return "";
	}
	return node_path.default.resolve(expandHomeShortcut(input));
}
function expandHomeShortcut(input) {
	if (input === "~") {
		return node_os.default.homedir();
	}
	if (input.startsWith("~/") || input.startsWith("~\\")) {
		return node_path.default.join(node_os.default.homedir(), input.slice(2));
	}
	return input;
}
function pathsEqual(a, b) {
	if (!a || !b) {
		return false;
	}
	if (process.platform === "win32") {
		return a.toLowerCase() === b.toLowerCase();
	}
	return a === b;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/jsonc-parser/lib/esm/impl/scanner.js
/**
* Creates a JSON scanner on the given text.
* If ignoreTrivia is set, whitespaces or comments are ignored.
*/
function createScanner$1(text, ignoreTrivia = false) {
	const len = text.length;
	let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
	function scanHexDigits(count, exact) {
		let digits = 0;
		let value$1 = 0;
		while (digits < count || !exact) {
			let ch = text.charCodeAt(pos);
			if (ch >= 48 && ch <= 57) {
				value$1 = value$1 * 16 + ch - 48;
			} else if (ch >= 65 && ch <= 70) {
				value$1 = value$1 * 16 + ch - 65 + 10;
			} else if (ch >= 97 && ch <= 102) {
				value$1 = value$1 * 16 + ch - 97 + 10;
			} else {
				break;
			}
			pos++;
			digits++;
		}
		if (digits < count) {
			value$1 = -1;
		}
		return value$1;
	}
	function setPosition(newPosition) {
		pos = newPosition;
		value = "";
		tokenOffset = 0;
		token = 16;
		scanError = 0;
	}
	function scanNumber() {
		let start = pos;
		if (text.charCodeAt(pos) === 48) {
			pos++;
		} else {
			pos++;
			while (pos < text.length && isDigit(text.charCodeAt(pos))) {
				pos++;
			}
		}
		if (pos < text.length && text.charCodeAt(pos) === 46) {
			pos++;
			if (pos < text.length && isDigit(text.charCodeAt(pos))) {
				pos++;
				while (pos < text.length && isDigit(text.charCodeAt(pos))) {
					pos++;
				}
			} else {
				scanError = 3;
				return text.substring(start, pos);
			}
		}
		let end = pos;
		if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
			pos++;
			if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
				pos++;
			}
			if (pos < text.length && isDigit(text.charCodeAt(pos))) {
				pos++;
				while (pos < text.length && isDigit(text.charCodeAt(pos))) {
					pos++;
				}
				end = pos;
			} else {
				scanError = 3;
			}
		}
		return text.substring(start, end);
	}
	function scanString() {
		let result = "", start = pos;
		while (true) {
			if (pos >= len) {
				result += text.substring(start, pos);
				scanError = 2;
				break;
			}
			const ch = text.charCodeAt(pos);
			if (ch === 34) {
				result += text.substring(start, pos);
				pos++;
				break;
			}
			if (ch === 92) {
				result += text.substring(start, pos);
				pos++;
				if (pos >= len) {
					scanError = 2;
					break;
				}
				const ch2 = text.charCodeAt(pos++);
				switch (ch2) {
					case 34:
						result += "\"";
						break;
					case 92:
						result += "\\";
						break;
					case 47:
						result += "/";
						break;
					case 98:
						result += "\b";
						break;
					case 102:
						result += "\f";
						break;
					case 110:
						result += "\n";
						break;
					case 114:
						result += "\r";
						break;
					case 116:
						result += "	";
						break;
					case 117:
						const ch3 = scanHexDigits(4, true);
						if (ch3 >= 0) {
							result += String.fromCharCode(ch3);
						} else {
							scanError = 4;
						}
						break;
					default: scanError = 5;
				}
				start = pos;
				continue;
			}
			if (ch >= 0 && ch <= 31) {
				if (isLineBreak(ch)) {
					result += text.substring(start, pos);
					scanError = 2;
					break;
				} else {
					scanError = 6;
				}
			}
			pos++;
		}
		return result;
	}
	function scanNext() {
		value = "";
		scanError = 0;
		tokenOffset = pos;
		lineStartOffset = lineNumber;
		prevTokenLineStartOffset = tokenLineStartOffset;
		if (pos >= len) {
			tokenOffset = len;
			return token = 17;
		}
		let code = text.charCodeAt(pos);
		if (isWhiteSpace(code)) {
			do {
				pos++;
				value += String.fromCharCode(code);
				code = text.charCodeAt(pos);
			} while (isWhiteSpace(code));
			return token = 15;
		}
		if (isLineBreak(code)) {
			pos++;
			value += String.fromCharCode(code);
			if (code === 13 && text.charCodeAt(pos) === 10) {
				pos++;
				value += "\n";
			}
			lineNumber++;
			tokenLineStartOffset = pos;
			return token = 14;
		}
		switch (code) {
			case 123:
				pos++;
				return token = 1;
			case 125:
				pos++;
				return token = 2;
			case 91:
				pos++;
				return token = 3;
			case 93:
				pos++;
				return token = 4;
			case 58:
				pos++;
				return token = 6;
			case 44:
				pos++;
				return token = 5;
			case 34:
				pos++;
				value = scanString();
				return token = 10;
			case 47:
				const start = pos - 1;
				if (text.charCodeAt(pos + 1) === 47) {
					pos += 2;
					while (pos < len) {
						if (isLineBreak(text.charCodeAt(pos))) {
							break;
						}
						pos++;
					}
					value = text.substring(start, pos);
					return token = 12;
				}
				if (text.charCodeAt(pos + 1) === 42) {
					pos += 2;
					const safeLength = len - 1;
					let commentClosed = false;
					while (pos < safeLength) {
						const ch = text.charCodeAt(pos);
						if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
							pos += 2;
							commentClosed = true;
							break;
						}
						pos++;
						if (isLineBreak(ch)) {
							if (ch === 13 && text.charCodeAt(pos) === 10) {
								pos++;
							}
							lineNumber++;
							tokenLineStartOffset = pos;
						}
					}
					if (!commentClosed) {
						pos++;
						scanError = 1;
					}
					value = text.substring(start, pos);
					return token = 13;
				}
				value += String.fromCharCode(code);
				pos++;
				return token = 16;
			case 45:
				value += String.fromCharCode(code);
				pos++;
				if (pos === len || !isDigit(text.charCodeAt(pos))) {
					return token = 16;
				}
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
				value += scanNumber();
				return token = 11;
			default:
				while (pos < len && isUnknownContentCharacter(code)) {
					pos++;
					code = text.charCodeAt(pos);
				}
				if (tokenOffset !== pos) {
					value = text.substring(tokenOffset, pos);
					switch (value) {
						case "true": return token = 8;
						case "false": return token = 9;
						case "null": return token = 7;
					}
					return token = 16;
				}
				value += String.fromCharCode(code);
				pos++;
				return token = 16;
		}
	}
	function isUnknownContentCharacter(code) {
		if (isWhiteSpace(code) || isLineBreak(code)) {
			return false;
		}
		switch (code) {
			case 125:
			case 93:
			case 123:
			case 91:
			case 34:
			case 58:
			case 44:
			case 47: return false;
		}
		return true;
	}
	function scanNextNonTrivia() {
		let result;
		do {
			result = scanNext();
		} while (result >= 12 && result <= 15);
		return result;
	}
	return {
		setPosition,
		getPosition: () => pos,
		scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
		getToken: () => token,
		getTokenValue: () => value,
		getTokenOffset: () => tokenOffset,
		getTokenLength: () => pos - tokenOffset,
		getTokenStartLine: () => lineStartOffset,
		getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
		getTokenError: () => scanError
	};
}
function isWhiteSpace(ch) {
	return ch === 32 || ch === 9;
}
function isLineBreak(ch) {
	return ch === 10 || ch === 13;
}
function isDigit(ch) {
	return ch >= 48 && ch <= 57;
}
var CharacterCodes;
(function(CharacterCodes$1) {
	CharacterCodes$1[CharacterCodes$1["lineFeed"] = 10] = "lineFeed";
	CharacterCodes$1[CharacterCodes$1["carriageReturn"] = 13] = "carriageReturn";
	CharacterCodes$1[CharacterCodes$1["space"] = 32] = "space";
	CharacterCodes$1[CharacterCodes$1["_0"] = 48] = "_0";
	CharacterCodes$1[CharacterCodes$1["_1"] = 49] = "_1";
	CharacterCodes$1[CharacterCodes$1["_2"] = 50] = "_2";
	CharacterCodes$1[CharacterCodes$1["_3"] = 51] = "_3";
	CharacterCodes$1[CharacterCodes$1["_4"] = 52] = "_4";
	CharacterCodes$1[CharacterCodes$1["_5"] = 53] = "_5";
	CharacterCodes$1[CharacterCodes$1["_6"] = 54] = "_6";
	CharacterCodes$1[CharacterCodes$1["_7"] = 55] = "_7";
	CharacterCodes$1[CharacterCodes$1["_8"] = 56] = "_8";
	CharacterCodes$1[CharacterCodes$1["_9"] = 57] = "_9";
	CharacterCodes$1[CharacterCodes$1["a"] = 97] = "a";
	CharacterCodes$1[CharacterCodes$1["b"] = 98] = "b";
	CharacterCodes$1[CharacterCodes$1["c"] = 99] = "c";
	CharacterCodes$1[CharacterCodes$1["d"] = 100] = "d";
	CharacterCodes$1[CharacterCodes$1["e"] = 101] = "e";
	CharacterCodes$1[CharacterCodes$1["f"] = 102] = "f";
	CharacterCodes$1[CharacterCodes$1["g"] = 103] = "g";
	CharacterCodes$1[CharacterCodes$1["h"] = 104] = "h";
	CharacterCodes$1[CharacterCodes$1["i"] = 105] = "i";
	CharacterCodes$1[CharacterCodes$1["j"] = 106] = "j";
	CharacterCodes$1[CharacterCodes$1["k"] = 107] = "k";
	CharacterCodes$1[CharacterCodes$1["l"] = 108] = "l";
	CharacterCodes$1[CharacterCodes$1["m"] = 109] = "m";
	CharacterCodes$1[CharacterCodes$1["n"] = 110] = "n";
	CharacterCodes$1[CharacterCodes$1["o"] = 111] = "o";
	CharacterCodes$1[CharacterCodes$1["p"] = 112] = "p";
	CharacterCodes$1[CharacterCodes$1["q"] = 113] = "q";
	CharacterCodes$1[CharacterCodes$1["r"] = 114] = "r";
	CharacterCodes$1[CharacterCodes$1["s"] = 115] = "s";
	CharacterCodes$1[CharacterCodes$1["t"] = 116] = "t";
	CharacterCodes$1[CharacterCodes$1["u"] = 117] = "u";
	CharacterCodes$1[CharacterCodes$1["v"] = 118] = "v";
	CharacterCodes$1[CharacterCodes$1["w"] = 119] = "w";
	CharacterCodes$1[CharacterCodes$1["x"] = 120] = "x";
	CharacterCodes$1[CharacterCodes$1["y"] = 121] = "y";
	CharacterCodes$1[CharacterCodes$1["z"] = 122] = "z";
	CharacterCodes$1[CharacterCodes$1["A"] = 65] = "A";
	CharacterCodes$1[CharacterCodes$1["B"] = 66] = "B";
	CharacterCodes$1[CharacterCodes$1["C"] = 67] = "C";
	CharacterCodes$1[CharacterCodes$1["D"] = 68] = "D";
	CharacterCodes$1[CharacterCodes$1["E"] = 69] = "E";
	CharacterCodes$1[CharacterCodes$1["F"] = 70] = "F";
	CharacterCodes$1[CharacterCodes$1["G"] = 71] = "G";
	CharacterCodes$1[CharacterCodes$1["H"] = 72] = "H";
	CharacterCodes$1[CharacterCodes$1["I"] = 73] = "I";
	CharacterCodes$1[CharacterCodes$1["J"] = 74] = "J";
	CharacterCodes$1[CharacterCodes$1["K"] = 75] = "K";
	CharacterCodes$1[CharacterCodes$1["L"] = 76] = "L";
	CharacterCodes$1[CharacterCodes$1["M"] = 77] = "M";
	CharacterCodes$1[CharacterCodes$1["N"] = 78] = "N";
	CharacterCodes$1[CharacterCodes$1["O"] = 79] = "O";
	CharacterCodes$1[CharacterCodes$1["P"] = 80] = "P";
	CharacterCodes$1[CharacterCodes$1["Q"] = 81] = "Q";
	CharacterCodes$1[CharacterCodes$1["R"] = 82] = "R";
	CharacterCodes$1[CharacterCodes$1["S"] = 83] = "S";
	CharacterCodes$1[CharacterCodes$1["T"] = 84] = "T";
	CharacterCodes$1[CharacterCodes$1["U"] = 85] = "U";
	CharacterCodes$1[CharacterCodes$1["V"] = 86] = "V";
	CharacterCodes$1[CharacterCodes$1["W"] = 87] = "W";
	CharacterCodes$1[CharacterCodes$1["X"] = 88] = "X";
	CharacterCodes$1[CharacterCodes$1["Y"] = 89] = "Y";
	CharacterCodes$1[CharacterCodes$1["Z"] = 90] = "Z";
	CharacterCodes$1[CharacterCodes$1["asterisk"] = 42] = "asterisk";
	CharacterCodes$1[CharacterCodes$1["backslash"] = 92] = "backslash";
	CharacterCodes$1[CharacterCodes$1["closeBrace"] = 125] = "closeBrace";
	CharacterCodes$1[CharacterCodes$1["closeBracket"] = 93] = "closeBracket";
	CharacterCodes$1[CharacterCodes$1["colon"] = 58] = "colon";
	CharacterCodes$1[CharacterCodes$1["comma"] = 44] = "comma";
	CharacterCodes$1[CharacterCodes$1["dot"] = 46] = "dot";
	CharacterCodes$1[CharacterCodes$1["doubleQuote"] = 34] = "doubleQuote";
	CharacterCodes$1[CharacterCodes$1["minus"] = 45] = "minus";
	CharacterCodes$1[CharacterCodes$1["openBrace"] = 123] = "openBrace";
	CharacterCodes$1[CharacterCodes$1["openBracket"] = 91] = "openBracket";
	CharacterCodes$1[CharacterCodes$1["plus"] = 43] = "plus";
	CharacterCodes$1[CharacterCodes$1["slash"] = 47] = "slash";
	CharacterCodes$1[CharacterCodes$1["formFeed"] = 12] = "formFeed";
	CharacterCodes$1[CharacterCodes$1["tab"] = 9] = "tab";
})(CharacterCodes || (CharacterCodes = {}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/jsonc-parser/lib/esm/impl/string-intern.js
const cachedSpaces = new Array(20).fill(0).map((_, index) => {
	return " ".repeat(index);
});
const maxCachedValues = 200;
const cachedBreakLinesWithSpaces = {
	" ": {
		"\n": new Array(maxCachedValues).fill(0).map((_, index) => {
			return "\n" + " ".repeat(index);
		}),
		"\r": new Array(maxCachedValues).fill(0).map((_, index) => {
			return "\r" + " ".repeat(index);
		}),
		"\r\n": new Array(maxCachedValues).fill(0).map((_, index) => {
			return "\r\n" + " ".repeat(index);
		})
	},
	"	": {
		"\n": new Array(maxCachedValues).fill(0).map((_, index) => {
			return "\n" + "	".repeat(index);
		}),
		"\r": new Array(maxCachedValues).fill(0).map((_, index) => {
			return "\r" + "	".repeat(index);
		}),
		"\r\n": new Array(maxCachedValues).fill(0).map((_, index) => {
			return "\r\n" + "	".repeat(index);
		})
	}
};
const supportedEols = [
	"\n",
	"\r",
	"\r\n"
];

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/jsonc-parser/lib/esm/impl/format.js
function format$1(documentText, range, options) {
	let initialIndentLevel;
	let formatText;
	let formatTextStart;
	let rangeStart;
	let rangeEnd;
	if (range) {
		rangeStart = range.offset;
		rangeEnd = rangeStart + range.length;
		formatTextStart = rangeStart;
		while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
			formatTextStart--;
		}
		let endOffset = rangeEnd;
		while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
			endOffset++;
		}
		formatText = documentText.substring(formatTextStart, endOffset);
		initialIndentLevel = computeIndentLevel(formatText, options);
	} else {
		formatText = documentText;
		initialIndentLevel = 0;
		formatTextStart = 0;
		rangeStart = 0;
		rangeEnd = documentText.length;
	}
	const eol = getEOL(options, documentText);
	const eolFastPathSupported = supportedEols.includes(eol);
	let numberLineBreaks = 0;
	let indentLevel = 0;
	let indentValue;
	if (options.insertSpaces) {
		indentValue = cachedSpaces[options.tabSize || 4] ?? repeat(cachedSpaces[1], options.tabSize || 4);
	} else {
		indentValue = "	";
	}
	const indentType = indentValue === "	" ? "	" : " ";
	let scanner = createScanner$1(formatText, false);
	let hasError = false;
	function newLinesAndIndent() {
		if (numberLineBreaks > 1) {
			return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
		}
		const amountOfSpaces = indentValue.length * (initialIndentLevel + indentLevel);
		if (!eolFastPathSupported || amountOfSpaces > cachedBreakLinesWithSpaces[indentType][eol].length) {
			return eol + repeat(indentValue, initialIndentLevel + indentLevel);
		}
		if (amountOfSpaces <= 0) {
			return eol;
		}
		return cachedBreakLinesWithSpaces[indentType][eol][amountOfSpaces];
	}
	function scanNext() {
		let token = scanner.scan();
		numberLineBreaks = 0;
		while (token === 15 || token === 14) {
			if (token === 14 && options.keepLines) {
				numberLineBreaks += 1;
			} else if (token === 14) {
				numberLineBreaks = 1;
			}
			token = scanner.scan();
		}
		hasError = token === 16 || scanner.getTokenError() !== 0;
		return token;
	}
	const editOperations = [];
	function addEdit(text, startOffset, endOffset) {
		if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {
			editOperations.push({
				offset: startOffset,
				length: endOffset - startOffset,
				content: text
			});
		}
	}
	let firstToken = scanNext();
	if (options.keepLines && numberLineBreaks > 0) {
		addEdit(repeat(eol, numberLineBreaks), 0, 0);
	}
	if (firstToken !== 17) {
		let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
		let initialIndent = indentValue.length * initialIndentLevel < 20 && options.insertSpaces ? cachedSpaces[indentValue.length * initialIndentLevel] : repeat(indentValue, initialIndentLevel);
		addEdit(initialIndent, formatTextStart, firstTokenStart);
	}
	while (firstToken !== 17) {
		let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
		let secondToken = scanNext();
		let replaceContent = "";
		let needsLineBreak = false;
		while (numberLineBreaks === 0 && (secondToken === 12 || secondToken === 13)) {
			let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
			addEdit(cachedSpaces[1], firstTokenEnd, commentTokenStart);
			firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
			needsLineBreak = secondToken === 12;
			replaceContent = needsLineBreak ? newLinesAndIndent() : "";
			secondToken = scanNext();
		}
		if (secondToken === 2) {
			if (firstToken !== 1) {
				indentLevel--;
			}
			;
			if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1) {
				replaceContent = newLinesAndIndent();
			} else if (options.keepLines) {
				replaceContent = cachedSpaces[1];
			}
		} else if (secondToken === 4) {
			if (firstToken !== 3) {
				indentLevel--;
			}
			;
			if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3) {
				replaceContent = newLinesAndIndent();
			} else if (options.keepLines) {
				replaceContent = cachedSpaces[1];
			}
		} else {
			switch (firstToken) {
				case 3:
				case 1:
					indentLevel++;
					if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
						replaceContent = newLinesAndIndent();
					} else {
						replaceContent = cachedSpaces[1];
					}
					break;
				case 5:
					if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
						replaceContent = newLinesAndIndent();
					} else {
						replaceContent = cachedSpaces[1];
					}
					break;
				case 12:
					replaceContent = newLinesAndIndent();
					break;
				case 13:
					if (numberLineBreaks > 0) {
						replaceContent = newLinesAndIndent();
					} else if (!needsLineBreak) {
						replaceContent = cachedSpaces[1];
					}
					break;
				case 6:
					if (options.keepLines && numberLineBreaks > 0) {
						replaceContent = newLinesAndIndent();
					} else if (!needsLineBreak) {
						replaceContent = cachedSpaces[1];
					}
					break;
				case 10:
					if (options.keepLines && numberLineBreaks > 0) {
						replaceContent = newLinesAndIndent();
					} else if (secondToken === 6 && !needsLineBreak) {
						replaceContent = "";
					}
					break;
				case 7:
				case 8:
				case 9:
				case 11:
				case 2:
				case 4:
					if (options.keepLines && numberLineBreaks > 0) {
						replaceContent = newLinesAndIndent();
					} else {
						if ((secondToken === 12 || secondToken === 13) && !needsLineBreak) {
							replaceContent = cachedSpaces[1];
						} else if (secondToken !== 5 && secondToken !== 17) {
							hasError = true;
						}
					}
					break;
				case 16:
					hasError = true;
					break;
			}
			if (numberLineBreaks > 0 && (secondToken === 12 || secondToken === 13)) {
				replaceContent = newLinesAndIndent();
			}
		}
		if (secondToken === 17) {
			if (options.keepLines && numberLineBreaks > 0) {
				replaceContent = newLinesAndIndent();
			} else {
				replaceContent = options.insertFinalNewline ? eol : "";
			}
		}
		const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
		addEdit(replaceContent, firstTokenEnd, secondTokenStart);
		firstToken = secondToken;
	}
	return editOperations;
}
function repeat(s, count) {
	let result = "";
	for (let i = 0; i < count; i++) {
		result += s;
	}
	return result;
}
function computeIndentLevel(content, options) {
	let i = 0;
	let nChars = 0;
	const tabSize = options.tabSize || 4;
	while (i < content.length) {
		let ch = content.charAt(i);
		if (ch === cachedSpaces[1]) {
			nChars++;
		} else if (ch === "	") {
			nChars += tabSize;
		} else {
			break;
		}
		i++;
	}
	return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
	for (let i = 0; i < text.length; i++) {
		const ch = text.charAt(i);
		if (ch === "\r") {
			if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
				return "\r\n";
			}
			return "\r";
		} else if (ch === "\n") {
			return "\n";
		}
	}
	return options && options.eol || "\n";
}
function isEOL(text, offset) {
	return "\r\n".indexOf(text.charAt(offset)) !== -1;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/jsonc-parser/lib/esm/impl/parser.js
var ParseOptions;
(function(ParseOptions$1) {
	ParseOptions$1.DEFAULT = { allowTrailingComma: false };
})(ParseOptions || (ParseOptions = {}));
/**
* For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
*/
function getLocation$1(text, position) {
	const segments = [];
	const earlyReturnException = new Object();
	let previousNode = undefined;
	const previousNodeInst = {
		value: {},
		offset: 0,
		length: 0,
		type: "object",
		parent: undefined
	};
	let isAtPropertyKey = false;
	function setPreviousNode(value, offset, length, type) {
		previousNodeInst.value = value;
		previousNodeInst.offset = offset;
		previousNodeInst.length = length;
		previousNodeInst.type = type;
		previousNodeInst.colonOffset = undefined;
		previousNode = previousNodeInst;
	}
	try {
		visit$1(text, {
			onObjectBegin: (offset, length) => {
				if (position <= offset) {
					throw earlyReturnException;
				}
				previousNode = undefined;
				isAtPropertyKey = position > offset;
				segments.push("");
			},
			onObjectProperty: (name, offset, length) => {
				if (position < offset) {
					throw earlyReturnException;
				}
				setPreviousNode(name, offset, length, "property");
				segments[segments.length - 1] = name;
				if (position <= offset + length) {
					throw earlyReturnException;
				}
			},
			onObjectEnd: (offset, length) => {
				if (position <= offset) {
					throw earlyReturnException;
				}
				previousNode = undefined;
				segments.pop();
			},
			onArrayBegin: (offset, length) => {
				if (position <= offset) {
					throw earlyReturnException;
				}
				previousNode = undefined;
				segments.push(0);
			},
			onArrayEnd: (offset, length) => {
				if (position <= offset) {
					throw earlyReturnException;
				}
				previousNode = undefined;
				segments.pop();
			},
			onLiteralValue: (value, offset, length) => {
				if (position < offset) {
					throw earlyReturnException;
				}
				setPreviousNode(value, offset, length, getNodeType(value));
				if (position <= offset + length) {
					throw earlyReturnException;
				}
			},
			onSeparator: (sep, offset, length) => {
				if (position <= offset) {
					throw earlyReturnException;
				}
				if (sep === ":" && previousNode && previousNode.type === "property") {
					previousNode.colonOffset = offset;
					isAtPropertyKey = false;
					previousNode = undefined;
				} else if (sep === ",") {
					const last = segments[segments.length - 1];
					if (typeof last === "number") {
						segments[segments.length - 1] = last + 1;
					} else {
						isAtPropertyKey = true;
						segments[segments.length - 1] = "";
					}
					previousNode = undefined;
				}
			}
		});
	} catch (e) {
		if (e !== earlyReturnException) {
			throw e;
		}
	}
	return {
		path: segments,
		previousNode,
		isAtPropertyKey,
		matches: (pattern) => {
			let k = 0;
			for (let i = 0; k < pattern.length && i < segments.length; i++) {
				if (pattern[k] === segments[i] || pattern[k] === "*") {
					k++;
				} else if (pattern[k] !== "**") {
					return false;
				}
			}
			return k === pattern.length;
		}
	};
}
/**
* Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
* Therefore always check the errors list to find out if the input was valid.
*/
function parse$1(text, errors = [], options = ParseOptions.DEFAULT) {
	let currentProperty = null;
	let currentParent = [];
	const previousParents = [];
	function onValue(value) {
		if (Array.isArray(currentParent)) {
			currentParent.push(value);
		} else if (currentProperty !== null) {
			currentParent[currentProperty] = value;
		}
	}
	const visitor = {
		onObjectBegin: () => {
			const object$2 = {};
			onValue(object$2);
			previousParents.push(currentParent);
			currentParent = object$2;
			currentProperty = null;
		},
		onObjectProperty: (name) => {
			currentProperty = name;
		},
		onObjectEnd: () => {
			currentParent = previousParents.pop();
		},
		onArrayBegin: () => {
			const array$2 = [];
			onValue(array$2);
			previousParents.push(currentParent);
			currentParent = array$2;
			currentProperty = null;
		},
		onArrayEnd: () => {
			currentParent = previousParents.pop();
		},
		onLiteralValue: onValue,
		onError: (error$47, offset, length) => {
			errors.push({
				error: error$47,
				offset,
				length
			});
		}
	};
	visit$1(text, visitor, options);
	return currentParent[0];
}
/**
* Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
*/
function parseTree$1(text, errors = [], options = ParseOptions.DEFAULT) {
	let currentParent = {
		type: "array",
		offset: -1,
		length: -1,
		children: [],
		parent: undefined
	};
	function ensurePropertyComplete(endOffset) {
		if (currentParent.type === "property") {
			currentParent.length = endOffset - currentParent.offset;
			currentParent = currentParent.parent;
		}
	}
	function onValue(valueNode) {
		currentParent.children.push(valueNode);
		return valueNode;
	}
	const visitor = {
		onObjectBegin: (offset) => {
			currentParent = onValue({
				type: "object",
				offset,
				length: -1,
				parent: currentParent,
				children: []
			});
		},
		onObjectProperty: (name, offset, length) => {
			currentParent = onValue({
				type: "property",
				offset,
				length: -1,
				parent: currentParent,
				children: []
			});
			currentParent.children.push({
				type: "string",
				value: name,
				offset,
				length,
				parent: currentParent
			});
		},
		onObjectEnd: (offset, length) => {
			ensurePropertyComplete(offset + length);
			currentParent.length = offset + length - currentParent.offset;
			currentParent = currentParent.parent;
			ensurePropertyComplete(offset + length);
		},
		onArrayBegin: (offset, length) => {
			currentParent = onValue({
				type: "array",
				offset,
				length: -1,
				parent: currentParent,
				children: []
			});
		},
		onArrayEnd: (offset, length) => {
			currentParent.length = offset + length - currentParent.offset;
			currentParent = currentParent.parent;
			ensurePropertyComplete(offset + length);
		},
		onLiteralValue: (value, offset, length) => {
			onValue({
				type: getNodeType(value),
				offset,
				length,
				parent: currentParent,
				value
			});
			ensurePropertyComplete(offset + length);
		},
		onSeparator: (sep, offset, length) => {
			if (currentParent.type === "property") {
				if (sep === ":") {
					currentParent.colonOffset = offset;
				} else if (sep === ",") {
					ensurePropertyComplete(offset);
				}
			}
		},
		onError: (error$47, offset, length) => {
			errors.push({
				error: error$47,
				offset,
				length
			});
		}
	};
	visit$1(text, visitor, options);
	const result = currentParent.children[0];
	if (result) {
		delete result.parent;
	}
	return result;
}
/**
* Finds the node at the given path in a JSON DOM.
*/
function findNodeAtLocation$1(root, path$12) {
	if (!root) {
		return undefined;
	}
	let node = root;
	for (let segment of path$12) {
		if (typeof segment === "string") {
			if (node.type !== "object" || !Array.isArray(node.children)) {
				return undefined;
			}
			let found = false;
			for (const propertyNode of node.children) {
				if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
					node = propertyNode.children[1];
					found = true;
					break;
				}
			}
			if (!found) {
				return undefined;
			}
		} else {
			const index = segment;
			if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
				return undefined;
			}
			node = node.children[index];
		}
	}
	return node;
}
/**
* Gets the JSON path of the given JSON DOM node
*/
function getNodePath$1(node) {
	if (!node.parent || !node.parent.children) {
		return [];
	}
	const path$12 = getNodePath$1(node.parent);
	if (node.parent.type === "property") {
		const key = node.parent.children[0].value;
		path$12.push(key);
	} else if (node.parent.type === "array") {
		const index = node.parent.children.indexOf(node);
		if (index !== -1) {
			path$12.push(index);
		}
	}
	return path$12;
}
/**
* Evaluates the JavaScript object of the given JSON DOM node
*/
function getNodeValue$1(node) {
	switch (node.type) {
		case "array": return node.children.map(getNodeValue$1);
		case "object":
			const obj = Object.create(null);
			for (let prop of node.children) {
				const valueNode = prop.children[1];
				if (valueNode) {
					obj[prop.children[0].value] = getNodeValue$1(valueNode);
				}
			}
			return obj;
		case "null":
		case "string":
		case "number":
		case "boolean": return node.value;
		default: return undefined;
	}
}
function contains(node, offset, includeRightBound = false) {
	return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
}
/**
* Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
*/
function findNodeAtOffset$1(node, offset, includeRightBound = false) {
	if (contains(node, offset, includeRightBound)) {
		const children = node.children;
		if (Array.isArray(children)) {
			for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
				const item = findNodeAtOffset$1(children[i], offset, includeRightBound);
				if (item) {
					return item;
				}
			}
		}
		return node;
	}
	return undefined;
}
/**
* Parses the given text and invokes the visitor functions for each object, array and literal reached.
*/
function visit$1(text, visitor, options = ParseOptions.DEFAULT) {
	const _scanner = createScanner$1(text, false);
	const _jsonPath = [];
	let suppressedCallbacks = 0;
	function toNoArgVisit(visitFunction) {
		return visitFunction ? () => suppressedCallbacks === 0 && visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
	}
	function toOneArgVisit(visitFunction) {
		return visitFunction ? (arg) => suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
	}
	function toOneArgVisitWithPath(visitFunction) {
		return visitFunction ? (arg) => suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
	}
	function toBeginVisit(visitFunction) {
		return visitFunction ? () => {
			if (suppressedCallbacks > 0) {
				suppressedCallbacks++;
			} else {
				let cbReturn = visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice());
				if (cbReturn === false) {
					suppressedCallbacks = 1;
				}
			}
		} : () => true;
	}
	function toEndVisit(visitFunction) {
		return visitFunction ? () => {
			if (suppressedCallbacks > 0) {
				suppressedCallbacks--;
			}
			if (suppressedCallbacks === 0) {
				visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
			}
		} : () => true;
	}
	const onObjectBegin = toBeginVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toEndVisit(visitor.onObjectEnd), onArrayBegin = toBeginVisit(visitor.onArrayBegin), onArrayEnd = toEndVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
	const disallowComments = options && options.disallowComments;
	const allowTrailingComma = options && options.allowTrailingComma;
	function scanNext() {
		while (true) {
			const token = _scanner.scan();
			switch (_scanner.getTokenError()) {
				case 4:
					handleError(14);
					break;
				case 5:
					handleError(15);
					break;
				case 3:
					handleError(13);
					break;
				case 1:
					if (!disallowComments) {
						handleError(11);
					}
					break;
				case 2:
					handleError(12);
					break;
				case 6:
					handleError(16);
					break;
			}
			switch (token) {
				case 12:
				case 13:
					if (disallowComments) {
						handleError(10);
					} else {
						onComment();
					}
					break;
				case 16:
					handleError(1);
					break;
				case 15:
				case 14: break;
				default: return token;
			}
		}
	}
	function handleError(error$47, skipUntilAfter = [], skipUntil = []) {
		onError(error$47);
		if (skipUntilAfter.length + skipUntil.length > 0) {
			let token = _scanner.getToken();
			while (token !== 17) {
				if (skipUntilAfter.indexOf(token) !== -1) {
					scanNext();
					break;
				} else if (skipUntil.indexOf(token) !== -1) {
					break;
				}
				token = scanNext();
			}
		}
	}
	function parseString(isValue) {
		const value = _scanner.getTokenValue();
		if (isValue) {
			onLiteralValue(value);
		} else {
			onObjectProperty(value);
			_jsonPath.push(value);
		}
		scanNext();
		return true;
	}
	function parseLiteral() {
		switch (_scanner.getToken()) {
			case 11:
				const tokenValue = _scanner.getTokenValue();
				let value = Number(tokenValue);
				if (isNaN(value)) {
					handleError(2);
					value = 0;
				}
				onLiteralValue(value);
				break;
			case 7:
				onLiteralValue(null);
				break;
			case 8:
				onLiteralValue(true);
				break;
			case 9:
				onLiteralValue(false);
				break;
			default: return false;
		}
		scanNext();
		return true;
	}
	function parseProperty() {
		if (_scanner.getToken() !== 10) {
			handleError(3, [], [2, 5]);
			return false;
		}
		parseString(false);
		if (_scanner.getToken() === 6) {
			onSeparator(":");
			scanNext();
			if (!parseValue()) {
				handleError(4, [], [2, 5]);
			}
		} else {
			handleError(5, [], [2, 5]);
		}
		_jsonPath.pop();
		return true;
	}
	function parseObject() {
		onObjectBegin();
		scanNext();
		let needsComma = false;
		while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
			if (_scanner.getToken() === 5) {
				if (!needsComma) {
					handleError(4, [], []);
				}
				onSeparator(",");
				scanNext();
				if (_scanner.getToken() === 2 && allowTrailingComma) {
					break;
				}
			} else if (needsComma) {
				handleError(6, [], []);
			}
			if (!parseProperty()) {
				handleError(4, [], [2, 5]);
			}
			needsComma = true;
		}
		onObjectEnd();
		if (_scanner.getToken() !== 2) {
			handleError(7, [2], []);
		} else {
			scanNext();
		}
		return true;
	}
	function parseArray() {
		onArrayBegin();
		scanNext();
		let isFirstElement = true;
		let needsComma = false;
		while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
			if (_scanner.getToken() === 5) {
				if (!needsComma) {
					handleError(4, [], []);
				}
				onSeparator(",");
				scanNext();
				if (_scanner.getToken() === 4 && allowTrailingComma) {
					break;
				}
			} else if (needsComma) {
				handleError(6, [], []);
			}
			if (isFirstElement) {
				_jsonPath.push(0);
				isFirstElement = false;
			} else {
				_jsonPath[_jsonPath.length - 1]++;
			}
			if (!parseValue()) {
				handleError(4, [], [4, 5]);
			}
			needsComma = true;
		}
		onArrayEnd();
		if (!isFirstElement) {
			_jsonPath.pop();
		}
		if (_scanner.getToken() !== 4) {
			handleError(8, [4], []);
		} else {
			scanNext();
		}
		return true;
	}
	function parseValue() {
		switch (_scanner.getToken()) {
			case 3: return parseArray();
			case 1: return parseObject();
			case 10: return parseString(true);
			default: return parseLiteral();
		}
	}
	scanNext();
	if (_scanner.getToken() === 17) {
		if (options.allowEmptyContent) {
			return true;
		}
		handleError(4, [], []);
		return false;
	}
	if (!parseValue()) {
		handleError(4, [], []);
		return false;
	}
	if (_scanner.getToken() !== 17) {
		handleError(9, [], []);
	}
	return true;
}
/**
* Takes JSON with JavaScript-style comments and remove
* them. Optionally replaces every none-newline character
* of comments with a replaceCharacter
*/
function stripComments$1(text, replaceCh) {
	let _scanner = createScanner$1(text), parts = [], kind, offset = 0, pos;
	do {
		pos = _scanner.getPosition();
		kind = _scanner.scan();
		switch (kind) {
			case 12:
			case 13:
			case 17:
				if (offset !== pos) {
					parts.push(text.substring(offset, pos));
				}
				if (replaceCh !== undefined) {
					parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
				}
				offset = _scanner.getPosition();
				break;
		}
	} while (kind !== 17);
	return parts.join("");
}
function getNodeType(value) {
	switch (typeof value) {
		case "boolean": return "boolean";
		case "number": return "number";
		case "string": return "string";
		case "object": {
			if (!value) {
				return "null";
			} else if (Array.isArray(value)) {
				return "array";
			}
			return "object";
		}
		default: return "null";
	}
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/jsonc-parser/lib/esm/impl/edit.js
function removeProperty(text, path$12, options) {
	return setProperty(text, path$12, void 0, options);
}
function setProperty(text, originalPath, value, options) {
	const path$12 = originalPath.slice();
	const errors = [];
	const root = parseTree$1(text, errors);
	let parent = void 0;
	let lastSegment = void 0;
	while (path$12.length > 0) {
		lastSegment = path$12.pop();
		parent = findNodeAtLocation$1(root, path$12);
		if (parent === void 0 && value !== void 0) {
			if (typeof lastSegment === "string") {
				value = { [lastSegment]: value };
			} else {
				value = [value];
			}
		} else {
			break;
		}
	}
	if (!parent) {
		if (value === void 0) {
			throw new Error("Can not delete in empty document");
		}
		return withFormatting(text, {
			offset: root ? root.offset : 0,
			length: root ? root.length : 0,
			content: JSON.stringify(value)
		}, options);
	} else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
		const existing = findNodeAtLocation$1(parent, [lastSegment]);
		if (existing !== void 0) {
			if (value === void 0) {
				if (!existing.parent) {
					throw new Error("Malformed AST");
				}
				const propertyIndex = parent.children.indexOf(existing.parent);
				let removeBegin;
				let removeEnd = existing.parent.offset + existing.parent.length;
				if (propertyIndex > 0) {
					let previous = parent.children[propertyIndex - 1];
					removeBegin = previous.offset + previous.length;
				} else {
					removeBegin = parent.offset + 1;
					if (parent.children.length > 1) {
						let next = parent.children[1];
						removeEnd = next.offset;
					}
				}
				return withFormatting(text, {
					offset: removeBegin,
					length: removeEnd - removeBegin,
					content: ""
				}, options);
			} else {
				return withFormatting(text, {
					offset: existing.offset,
					length: existing.length,
					content: JSON.stringify(value)
				}, options);
			}
		} else {
			if (value === void 0) {
				return [];
			}
			const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
			const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map((p) => p.children[0].value)) : parent.children.length;
			let edit;
			if (index > 0) {
				let previous = parent.children[index - 1];
				edit = {
					offset: previous.offset + previous.length,
					length: 0,
					content: "," + newProperty
				};
			} else if (parent.children.length === 0) {
				edit = {
					offset: parent.offset + 1,
					length: 0,
					content: newProperty
				};
			} else {
				edit = {
					offset: parent.offset + 1,
					length: 0,
					content: newProperty + ","
				};
			}
			return withFormatting(text, edit, options);
		}
	} else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
		const insertIndex = lastSegment;
		if (insertIndex === -1) {
			const newProperty = `${JSON.stringify(value)}`;
			let edit;
			if (parent.children.length === 0) {
				edit = {
					offset: parent.offset + 1,
					length: 0,
					content: newProperty
				};
			} else {
				const previous = parent.children[parent.children.length - 1];
				edit = {
					offset: previous.offset + previous.length,
					length: 0,
					content: "," + newProperty
				};
			}
			return withFormatting(text, edit, options);
		} else if (value === void 0 && parent.children.length >= 0) {
			const removalIndex = lastSegment;
			const toRemove = parent.children[removalIndex];
			let edit;
			if (parent.children.length === 1) {
				edit = {
					offset: parent.offset + 1,
					length: parent.length - 2,
					content: ""
				};
			} else if (parent.children.length - 1 === removalIndex) {
				let previous = parent.children[removalIndex - 1];
				let offset = previous.offset + previous.length;
				let parentEndOffset = parent.offset + parent.length;
				edit = {
					offset,
					length: parentEndOffset - 2 - offset,
					content: ""
				};
			} else {
				edit = {
					offset: toRemove.offset,
					length: parent.children[removalIndex + 1].offset - toRemove.offset,
					content: ""
				};
			}
			return withFormatting(text, edit, options);
		} else if (value !== void 0) {
			let edit;
			const newProperty = `${JSON.stringify(value)}`;
			if (!options.isArrayInsertion && parent.children.length > lastSegment) {
				const toModify = parent.children[lastSegment];
				edit = {
					offset: toModify.offset,
					length: toModify.length,
					content: newProperty
				};
			} else if (parent.children.length === 0 || lastSegment === 0) {
				edit = {
					offset: parent.offset + 1,
					length: 0,
					content: parent.children.length === 0 ? newProperty : newProperty + ","
				};
			} else {
				const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
				const previous = parent.children[index - 1];
				edit = {
					offset: previous.offset + previous.length,
					length: 0,
					content: "," + newProperty
				};
			}
			return withFormatting(text, edit, options);
		} else {
			throw new Error(`Can not ${value === void 0 ? "remove" : options.isArrayInsertion ? "insert" : "modify"} Array index ${insertIndex} as length is not sufficient`);
		}
	} else {
		throw new Error(`Can not add ${typeof lastSegment !== "number" ? "index" : "property"} to parent of type ${parent.type}`);
	}
}
function withFormatting(text, edit, options) {
	if (!options.formattingOptions) {
		return [edit];
	}
	let newText = applyEdit(text, edit);
	let begin = edit.offset;
	let end = edit.offset + edit.content.length;
	if (edit.length === 0 || edit.content.length === 0) {
		while (begin > 0 && !isEOL(newText, begin - 1)) {
			begin--;
		}
		while (end < newText.length && !isEOL(newText, end)) {
			end++;
		}
	}
	const edits = format$1(newText, {
		offset: begin,
		length: end - begin
	}, {
		...options.formattingOptions,
		keepLines: false
	});
	for (let i = edits.length - 1; i >= 0; i--) {
		const edit$1 = edits[i];
		newText = applyEdit(newText, edit$1);
		begin = Math.min(begin, edit$1.offset);
		end = Math.max(end, edit$1.offset + edit$1.length);
		end += edit$1.content.length - edit$1.length;
	}
	const editLength = text.length - (newText.length - end) - begin;
	return [{
		offset: begin,
		length: editLength,
		content: newText.substring(begin, end)
	}];
}
function applyEdit(text, edit) {
	return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
function isWS(text, offset) {
	return "\r\n 	".indexOf(text.charAt(offset)) !== -1;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/jsonc-parser/lib/esm/main.js
/**
* Creates a JSON scanner on the given text.
* If ignoreTrivia is set, whitespaces or comments are ignored.
*/
const createScanner = createScanner$1;
var ScanError;
(function(ScanError$1) {
	ScanError$1[ScanError$1["None"] = 0] = "None";
	ScanError$1[ScanError$1["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
	ScanError$1[ScanError$1["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
	ScanError$1[ScanError$1["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
	ScanError$1[ScanError$1["InvalidUnicode"] = 4] = "InvalidUnicode";
	ScanError$1[ScanError$1["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
	ScanError$1[ScanError$1["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
(function(SyntaxKind$1) {
	SyntaxKind$1[SyntaxKind$1["OpenBraceToken"] = 1] = "OpenBraceToken";
	SyntaxKind$1[SyntaxKind$1["CloseBraceToken"] = 2] = "CloseBraceToken";
	SyntaxKind$1[SyntaxKind$1["OpenBracketToken"] = 3] = "OpenBracketToken";
	SyntaxKind$1[SyntaxKind$1["CloseBracketToken"] = 4] = "CloseBracketToken";
	SyntaxKind$1[SyntaxKind$1["CommaToken"] = 5] = "CommaToken";
	SyntaxKind$1[SyntaxKind$1["ColonToken"] = 6] = "ColonToken";
	SyntaxKind$1[SyntaxKind$1["NullKeyword"] = 7] = "NullKeyword";
	SyntaxKind$1[SyntaxKind$1["TrueKeyword"] = 8] = "TrueKeyword";
	SyntaxKind$1[SyntaxKind$1["FalseKeyword"] = 9] = "FalseKeyword";
	SyntaxKind$1[SyntaxKind$1["StringLiteral"] = 10] = "StringLiteral";
	SyntaxKind$1[SyntaxKind$1["NumericLiteral"] = 11] = "NumericLiteral";
	SyntaxKind$1[SyntaxKind$1["LineCommentTrivia"] = 12] = "LineCommentTrivia";
	SyntaxKind$1[SyntaxKind$1["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
	SyntaxKind$1[SyntaxKind$1["LineBreakTrivia"] = 14] = "LineBreakTrivia";
	SyntaxKind$1[SyntaxKind$1["Trivia"] = 15] = "Trivia";
	SyntaxKind$1[SyntaxKind$1["Unknown"] = 16] = "Unknown";
	SyntaxKind$1[SyntaxKind$1["EOF"] = 17] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
/**
* For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
*/
const getLocation = getLocation$1;
/**
* Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
* Therefore, always check the errors list to find out if the input was valid.
*/
const parse = parse$1;
/**
* Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
*/
const parseTree = parseTree$1;
/**
* Finds the node at the given path in a JSON DOM.
*/
const findNodeAtLocation = findNodeAtLocation$1;
/**
* Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
*/
const findNodeAtOffset = findNodeAtOffset$1;
/**
* Gets the JSON path of the given JSON DOM node
*/
const getNodePath = getNodePath$1;
/**
* Evaluates the JavaScript object of the given JSON DOM node
*/
const getNodeValue = getNodeValue$1;
/**
* Parses the given text and invokes the visitor functions for each object, array and literal reached.
*/
const visit = visit$1;
/**
* Takes JSON with JavaScript-style comments and remove
* them. Optionally replaces every none-newline character
* of comments with a replaceCharacter
*/
const stripComments = stripComments$1;
var ParseErrorCode;
(function(ParseErrorCode$1) {
	ParseErrorCode$1[ParseErrorCode$1["InvalidSymbol"] = 1] = "InvalidSymbol";
	ParseErrorCode$1[ParseErrorCode$1["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
	ParseErrorCode$1[ParseErrorCode$1["PropertyNameExpected"] = 3] = "PropertyNameExpected";
	ParseErrorCode$1[ParseErrorCode$1["ValueExpected"] = 4] = "ValueExpected";
	ParseErrorCode$1[ParseErrorCode$1["ColonExpected"] = 5] = "ColonExpected";
	ParseErrorCode$1[ParseErrorCode$1["CommaExpected"] = 6] = "CommaExpected";
	ParseErrorCode$1[ParseErrorCode$1["CloseBraceExpected"] = 7] = "CloseBraceExpected";
	ParseErrorCode$1[ParseErrorCode$1["CloseBracketExpected"] = 8] = "CloseBracketExpected";
	ParseErrorCode$1[ParseErrorCode$1["EndOfFileExpected"] = 9] = "EndOfFileExpected";
	ParseErrorCode$1[ParseErrorCode$1["InvalidCommentToken"] = 10] = "InvalidCommentToken";
	ParseErrorCode$1[ParseErrorCode$1["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
	ParseErrorCode$1[ParseErrorCode$1["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
	ParseErrorCode$1[ParseErrorCode$1["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
	ParseErrorCode$1[ParseErrorCode$1["InvalidUnicode"] = 14] = "InvalidUnicode";
	ParseErrorCode$1[ParseErrorCode$1["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
	ParseErrorCode$1[ParseErrorCode$1["InvalidCharacter"] = 16] = "InvalidCharacter";
})(ParseErrorCode || (ParseErrorCode = {}));
function printParseErrorCode(code) {
	switch (code) {
		case 1: return "InvalidSymbol";
		case 2: return "InvalidNumberFormat";
		case 3: return "PropertyNameExpected";
		case 4: return "ValueExpected";
		case 5: return "ColonExpected";
		case 6: return "CommaExpected";
		case 7: return "CloseBraceExpected";
		case 8: return "CloseBracketExpected";
		case 9: return "EndOfFileExpected";
		case 10: return "InvalidCommentToken";
		case 11: return "UnexpectedEndOfComment";
		case 12: return "UnexpectedEndOfString";
		case 13: return "UnexpectedEndOfNumber";
		case 14: return "InvalidUnicode";
		case 15: return "InvalidEscapeCharacter";
		case 16: return "InvalidCharacter";
	}
	return "<unknown ParseErrorCode>";
}
/**
* Computes the edit operations needed to format a JSON document.
*
* @param documentText The input text
* @param range The range to format or `undefined` to format the full content
* @param options The formatting options
* @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.
* To apply the edit operations to the input, use {@linkcode applyEdits}.
*/
function format(documentText, range, options) {
	return format$1(documentText, range, options);
}
/**
* Computes the edit operations needed to modify a value in the JSON document.
*
* @param documentText The input text
* @param path The path of the value to change. The path represents either to the document root, a property or an array item.
* If the path points to an non-existing property or item, it will be created.
* @param value The new value for the specified property or item. If the value is undefined,
* the property or item will be removed.
* @param options Options
* @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.
* To apply the edit operations to the input, use {@linkcode applyEdits}.
*/
function modify(text, path$12, value, options) {
	return setProperty(text, path$12, value, options);
}
/**
* Applies edits to an input string.
* @param text The input text
* @param edits Edit operations following the format described in {@linkcode EditResult}.
* @returns The text with the applied edits.
* @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.
*/
function applyEdits(text, edits) {
	let sortedEdits = edits.slice(0).sort((a, b) => {
		const diff = a.offset - b.offset;
		if (diff === 0) {
			return a.length - b.length;
		}
		return diff;
	});
	let lastModifiedOffset = text.length;
	for (let i = sortedEdits.length - 1; i >= 0; i--) {
		let e = sortedEdits[i];
		if (e.offset + e.length <= lastModifiedOffset) {
			text = applyEdit(text, e);
		} else {
			throw new Error("Overlapping edit");
		}
		lastModifiedOffset = e.offset;
	}
	return text;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config/imports/shared.js
async function fileExists(filePath) {
	try {
		await node_fs_promises.default.access(filePath);
		return true;
	} catch {
		return false;
	}
}
function parseJsonBuffer(buffer) {
	const errors = [];
	const parsed = parse(buffer, errors, { allowTrailingComma: true });
	const first = errors[0];
	if (first) {
		const message = printParseErrorCode(first.error);
		throw new SyntaxError(`Failed to parse JSON (offset ${first.offset}): ${message}`);
	}
	return parsed;
}
function isRecord(value) {
	return Boolean(value && typeof value === "object" && !Array.isArray(value));
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config/imports/external.js
async function readExternalEntries(filePath, options = {}) {
	if (!await fileExists(filePath)) {
		return null;
	}
	const buffer = await node_fs_promises.default.readFile(filePath, "utf8");
	if (!buffer.trim()) {
		return new Map();
	}
	try {
		if (filePath.endsWith(".toml")) {
			const parsed$1 = (0, import_toml.parse)(buffer);
			return extractFromCodexConfig(parsed$1);
		}
		const parsed = parseJsonBuffer(buffer);
		return extractFromMcpJson(parsed, options, filePath);
	} catch (error$47) {
		if (shouldIgnoreParseError(error$47)) {
			return new Map();
		}
		throw error$47;
	}
}
function extractFromMcpJson(raw, options, filePath) {
	const map$2 = new Map();
	if (!isRecord(raw)) {
		return map$2;
	}
	const { importKind, projectRoot } = options;
	const descriptor = resolveContainerDescriptor(importKind, filePath);
	const containers = [];
	if (descriptor.allowMcpServers && isRecord(raw.mcpServers)) {
		containers.push(raw.mcpServers);
	}
	if (descriptor.allowServers && isRecord(raw.servers)) {
		containers.push(raw.servers);
	}
	if (descriptor.allowMcp && isRecord(raw.mcp)) {
		containers.push(raw.mcp);
	}
	if (descriptor.allowRootFallback && containers.length === 0) {
		containers.push(raw);
	}
	for (const container of containers) {
		addEntriesFromContainer(container, map$2);
	}
	if (projectRoot) {
		const projectEntries = extractClaudeProjectEntries(raw, projectRoot);
		for (const [name, entry] of projectEntries) {
			if (!map$2.has(name)) {
				map$2.set(name, entry);
			}
		}
	}
	return map$2;
}
function extractFromCodexConfig(raw) {
	const map$2 = new Map();
	const serversRaw = raw.mcp_servers;
	if (!serversRaw || typeof serversRaw !== "object") {
		return map$2;
	}
	for (const [name, value] of Object.entries(serversRaw)) {
		if (!value || typeof value !== "object") {
			continue;
		}
		const entry = convertExternalEntry(value);
		if (entry) {
			map$2.set(name, entry);
		}
	}
	return map$2;
}
function convertExternalEntry(value) {
	const result = {};
	if (typeof value.description === "string") {
		result.description = value.description;
	}
	const env = asStringRecord(value.env);
	if (env) {
		result.env = env;
	}
	const headers = buildExternalHeaders(value);
	if (headers) {
		result.headers = headers;
	}
	const auth$1 = asString$1(value.auth);
	if (auth$1) {
		result.auth = auth$1;
	}
	const tokenCacheDir = asString$1(value.tokenCacheDir ?? value.token_cache_dir ?? value.token_cacheDir);
	if (tokenCacheDir) {
		result.tokenCacheDir = tokenCacheDir;
	}
	const clientName = asString$1(value.clientName ?? value.client_name);
	if (clientName) {
		result.clientName = clientName;
	}
	const url$2 = asString$1(value.baseUrl ?? value.base_url ?? value.url ?? value.serverUrl ?? value.server_url);
	if (url$2) {
		result.baseUrl = url$2;
	}
	const commandValue = value.command ?? value.executable;
	if (Array.isArray(commandValue) && commandValue.every((item) => typeof item === "string")) {
		result.command = commandValue;
	} else if (typeof commandValue === "string") {
		result.command = commandValue;
	}
	if (Array.isArray(value.args) && value.args.every((item) => typeof item === "string")) {
		result.args = value.args;
	}
	const hasHttpTarget = typeof result.baseUrl === "string";
	const hasCommandTarget = typeof result.command === "string" || Array.isArray(result.command) && result.command.length > 0;
	if (!hasHttpTarget && !hasCommandTarget) {
		return null;
	}
	const parsed = RawEntrySchema.safeParse(result);
	return parsed.success ? parsed.data : null;
}
function buildExternalHeaders(record$2) {
	const headers = {};
	const literalHeaders = asStringRecord(record$2.headers);
	if (literalHeaders) {
		Object.assign(headers, literalHeaders);
	}
	const bearerToken = asString$1(record$2.bearerToken ?? record$2.bearer_token);
	if (bearerToken) {
		headers.Authorization = `Bearer ${bearerToken}`;
	}
	const bearerTokenEnv = asString$1(record$2.bearerTokenEnv ?? record$2.bearer_token_env);
	if (bearerTokenEnv) {
		headers.Authorization = `$env:${bearerTokenEnv}`;
	}
	return Object.keys(headers).length > 0 ? headers : undefined;
}
function extractClaudeProjectEntries(raw, projectRoot) {
	const map$2 = new Map();
	if (!isRecord(raw.projects)) {
		return map$2;
	}
	const projects = raw.projects;
	const targetPath = normalizeProjectPath(projectRoot);
	for (const [projectKey, value] of Object.entries(projects)) {
		if (!isRecord(value) || !isRecord(value.mcpServers)) {
			continue;
		}
		const normalizedKey = normalizeProjectPath(projectKey);
		if (!pathsEqual(normalizedKey, targetPath)) {
			continue;
		}
		addEntriesFromContainer(value.mcpServers, map$2);
	}
	return map$2;
}
function addEntriesFromContainer(container, target) {
	for (const [name, value] of Object.entries(container)) {
		if (!isRecord(value)) {
			continue;
		}
		if (target.has(name)) {
			continue;
		}
		const entry = convertExternalEntry(value);
		if (entry) {
			target.set(name, entry);
		}
	}
}
function resolveContainerDescriptor(importKind, filePath) {
	if (importKind === "opencode") {
		return {
			allowMcpServers: false,
			allowServers: false,
			allowMcp: true,
			allowRootFallback: false
		};
	}
	if (importKind === "claude-code" && filePath) {
		const normalized = node_path.default.normalize(filePath);
		const allowRootFallback = normalized.endsWith(".claude.json") || normalized.endsWith(`${node_path.default.sep}.claude${node_path.default.sep}mcp.json`);
		return {
			allowMcpServers: true,
			allowServers: true,
			allowMcp: true,
			allowRootFallback
		};
	}
	return {
		allowMcpServers: true,
		allowServers: true,
		allowMcp: true,
		allowRootFallback: true
	};
}
function asString$1(value) {
	return typeof value === "string" && value.length > 0 ? value : undefined;
}
function asStringRecord(input) {
	if (!input || typeof input !== "object") {
		return undefined;
	}
	const record$2 = {};
	for (const [key, value] of Object.entries(input)) {
		if (typeof value === "string") {
			record$2[key] = value;
		} else if (typeof value === "number" || typeof value === "boolean") {
			record$2[key] = String(value);
		}
	}
	return Object.keys(record$2).length > 0 ? record$2 : undefined;
}
function shouldIgnoreParseError(error$47) {
	if (error$47 instanceof SyntaxError) {
		return true;
	}
	if (!error$47 || typeof error$47 !== "object") {
		return false;
	}
	return "fromTOML" in error$47;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config/imports/paths.js
function pathsForImport(kind, rootDir) {
	switch (kind) {
		case "cursor": return dedupePaths([
			node_path.default.resolve(rootDir, ".cursor", "mcp.json"),
			node_path.default.join(node_os.default.homedir(), ".cursor", "mcp.json"),
			...defaultCursorUserConfigPaths()
		]);
		case "claude-code": return dedupePaths([
			node_path.default.resolve(rootDir, ".claude", "settings.local.json"),
			node_path.default.resolve(rootDir, ".claude", "settings.json"),
			node_path.default.resolve(rootDir, ".claude", "mcp.json"),
			node_path.default.join(node_os.default.homedir(), ".claude", "settings.local.json"),
			node_path.default.join(node_os.default.homedir(), ".claude", "settings.json"),
			node_path.default.join(node_os.default.homedir(), ".claude", "mcp.json"),
			node_path.default.join(node_os.default.homedir(), ".claude.json")
		]);
		case "claude-desktop": return [defaultClaudeDesktopConfigPath()];
		case "codex": return [node_path.default.resolve(rootDir, ".codex", "config.toml"), node_path.default.join(node_os.default.homedir(), ".codex", "config.toml")];
		case "windsurf": return defaultWindsurfConfigPaths();
		case "opencode": return opencodeConfigPaths(rootDir);
		case "vscode": return dedupePaths([node_path.default.resolve(rootDir, ".vscode", "mcp.json"), ...defaultVscodeConfigPaths()]);
		default: return [];
	}
}
function defaultCursorUserConfigPaths() {
	const xdgConfig = process.env.XDG_CONFIG_HOME;
	const configs = xdgConfig ? [node_path.default.join(xdgConfig, "Cursor", "User", "mcp.json")] : [];
	return dedupePaths([
		node_path.default.join(node_os.default.homedir(), "AppData", "Roaming", "Cursor", "User", "mcp.json"),
		node_path.default.join(node_os.default.homedir(), "Library", "Application Support", "Cursor", "User", "mcp.json"),
		...configs
	]);
}
function defaultWindsurfConfigPaths() {
	const homeDir = node_os.default.homedir();
	const paths = [
		node_path.default.join(homeDir, ".codeium", "windsurf", "mcp_config.json"),
		node_path.default.join(homeDir, ".codeium", "windsurf-next", "mcp_config.json"),
		node_path.default.join(homeDir, ".windsurf", "mcp_config.json"),
		node_path.default.join(homeDir, ".config", ".codeium", "windsurf", "mcp_config.json")
	];
	if (process.platform === "win32") {
		const appData = process.env.APPDATA ?? node_path.default.join(homeDir, "AppData", "Roaming");
		paths.push(node_path.default.join(appData, "Codeium", "windsurf", "mcp_config.json"));
	}
	return dedupePaths(paths);
}
function defaultVscodeConfigPaths() {
	if (process.platform === "darwin") {
		return [node_path.default.join(node_os.default.homedir(), "Library", "Application Support", "Code", "User", "mcp.json"), node_path.default.join(node_os.default.homedir(), "Library", "Application Support", "Code - Insiders", "User", "mcp.json")];
	}
	if (process.platform === "win32") {
		const appData = process.env.APPDATA ?? node_path.default.join(node_os.default.homedir(), "AppData", "Roaming");
		return [node_path.default.join(appData, "Code", "User", "mcp.json"), node_path.default.join(appData, "Code - Insiders", "User", "mcp.json")];
	}
	return [node_path.default.join(node_os.default.homedir(), ".config", "Code", "User", "mcp.json"), node_path.default.join(node_os.default.homedir(), ".config", "Code - Insiders", "User", "mcp.json")];
}
function opencodeConfigPaths(rootDir) {
	const overrideConfig = process.env.OPENCODE_CONFIG;
	const overrideDir = process.env.OPENCODE_CONFIG_DIR;
	const envConfigPath = process.env.OPENAI_WORKDIR;
	const xdg = process.env.XDG_CONFIG_HOME;
	const configHome = xdg ?? node_path.default.join(process.env.HOME ?? "", ".config");
	const paths = [
		overrideConfig ?? "",
		node_path.default.resolve(rootDir, "opencode.jsonc"),
		node_path.default.resolve(rootDir, "opencode.json")
	];
	if (overrideDir && overrideDir.length > 0) {
		paths.push(node_path.default.join(overrideDir, "opencode.jsonc"), node_path.default.join(overrideDir, "opencode.json"));
	}
	paths.push(node_path.default.resolve(rootDir, ".openai", "config.json"), envConfigPath ? node_path.default.resolve(envConfigPath, ".openai", "config.json") : "", node_path.default.join(configHome, "openai", "config.json"));
	for (const dir of defaultOpencodeConfigDirs()) {
		paths.push(node_path.default.join(dir, "opencode.jsonc"), node_path.default.join(dir, "opencode.json"));
	}
	return dedupePaths(paths);
}
function defaultOpencodeConfigDirs() {
	const dirs = [];
	const xdg = process.env.XDG_CONFIG_HOME;
	if (xdg && xdg.length > 0) {
		dirs.push(node_path.default.join(xdg, "opencode"));
	} else if (process.platform === "win32") {
		const appData = process.env.APPDATA ?? node_path.default.join(node_os.default.homedir(), "AppData", "Roaming");
		dirs.push(node_path.default.join(appData, "opencode"));
	} else {
		dirs.push(node_path.default.join(node_os.default.homedir(), ".config", "opencode"));
	}
	return dirs;
}
function defaultClaudeDesktopConfigPath() {
	const homeDir = node_os.default.homedir();
	const darwinPath = node_path.default.join(homeDir, "Library", "Application Support", "Claude", "settings.json");
	const windowsPath = node_path.default.join(homeDir, "AppData", "Roaming", "Claude", "settings.json");
	const linuxPath = node_path.default.join(homeDir, ".config", "Claude", "settings.json");
	const platform = process.platform;
	if (platform === "darwin") {
		return darwinPath;
	}
	if (platform === "win32") {
		return windowsPath;
	}
	return linuxPath;
}
function dedupePaths(paths) {
	const seen = new Set();
	const result = [];
	for (const candidate of paths) {
		if (!candidate || seen.has(candidate)) {
			continue;
		}
		seen.add(candidate);
		result.push(candidate);
	}
	return result;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config-imports.js
function toFileUrl(filePath) {
	return (0, node_url.pathToFileURL)(filePath);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/env.js
const ENV_DEFAULT_PATTERN = /^\$\{([A-Za-z_][A-Za-z0-9_]*)(?::-|:|-)?([^}]*)\}$/;
const ENV_INTERPOLATION_PATTERN = /\\?\$\{([A-Za-z_][A-Za-z0-9_]*)\}/g;
const ENV_DIRECT_PREFIX = "$env:";
function expandHome(input) {
	if (!input.startsWith("~")) {
		return input;
	}
	const home = node_os.default.homedir();
	if (input === "~") {
		return home;
	}
	if (input.startsWith("~/")) {
		return `${home}/${input.slice(2)}`;
	}
	return input;
}
function resolveEnvValue(raw) {
	if (typeof raw !== "string") {
		return String(raw);
	}
	const match = ENV_DEFAULT_PATTERN.exec(raw);
	if (match) {
		const envName = match[1];
		const defaultValue = match[2] ?? "";
		if (!envName) {
			return raw;
		}
		const existing = process.env[envName];
		if (existing && existing !== "") {
			return existing;
		}
		return defaultValue;
	}
	if (raw.startsWith("$")) {
		return resolveEnvPlaceholders(raw);
	}
	return raw;
}
function resolveEnvPlaceholders(value) {
	if (value.startsWith(ENV_DIRECT_PREFIX)) {
		const envName = value.slice(ENV_DIRECT_PREFIX.length);
		const envValue = process.env[envName];
		if (envValue === undefined) {
			throw new Error(`Environment variable '${envName}' is required for MCP header substitution.`);
		}
		return envValue;
	}
	const missing = new Set();
	const replaced = value.replace(ENV_INTERPOLATION_PATTERN, (placeholder, envName) => {
		const envValue = process.env[envName];
		if (envValue === undefined) {
			missing.add(envName);
			return placeholder;
		}
		return envValue;
	});
	if (missing.size > 0) {
		const names = [...missing].sort().join(", ");
		throw new Error(`Environment variable(s) ${names} must be set for MCP header substitution.`);
	}
	return replaced;
}
async function withEnvOverrides(envOverrides, fn) {
	if (!envOverrides || Object.keys(envOverrides).length === 0) {
		return await fn();
	}
	const applied = [];
	for (const [key, rawValue] of Object.entries(envOverrides)) {
		if (process.env[key]) {
			continue;
		}
		const resolved = resolveEnvValue(rawValue);
		if (resolved === "") {
			continue;
		}
		process.env[key] = resolved;
		applied.push(key);
	}
	try {
		return await fn();
	} finally {
		for (const key of applied) {
			delete process.env[key];
		}
	}
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/lifecycle.js
const DEFAULT_KEEP_ALIVE = new Set([
	"chrome-devtools",
	"mobile-mcp",
	"playwright"
]);
const includeOverride = parseList(process.env.MCPORTER_KEEPALIVE);
const excludeOverride = parseList(process.env.MCPORTER_DISABLE_KEEPALIVE ?? process.env.MCPORTER_NO_KEEPALIVE);
const KEEP_ALIVE_COMMANDS = [
	{
		label: "chrome-devtools",
		fragments: ["chrome-devtools-mcp"]
	},
	{
		label: "mobile-mcp",
		fragments: ["@mobilenext/mobile-mcp", "mobile-mcp"]
	},
	{
		label: "playwright",
		fragments: ["@playwright/mcp", "playwright/mcp"]
	}
];
const CHROME_DEVTOOLS_URL_PLACEHOLDERS = [String.raw`\${CHROME_DEVTOOLS_URL}`, "$env:CHROME_DEVTOOLS_URL"];
function resolveLifecycle(name, rawLifecycle, command) {
	const normalizedName = name.toLowerCase();
	const canonicalName = canonicalKeepAliveName(command);
	const candidateNames = new Set([normalizedName]);
	if (canonicalName) {
		candidateNames.add(canonicalName);
	}
	const forcedDisable = excludeOverride.all || matchesOverride(excludeOverride.names, candidateNames);
	const forcedEnable = includeOverride.all || matchesOverride(includeOverride.names, candidateNames);
	if (forcedEnable) {
		return { mode: "keep-alive" };
	}
	if (forcedDisable) {
		return undefined;
	}
	const lifecycle = rawLifecycle ? coerceLifecycle(rawLifecycle) : undefined;
	if (lifecycle) {
		return lifecycle;
	}
	if (commandRequiresDynamicChromePort(command)) {
		return { mode: "ephemeral" };
	}
	if (Array.from(candidateNames).some((candidate) => DEFAULT_KEEP_ALIVE.has(candidate))) {
		return { mode: "keep-alive" };
	}
	return undefined;
}
function canonicalKeepAliveName(command) {
	if (command.kind !== "stdio") {
		return undefined;
	}
	const tokens = [command.command, ...command.args].map((token) => token.toLowerCase());
	const match = KEEP_ALIVE_COMMANDS.find((signature) => signature.fragments.some((fragment) => tokens.some((token) => token.includes(fragment))));
	return match?.label;
}
function commandRequiresDynamicChromePort(command) {
	if (command.kind !== "stdio") {
		return false;
	}
	const tokens = [command.command, ...command.args];
	return tokens.some((token) => CHROME_DEVTOOLS_URL_PLACEHOLDERS.some((placeholder) => token.includes(placeholder)));
}
function parseList(value) {
	if (!value) {
		return {
			all: false,
			names: new Set()
		};
	}
	const names = value.split(",").map((token) => token.trim().toLowerCase()).filter((token) => token.length > 0);
	if (names.includes("*")) {
		return {
			all: true,
			names: new Set()
		};
	}
	return {
		all: false,
		names: new Set(names)
	};
}
function matchesOverride(names, candidates) {
	for (const candidate of candidates) {
		if (names.has(candidate)) {
			return true;
		}
	}
	return false;
}
function coerceLifecycle(raw) {
	if (typeof raw === "string") {
		if (raw === "keep-alive") {
			return { mode: "keep-alive" };
		}
		if (raw === "ephemeral") {
			return { mode: "ephemeral" };
		}
		return undefined;
	}
	if (raw.mode === "keep-alive") {
		const timeout = typeof raw.idleTimeoutMs === "number" && Number.isFinite(raw.idleTimeoutMs) && raw.idleTimeoutMs > 0 ? Math.trunc(raw.idleTimeoutMs) : undefined;
		return timeout ? {
			mode: "keep-alive",
			idleTimeoutMs: timeout
		} : { mode: "keep-alive" };
	}
	if (raw.mode === "ephemeral") {
		return { mode: "ephemeral" };
	}
	return undefined;
}
function isKeepAliveServer(definition) {
	return definition?.lifecycle?.mode === "keep-alive";
}
function keepAliveIdleTimeout(definition) {
	if (definition.lifecycle?.mode !== "keep-alive") {
		return undefined;
	}
	return definition.lifecycle.idleTimeoutMs;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config-normalize.js
function normalizeServerEntry(name, raw, baseDir, source, sources) {
	const description = raw.description;
	const env = raw.env ? { ...raw.env } : undefined;
	const auth$1 = normalizeAuth(raw.auth);
	const tokenCacheDir = normalizePath(raw.tokenCacheDir ?? raw.token_cache_dir);
	const clientName = raw.clientName ?? raw.client_name;
	const oauthRedirectUrl = raw.oauthRedirectUrl ?? raw.oauth_redirect_url ?? undefined;
	const oauthCommandRaw = raw.oauthCommand ?? raw.oauth_command;
	const oauthCommand = oauthCommandRaw ? { args: [...oauthCommandRaw.args] } : undefined;
	const headers = buildHeaders(raw);
	const httpUrl$2 = getUrl(raw);
	const stdio = getCommand(raw);
	let command;
	if (httpUrl$2) {
		command = {
			kind: "http",
			url: new URL(httpUrl$2),
			headers: ensureHttpAcceptHeader(headers)
		};
	} else if (stdio) {
		command = {
			kind: "stdio",
			command: stdio.command,
			args: stdio.args,
			cwd: baseDir
		};
	} else {
		throw new Error(`Server '${name}' is missing a baseUrl/url or command definition in mcporter.json`);
	}
	const lifecycle = resolveLifecycle(name, raw.lifecycle, command);
	const logging = normalizeLogging(raw.logging);
	const defaultedOauthCommand = !oauthCommand && name.toLowerCase() === "gmail" && command.kind === "stdio" ? { args: ["auth", "http://localhost:3000/oauth2callback"] } : oauthCommand;
	return {
		name,
		description,
		command,
		env,
		auth: auth$1,
		tokenCacheDir,
		clientName,
		oauthRedirectUrl,
		oauthCommand: defaultedOauthCommand,
		source,
		sources,
		lifecycle,
		logging
	};
}
const __configInternals = { ensureHttpAcceptHeader };
function normalizeAuth(auth$1) {
	if (!auth$1) {
		return undefined;
	}
	if (auth$1.toLowerCase() === "oauth") {
		return "oauth";
	}
	return undefined;
}
function normalizePath(input) {
	if (!input) {
		return undefined;
	}
	return expandHome(input);
}
function getUrl(raw) {
	return raw.baseUrl ?? raw.base_url ?? raw.url ?? raw.serverUrl ?? raw.server_url ?? undefined;
}
function getCommand(raw) {
	const commandValue = raw.command ?? raw.executable;
	if (Array.isArray(commandValue)) {
		if (commandValue.length === 0 || typeof commandValue[0] !== "string") {
			return undefined;
		}
		return {
			command: commandValue[0],
			args: commandValue.slice(1)
		};
	}
	if (typeof commandValue === "string" && commandValue.length > 0) {
		const args = Array.isArray(raw.args) ? raw.args : [];
		if (args.length > 0) {
			return {
				command: commandValue,
				args
			};
		}
		const tokens = parseCommandString(commandValue);
		if (tokens.length === 0) {
			return undefined;
		}
		const [commandToken, ...rest] = tokens;
		if (!commandToken) {
			return undefined;
		}
		return {
			command: commandToken,
			args: rest
		};
	}
	return undefined;
}
function buildHeaders(raw) {
	const headers = {};
	if (raw.headers) {
		Object.assign(headers, raw.headers);
	}
	const bearerToken = raw.bearerToken ?? raw.bearer_token;
	if (bearerToken) {
		headers.Authorization = `Bearer ${bearerToken}`;
	}
	const bearerTokenEnv = raw.bearerTokenEnv ?? raw.bearer_token_env;
	if (bearerTokenEnv) {
		headers.Authorization = `$env:${bearerTokenEnv}`;
	}
	return Object.keys(headers).length > 0 ? headers : undefined;
}
function ensureHttpAcceptHeader(headers) {
	const requiredAccept = "application/json, text/event-stream";
	const normalized = headers ? { ...headers } : {};
	const acceptKey = Object.keys(normalized).find((key) => key.toLowerCase() === "accept");
	const currentValue = acceptKey ? normalized[acceptKey] : undefined;
	if (!currentValue || !hasRequiredAcceptTokens(currentValue)) {
		normalized[acceptKey ?? "accept"] = requiredAccept;
	}
	return Object.keys(normalized).length > 0 ? normalized : undefined;
}
function hasRequiredAcceptTokens(value) {
	const lower = value.toLowerCase();
	return lower.includes("application/json") && lower.includes("text/event-stream");
}
function parseCommandString(value) {
	const result = [];
	let current = "";
	let inSingleQuote = false;
	let inDoubleQuote = false;
	let escapeNext = false;
	for (const char of value.trim()) {
		if (escapeNext) {
			current += char;
			escapeNext = false;
			continue;
		}
		if (char === "\\") {
			escapeNext = true;
			continue;
		}
		if (char === "'" && !inDoubleQuote) {
			inSingleQuote = !inSingleQuote;
			continue;
		}
		if (char === "\"" && !inSingleQuote) {
			inDoubleQuote = !inDoubleQuote;
			continue;
		}
		if (char === " " && !inSingleQuote && !inDoubleQuote) {
			if (current.length > 0) {
				result.push(current);
				current = "";
			}
			continue;
		}
		current += char;
	}
	if (escapeNext) {
		current += "\\";
	}
	if (current.length > 0) {
		result.push(current);
	}
	return result;
}
function normalizeLogging(raw) {
	if (!raw) {
		return undefined;
	}
	if (raw.daemon) {
		const logging = { daemon: { enabled: raw.daemon.enabled } };
		return logging;
	}
	return undefined;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/config.js
async function loadServerDefinitions(options = {}) {
	const rootDir = options.rootDir ?? process.cwd();
	const layers = await loadConfigLayers(options, rootDir);
	const merged = new Map();
	for (const layer of layers) {
		const configuredImports = layer.config.imports;
		const imports = configuredImports ? configuredImports.length === 0 ? configuredImports : [...configuredImports, ...DEFAULT_IMPORTS.filter((kind) => !configuredImports.includes(kind))] : DEFAULT_IMPORTS;
		for (const importKind of imports) {
			const candidates = pathsForImport(importKind, rootDir);
			for (const candidate of candidates) {
				const resolved = expandHome(candidate);
				const entries = await readExternalEntries(resolved, {
					projectRoot: rootDir,
					importKind
				});
				if (!entries) {
					continue;
				}
				for (const [name, rawEntry] of entries) {
					if (merged.has(name)) {
						continue;
					}
					const source = {
						kind: "import",
						path: resolved,
						importKind
					};
					const existing = merged.get(name);
					if (existing) {
						existing.sources.push(source);
						continue;
					}
					merged.set(name, {
						raw: rawEntry,
						baseDir: node_path.default.dirname(resolved),
						source,
						sources: [source]
					});
				}
			}
		}
		for (const [name, entryRaw] of Object.entries(layer.config.mcpServers)) {
			const source = {
				kind: "local",
				path: layer.path
			};
			const parsed = RawEntrySchema.parse(entryRaw);
			const existing = merged.get(name);
			if (existing) {
				const sources = [source, ...existing.sources];
				merged.set(name, {
					raw: parsed,
					baseDir: node_path.default.dirname(layer.path),
					source,
					sources
				});
				continue;
			}
			merged.set(name, {
				raw: parsed,
				baseDir: node_path.default.dirname(layer.path),
				source,
				sources: [source]
			});
		}
	}
	const servers = [];
	for (const [name, { raw, baseDir: entryBaseDir, source, sources }] of merged) {
		servers.push(normalizeServerEntry(name, raw, entryBaseDir, source, sources));
	}
	return servers;
}
async function loadRawConfig(options = {}) {
	const rootDir = options.rootDir ?? process.cwd();
	const resolved = resolveConfigPath(options.configPath, rootDir);
	const config$1 = await readConfigFile(resolved.path, resolved.explicit);
	return {
		config: config$1,
		...resolved
	};
}
async function listConfigLayerPaths(options = {}, rootDir = process.cwd()) {
	const explicitPath = options.configPath ?? process.env.MCPORTER_CONFIG;
	if (explicitPath) {
		return [node_path.default.resolve(expandHome(explicitPath.trim()))];
	}
	const paths = [];
	const homeCandidates = homeConfigCandidates();
	const existingHome = homeCandidates.find((candidate) => pathExists(candidate));
	if (existingHome) {
		paths.push(existingHome);
	}
	const projectPath = node_path.default.resolve(rootDir, "config", "mcporter.json");
	if (pathExists(projectPath)) {
		paths.push(projectPath);
	}
	return paths;
}
async function loadConfigLayers(options, rootDir) {
	const explicitPath = options.configPath ?? process.env.MCPORTER_CONFIG;
	if (explicitPath) {
		const resolvedPath = node_path.default.resolve(expandHome(explicitPath.trim()));
		const config$1 = await readConfigFile(resolvedPath, true);
		return [{
			config: config$1,
			path: resolvedPath,
			explicit: true
		}];
	}
	const layers = [];
	const homeCandidates = homeConfigCandidates();
	const existingHome = homeCandidates.find((candidate) => pathExists(candidate));
	if (existingHome) {
		layers.push({
			config: await readConfigFile(existingHome, false),
			path: existingHome,
			explicit: false
		});
	}
	const projectPath = node_path.default.resolve(rootDir, "config", "mcporter.json");
	if (pathExists(projectPath)) {
		layers.push({
			config: await readConfigFile(projectPath, false),
			path: projectPath,
			explicit: false
		});
	}
	if (layers.length === 0) {
		layers.push({
			config: { mcpServers: {} },
			path: projectPath,
			explicit: false
		});
	}
	return layers;
}
async function writeRawConfig(targetPath, config$1) {
	await node_fs_promises.default.mkdir(node_path.default.dirname(targetPath), { recursive: true });
	const serialized = `${JSON.stringify(config$1, null, 2)}\n`;
	await node_fs_promises.default.writeFile(targetPath, serialized, "utf8");
}
function resolveConfigPath(configPath, rootDir) {
	if (configPath) {
		return {
			path: node_path.default.resolve(configPath),
			explicit: true
		};
	}
	const envConfig = process.env.MCPORTER_CONFIG;
	if (envConfig && envConfig.trim().length > 0) {
		return {
			path: node_path.default.resolve(expandHome(envConfig.trim())),
			explicit: true
		};
	}
	const projectPath = node_path.default.resolve(rootDir, "config", "mcporter.json");
	if (pathExists(projectPath)) {
		return {
			path: projectPath,
			explicit: false
		};
	}
	const homeCandidates = homeConfigCandidates();
	const existingHome = homeCandidates.find((candidate) => pathExists(candidate));
	if (existingHome) {
		return {
			path: existingHome,
			explicit: false
		};
	}
	return {
		path: projectPath,
		explicit: false
	};
}
const warnedConfigPaths = new Set();
async function readConfigFile(configPath, explicit) {
	if (!explicit && !await pathExistsAsync(configPath)) {
		return { mcpServers: {} };
	}
	try {
		const buffer = await node_fs_promises.default.readFile(configPath, "utf8");
		return RawConfigSchema.parse(JSON.parse(buffer));
	} catch (error$47) {
		if (!explicit && isMissingConfigError(error$47)) {
			return { mcpServers: {} };
		}
		if (!explicit && isSyntaxError(error$47)) {
			warnConfigFallback(configPath, error$47);
			return { mcpServers: {} };
		}
		throw error$47;
	}
}
function isErrno(error$47, code) {
	return Boolean(error$47 && typeof error$47 === "object" && error$47.code === code);
}
function isMissingConfigError(error$47) {
	return isErrno(error$47, "ENOENT") || includesErrnoMessage(error$47, "ENOENT");
}
function isSyntaxError(error$47) {
	return error$47 instanceof SyntaxError;
}
function pathExists(filePath) {
	try {
		node_fs.default.accessSync(filePath);
		return true;
	} catch {
		return false;
	}
}
async function pathExistsAsync(filePath) {
	try {
		await node_fs_promises.default.access(filePath);
		return true;
	} catch {
		return false;
	}
}
function warnConfigFallback(configPath, error$47) {
	if (warnedConfigPaths.has(configPath)) {
		return;
	}
	warnedConfigPaths.add(configPath);
	const reason = error$47 instanceof Error ? error$47.message : String(error$47);
	console.warn(`[mcporter] Ignoring config at ${configPath}: ${reason}`);
}
function includesErrnoMessage(error$47, code) {
	if (!error$47 || typeof error$47 !== "object") {
		return false;
	}
	const message = error$47.message;
	return typeof message === "string" && message.includes(code);
}
function homeConfigCandidates() {
	const homeDir = node_os.default.homedir();
	const base = node_path.default.join(homeDir, ".mcporter");
	return [node_path.default.join(base, "mcporter.json"), node_path.default.join(base, "mcporter.jsonc")];
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/pkce-challenge/dist/index.node.js
let crypto$1;
crypto$1 = globalThis.crypto?.webcrypto ?? globalThis.crypto ?? import("node:crypto").then((m) => m.webcrypto);
/**
* Creates an array of length `size` of random bytes
* @param size
* @returns Array of random ints (0 to 255)
*/
async function getRandomValues(size) {
	return (await crypto$1).getRandomValues(new Uint8Array(size));
}
/** Generate cryptographically strong random string
* @param size The desired length of the string
* @returns The random string
*/
async function random(size) {
	const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
	const evenDistCutoff = Math.pow(2, 8) - Math.pow(2, 8) % mask.length;
	let result = "";
	while (result.length < size) {
		const randomBytes = await getRandomValues(size - result.length);
		for (const randomByte of randomBytes) {
			if (randomByte < evenDistCutoff) {
				result += mask[randomByte % mask.length];
			}
		}
	}
	return result;
}
/** Generate a PKCE challenge verifier
* @param length Length of the verifier
* @returns A random verifier `length` characters long
*/
async function generateVerifier(length) {
	return await random(length);
}
/** Generate a PKCE code challenge from a code verifier
* @param code_verifier
* @returns The base64 url encoded code challenge
*/
async function generateChallenge(code_verifier) {
	const buffer = await (await crypto$1).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
	return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
/** Generate a PKCE challenge pair
* @param length Length of the verifer (between 43-128). Defaults to 43.
* @returns PKCE challenge pair
*/
async function pkceChallenge(length) {
	if (!length) length = 43;
	if (length < 43 || length > 128) {
		throw `Expected a length between 43 and 128. Received ${length}.`;
	}
	const verifier = await generateVerifier(length);
	const challenge = await generateChallenge(verifier);
	return {
		code_verifier: verifier,
		code_challenge: challenge
	};
}
/** Verify that a code_verifier produces the expected code challenge
* @param code_verifier
* @param expectedChallenge The code challenge to verify
* @returns True if challenges are equal. False otherwise.
*/
async function verifyChallenge(code_verifier, expectedChallenge) {
	const actualChallenge = await generateChallenge(code_verifier);
	return actualChallenge === expectedChallenge;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/classic/index.js
var classic_default = external_exports$2;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/index.js
var v4_default = classic_default;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
const LATEST_PROTOCOL_VERSION = "2025-11-25";
const DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
const SUPPORTED_PROTOCOL_VERSIONS = [
	LATEST_PROTOCOL_VERSION,
	"2025-06-18",
	"2025-03-26",
	"2024-11-05",
	"2024-10-07"
];
const RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
const JSONRPC_VERSION = "2.0";
/**
* Assert 'object' type schema.
*
* @internal
*/
const AssertObjectSchema = custom$2((v) => v !== null && (typeof v === "object" || typeof v === "function"));
/**
* A progress token, used to associate progress notifications with the original request.
*/
const ProgressTokenSchema = union$1([string$3(), number$3().int()]);
/**
* An opaque token used to represent a cursor for pagination.
*/
const CursorSchema = string$3();
/**
* Task creation parameters, used to ask that the server create a task to represent a request.
*/
const TaskCreationParamsSchema = looseObject$1({
	ttl: union$1([number$3(), _null$1()]).optional(),
	pollInterval: number$3().optional()
});
const TaskMetadataSchema = object$1({ ttl: number$3().optional() });
/**
* Metadata for associating messages with a task.
* Include this in the `_meta` field under the key `io.modelcontextprotocol/related-task`.
*/
const RelatedTaskMetadataSchema = object$1({ taskId: string$3() });
const RequestMetaSchema = looseObject$1({
	progressToken: ProgressTokenSchema.optional(),
	[RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
/**
* Common params for any request.
*/
const BaseRequestParamsSchema = object$1({ _meta: RequestMetaSchema.optional() });
/**
* Common params for any task-augmented request.
*/
const TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({ task: TaskMetadataSchema.optional() });
/**
* Checks if a value is a valid TaskAugmentedRequestParams.
* @param value - The value to check.
*
* @returns True if the value is a valid TaskAugmentedRequestParams, false otherwise.
*/
const isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success;
const RequestSchema = object$1({
	method: string$3(),
	params: BaseRequestParamsSchema.loose().optional()
});
const NotificationsParamsSchema = object$1({ _meta: RequestMetaSchema.optional() });
const NotificationSchema = object$1({
	method: string$3(),
	params: NotificationsParamsSchema.loose().optional()
});
const ResultSchema = looseObject$1({ _meta: RequestMetaSchema.optional() });
/**
* A uniquely identifying ID for a request in JSON-RPC.
*/
const RequestIdSchema = union$1([string$3(), number$3().int()]);
/**
* A request that expects a response.
*/
const JSONRPCRequestSchema = object$1({
	jsonrpc: literal$1(JSONRPC_VERSION),
	id: RequestIdSchema,
	...RequestSchema.shape
}).strict();
const isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
/**
* A notification which does not expect a response.
*/
const JSONRPCNotificationSchema = object$1({
	jsonrpc: literal$1(JSONRPC_VERSION),
	...NotificationSchema.shape
}).strict();
const isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
/**
* A successful (non-error) response to a request.
*/
const JSONRPCResultResponseSchema = object$1({
	jsonrpc: literal$1(JSONRPC_VERSION),
	id: RequestIdSchema,
	result: ResultSchema
}).strict();
/**
* Checks if a value is a valid JSONRPCResultResponse.
* @param value - The value to check.
*
* @returns True if the value is a valid JSONRPCResultResponse, false otherwise.
*/
const isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
/**
* @deprecated Use {@link isJSONRPCResultResponse} instead.
*
* Please note that {@link JSONRPCResponse} is a union of {@link JSONRPCResultResponse} and {@link JSONRPCErrorResponse} as per the updated JSON-RPC specification. (was previously just {@link JSONRPCResultResponse})
*/
const isJSONRPCResponse = isJSONRPCResultResponse;
/**
* Error codes defined by the JSON-RPC specification.
*/
var ErrorCode;
(function(ErrorCode$1) {
	ErrorCode$1[ErrorCode$1["ConnectionClosed"] = -32e3] = "ConnectionClosed";
	ErrorCode$1[ErrorCode$1["RequestTimeout"] = -32001] = "RequestTimeout";
	ErrorCode$1[ErrorCode$1["ParseError"] = -32700] = "ParseError";
	ErrorCode$1[ErrorCode$1["InvalidRequest"] = -32600] = "InvalidRequest";
	ErrorCode$1[ErrorCode$1["MethodNotFound"] = -32601] = "MethodNotFound";
	ErrorCode$1[ErrorCode$1["InvalidParams"] = -32602] = "InvalidParams";
	ErrorCode$1[ErrorCode$1["InternalError"] = -32603] = "InternalError";
	ErrorCode$1[ErrorCode$1["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
/**
* A response to a request that indicates an error occurred.
*/
const JSONRPCErrorResponseSchema = object$1({
	jsonrpc: literal$1(JSONRPC_VERSION),
	id: RequestIdSchema.optional(),
	error: object$1({
		code: number$3().int(),
		message: string$3(),
		data: unknown$1().optional()
	})
}).strict();
/**
* @deprecated Use {@link JSONRPCErrorResponseSchema} instead.
*/
const JSONRPCErrorSchema = JSONRPCErrorResponseSchema;
/**
* Checks if a value is a valid JSONRPCErrorResponse.
* @param value - The value to check.
*
* @returns True if the value is a valid JSONRPCErrorResponse, false otherwise.
*/
const isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
/**
* @deprecated Use {@link isJSONRPCErrorResponse} instead.
*/
const isJSONRPCError = isJSONRPCErrorResponse;
const JSONRPCMessageSchema = union$1([
	JSONRPCRequestSchema,
	JSONRPCNotificationSchema,
	JSONRPCResultResponseSchema,
	JSONRPCErrorResponseSchema
]);
const JSONRPCResponseSchema = union$1([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
/**
* A response that indicates success but carries no data.
*/
const EmptyResultSchema = ResultSchema.strict();
const CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
	requestId: RequestIdSchema.optional(),
	reason: string$3().optional()
});
/**
* This notification can be sent by either side to indicate that it is cancelling a previously-issued request.
*
* The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.
*
* This notification indicates that the result will be unused, so any associated processing SHOULD cease.
*
* A client MUST NOT attempt to cancel its `initialize` request.
*/
const CancelledNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/cancelled"),
	params: CancelledNotificationParamsSchema
});
/**
* Icon schema for use in tools, prompts, resources, and implementations.
*/
const IconSchema = object$1({
	src: string$3(),
	mimeType: string$3().optional(),
	sizes: array$1(string$3()).optional(),
	theme: _enum$1(["light", "dark"]).optional()
});
/**
* Base schema to add `icons` property.
*
*/
const IconsSchema = object$1({ icons: array$1(IconSchema).optional() });
/**
* Base metadata interface for common properties across resources, tools, prompts, and implementations.
*/
const BaseMetadataSchema = object$1({
	name: string$3(),
	title: string$3().optional()
});
/**
* Describes the name and version of an MCP implementation.
*/
const ImplementationSchema = BaseMetadataSchema.extend({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	version: string$3(),
	websiteUrl: string$3().optional(),
	description: string$3().optional()
});
const FormElicitationCapabilitySchema = intersection$1(object$1({ applyDefaults: boolean$3().optional() }), record$1(string$3(), unknown$1()));
const ElicitationCapabilitySchema = preprocess((value) => {
	if (value && typeof value === "object" && !Array.isArray(value)) {
		if (Object.keys(value).length === 0) {
			return { form: {} };
		}
	}
	return value;
}, intersection$1(object$1({
	form: FormElicitationCapabilitySchema.optional(),
	url: AssertObjectSchema.optional()
}), record$1(string$3(), unknown$1()).optional()));
/**
* Task capabilities for clients, indicating which request types support task creation.
*/
const ClientTasksCapabilitySchema = looseObject$1({
	list: AssertObjectSchema.optional(),
	cancel: AssertObjectSchema.optional(),
	requests: looseObject$1({
		sampling: looseObject$1({ createMessage: AssertObjectSchema.optional() }).optional(),
		elicitation: looseObject$1({ create: AssertObjectSchema.optional() }).optional()
	}).optional()
});
/**
* Task capabilities for servers, indicating which request types support task creation.
*/
const ServerTasksCapabilitySchema = looseObject$1({
	list: AssertObjectSchema.optional(),
	cancel: AssertObjectSchema.optional(),
	requests: looseObject$1({ tools: looseObject$1({ call: AssertObjectSchema.optional() }).optional() }).optional()
});
/**
* Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
*/
const ClientCapabilitiesSchema = object$1({
	experimental: record$1(string$3(), AssertObjectSchema).optional(),
	sampling: object$1({
		context: AssertObjectSchema.optional(),
		tools: AssertObjectSchema.optional()
	}).optional(),
	elicitation: ElicitationCapabilitySchema.optional(),
	roots: object$1({ listChanged: boolean$3().optional() }).optional(),
	tasks: ClientTasksCapabilitySchema.optional()
});
const InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
	protocolVersion: string$3(),
	capabilities: ClientCapabilitiesSchema,
	clientInfo: ImplementationSchema
});
/**
* This request is sent from the client to the server when it first connects, asking it to begin initialization.
*/
const InitializeRequestSchema = RequestSchema.extend({
	method: literal$1("initialize"),
	params: InitializeRequestParamsSchema
});
const isInitializeRequest = (value) => InitializeRequestSchema.safeParse(value).success;
/**
* Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
*/
const ServerCapabilitiesSchema = object$1({
	experimental: record$1(string$3(), AssertObjectSchema).optional(),
	logging: AssertObjectSchema.optional(),
	completions: AssertObjectSchema.optional(),
	prompts: object$1({ listChanged: boolean$3().optional() }).optional(),
	resources: object$1({
		subscribe: boolean$3().optional(),
		listChanged: boolean$3().optional()
	}).optional(),
	tools: object$1({ listChanged: boolean$3().optional() }).optional(),
	tasks: ServerTasksCapabilitySchema.optional()
});
/**
* After receiving an initialize request from the client, the server sends this response.
*/
const InitializeResultSchema = ResultSchema.extend({
	protocolVersion: string$3(),
	capabilities: ServerCapabilitiesSchema,
	serverInfo: ImplementationSchema,
	instructions: string$3().optional()
});
/**
* This notification is sent from the client to the server after initialization has finished.
*/
const InitializedNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/initialized"),
	params: NotificationsParamsSchema.optional()
});
const isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
/**
* A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.
*/
const PingRequestSchema = RequestSchema.extend({
	method: literal$1("ping"),
	params: BaseRequestParamsSchema.optional()
});
const ProgressSchema = object$1({
	progress: number$3(),
	total: optional$1(number$3()),
	message: optional$1(string$3())
});
const ProgressNotificationParamsSchema = object$1({
	...NotificationsParamsSchema.shape,
	...ProgressSchema.shape,
	progressToken: ProgressTokenSchema
});
/**
* An out-of-band notification used to inform the receiver of a progress update for a long-running request.
*
* @category notifications/progress
*/
const ProgressNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/progress"),
	params: ProgressNotificationParamsSchema
});
const PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({ cursor: CursorSchema.optional() });
const PaginatedRequestSchema = RequestSchema.extend({ params: PaginatedRequestParamsSchema.optional() });
const PaginatedResultSchema = ResultSchema.extend({ nextCursor: CursorSchema.optional() });
/**
* The status of a task.
* */
const TaskStatusSchema = _enum$1([
	"working",
	"input_required",
	"completed",
	"failed",
	"cancelled"
]);
/**
* A pollable state object associated with a request.
*/
const TaskSchema = object$1({
	taskId: string$3(),
	status: TaskStatusSchema,
	ttl: union$1([number$3(), _null$1()]),
	createdAt: string$3(),
	lastUpdatedAt: string$3(),
	pollInterval: optional$1(number$3()),
	statusMessage: optional$1(string$3())
});
/**
* Result returned when a task is created, containing the task data wrapped in a task field.
*/
const CreateTaskResultSchema = ResultSchema.extend({ task: TaskSchema });
/**
* Parameters for task status notification.
*/
const TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
/**
* A notification sent when a task's status changes.
*/
const TaskStatusNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/tasks/status"),
	params: TaskStatusNotificationParamsSchema
});
/**
* A request to get the state of a specific task.
*/
const GetTaskRequestSchema = RequestSchema.extend({
	method: literal$1("tasks/get"),
	params: BaseRequestParamsSchema.extend({ taskId: string$3() })
});
/**
* The response to a tasks/get request.
*/
const GetTaskResultSchema = ResultSchema.merge(TaskSchema);
/**
* A request to get the result of a specific task.
*/
const GetTaskPayloadRequestSchema = RequestSchema.extend({
	method: literal$1("tasks/result"),
	params: BaseRequestParamsSchema.extend({ taskId: string$3() })
});
/**
* The response to a tasks/result request.
* The structure matches the result type of the original request.
* For example, a tools/call task would return the CallToolResult structure.
*
*/
const GetTaskPayloadResultSchema = ResultSchema.loose();
/**
* A request to list tasks.
*/
const ListTasksRequestSchema = PaginatedRequestSchema.extend({ method: literal$1("tasks/list") });
/**
* The response to a tasks/list request.
*/
const ListTasksResultSchema = PaginatedResultSchema.extend({ tasks: array$1(TaskSchema) });
/**
* A request to cancel a specific task.
*/
const CancelTaskRequestSchema = RequestSchema.extend({
	method: literal$1("tasks/cancel"),
	params: BaseRequestParamsSchema.extend({ taskId: string$3() })
});
/**
* The response to a tasks/cancel request.
*/
const CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
/**
* The contents of a specific resource or sub-resource.
*/
const ResourceContentsSchema = object$1({
	uri: string$3(),
	mimeType: optional$1(string$3()),
	_meta: record$1(string$3(), unknown$1()).optional()
});
const TextResourceContentsSchema = ResourceContentsSchema.extend({ text: string$3() });
/**
* A Zod schema for validating Base64 strings that is more performant and
* robust for very large inputs than the default regex-based check. It avoids
* stack overflows by using the native `atob` function for validation.
*/
const Base64Schema = string$3().refine((val) => {
	try {
		atob(val);
		return true;
	} catch {
		return false;
	}
}, { message: "Invalid Base64 string" });
const BlobResourceContentsSchema = ResourceContentsSchema.extend({ blob: Base64Schema });
/**
* The sender or recipient of messages and data in a conversation.
*/
const RoleSchema = _enum$1(["user", "assistant"]);
/**
* Optional annotations providing clients additional context about a resource.
*/
const AnnotationsSchema = object$1({
	audience: array$1(RoleSchema).optional(),
	priority: number$3().min(0).max(1).optional(),
	lastModified: datetime$1({ offset: true }).optional()
});
/**
* A known resource that the server is capable of reading.
*/
const ResourceSchema = object$1({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	uri: string$3(),
	description: optional$1(string$3()),
	mimeType: optional$1(string$3()),
	annotations: AnnotationsSchema.optional(),
	_meta: optional$1(looseObject$1({}))
});
/**
* A template description for resources available on the server.
*/
const ResourceTemplateSchema = object$1({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	uriTemplate: string$3(),
	description: optional$1(string$3()),
	mimeType: optional$1(string$3()),
	annotations: AnnotationsSchema.optional(),
	_meta: optional$1(looseObject$1({}))
});
/**
* Sent from the client to request a list of resources the server has.
*/
const ListResourcesRequestSchema = PaginatedRequestSchema.extend({ method: literal$1("resources/list") });
/**
* The server's response to a resources/list request from the client.
*/
const ListResourcesResultSchema = PaginatedResultSchema.extend({ resources: array$1(ResourceSchema) });
/**
* Sent from the client to request a list of resource templates the server has.
*/
const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({ method: literal$1("resources/templates/list") });
/**
* The server's response to a resources/templates/list request from the client.
*/
const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({ resourceTemplates: array$1(ResourceTemplateSchema) });
const ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({ uri: string$3() });
/**
* Parameters for a `resources/read` request.
*/
const ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
/**
* Sent from the client to the server, to read a specific resource URI.
*/
const ReadResourceRequestSchema = RequestSchema.extend({
	method: literal$1("resources/read"),
	params: ReadResourceRequestParamsSchema
});
/**
* The server's response to a resources/read request from the client.
*/
const ReadResourceResultSchema = ResultSchema.extend({ contents: array$1(union$1([TextResourceContentsSchema, BlobResourceContentsSchema])) });
/**
* An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.
*/
const ResourceListChangedNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/resources/list_changed"),
	params: NotificationsParamsSchema.optional()
});
const SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
/**
* Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.
*/
const SubscribeRequestSchema = RequestSchema.extend({
	method: literal$1("resources/subscribe"),
	params: SubscribeRequestParamsSchema
});
const UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
/**
* Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.
*/
const UnsubscribeRequestSchema = RequestSchema.extend({
	method: literal$1("resources/unsubscribe"),
	params: UnsubscribeRequestParamsSchema
});
/**
* Parameters for a `notifications/resources/updated` notification.
*/
const ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({ uri: string$3() });
/**
* A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
*/
const ResourceUpdatedNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/resources/updated"),
	params: ResourceUpdatedNotificationParamsSchema
});
/**
* Describes an argument that a prompt can accept.
*/
const PromptArgumentSchema = object$1({
	name: string$3(),
	description: optional$1(string$3()),
	required: optional$1(boolean$3())
});
/**
* A prompt or prompt template that the server offers.
*/
const PromptSchema = object$1({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	description: optional$1(string$3()),
	arguments: optional$1(array$1(PromptArgumentSchema)),
	_meta: optional$1(looseObject$1({}))
});
/**
* Sent from the client to request a list of prompts and prompt templates the server has.
*/
const ListPromptsRequestSchema = PaginatedRequestSchema.extend({ method: literal$1("prompts/list") });
/**
* The server's response to a prompts/list request from the client.
*/
const ListPromptsResultSchema = PaginatedResultSchema.extend({ prompts: array$1(PromptSchema) });
/**
* Parameters for a `prompts/get` request.
*/
const GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
	name: string$3(),
	arguments: record$1(string$3(), string$3()).optional()
});
/**
* Used by the client to get a prompt provided by the server.
*/
const GetPromptRequestSchema = RequestSchema.extend({
	method: literal$1("prompts/get"),
	params: GetPromptRequestParamsSchema
});
/**
* Text provided to or from an LLM.
*/
const TextContentSchema = object$1({
	type: literal$1("text"),
	text: string$3(),
	annotations: AnnotationsSchema.optional(),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* An image provided to or from an LLM.
*/
const ImageContentSchema = object$1({
	type: literal$1("image"),
	data: Base64Schema,
	mimeType: string$3(),
	annotations: AnnotationsSchema.optional(),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* An Audio provided to or from an LLM.
*/
const AudioContentSchema = object$1({
	type: literal$1("audio"),
	data: Base64Schema,
	mimeType: string$3(),
	annotations: AnnotationsSchema.optional(),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* A tool call request from an assistant (LLM).
* Represents the assistant's request to use a tool.
*/
const ToolUseContentSchema = object$1({
	type: literal$1("tool_use"),
	name: string$3(),
	id: string$3(),
	input: record$1(string$3(), unknown$1()),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* The contents of a resource, embedded into a prompt or tool call result.
*/
const EmbeddedResourceSchema = object$1({
	type: literal$1("resource"),
	resource: union$1([TextResourceContentsSchema, BlobResourceContentsSchema]),
	annotations: AnnotationsSchema.optional(),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* A resource that the server is capable of reading, included in a prompt or tool call result.
*
* Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
*/
const ResourceLinkSchema = ResourceSchema.extend({ type: literal$1("resource_link") });
/**
* A content block that can be used in prompts and tool results.
*/
const ContentBlockSchema = union$1([
	TextContentSchema,
	ImageContentSchema,
	AudioContentSchema,
	ResourceLinkSchema,
	EmbeddedResourceSchema
]);
/**
* Describes a message returned as part of a prompt.
*/
const PromptMessageSchema = object$1({
	role: RoleSchema,
	content: ContentBlockSchema
});
/**
* The server's response to a prompts/get request from the client.
*/
const GetPromptResultSchema = ResultSchema.extend({
	description: string$3().optional(),
	messages: array$1(PromptMessageSchema)
});
/**
* An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.
*/
const PromptListChangedNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/prompts/list_changed"),
	params: NotificationsParamsSchema.optional()
});
/**
* Additional properties describing a Tool to clients.
*
* NOTE: all properties in ToolAnnotations are **hints**.
* They are not guaranteed to provide a faithful description of
* tool behavior (including descriptive properties like `title`).
*
* Clients should never make tool use decisions based on ToolAnnotations
* received from untrusted servers.
*/
const ToolAnnotationsSchema = object$1({
	title: string$3().optional(),
	readOnlyHint: boolean$3().optional(),
	destructiveHint: boolean$3().optional(),
	idempotentHint: boolean$3().optional(),
	openWorldHint: boolean$3().optional()
});
/**
* Execution-related properties for a tool.
*/
const ToolExecutionSchema = object$1({ taskSupport: _enum$1([
	"required",
	"optional",
	"forbidden"
]).optional() });
/**
* Definition for a tool the client can call.
*/
const ToolSchema = object$1({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	description: string$3().optional(),
	inputSchema: object$1({
		type: literal$1("object"),
		properties: record$1(string$3(), AssertObjectSchema).optional(),
		required: array$1(string$3()).optional()
	}).catchall(unknown$1()),
	outputSchema: object$1({
		type: literal$1("object"),
		properties: record$1(string$3(), AssertObjectSchema).optional(),
		required: array$1(string$3()).optional()
	}).catchall(unknown$1()).optional(),
	annotations: ToolAnnotationsSchema.optional(),
	execution: ToolExecutionSchema.optional(),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* Sent from the client to request a list of tools the server has.
*/
const ListToolsRequestSchema = PaginatedRequestSchema.extend({ method: literal$1("tools/list") });
/**
* The server's response to a tools/list request from the client.
*/
const ListToolsResultSchema = PaginatedResultSchema.extend({ tools: array$1(ToolSchema) });
/**
* The server's response to a tool call.
*/
const CallToolResultSchema = ResultSchema.extend({
	content: array$1(ContentBlockSchema).default([]),
	structuredContent: record$1(string$3(), unknown$1()).optional(),
	isError: boolean$3().optional()
});
/**
* CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.
*/
const CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({ toolResult: unknown$1() }));
/**
* Parameters for a `tools/call` request.
*/
const CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
	name: string$3(),
	arguments: record$1(string$3(), unknown$1()).optional()
});
/**
* Used by the client to invoke a tool provided by the server.
*/
const CallToolRequestSchema = RequestSchema.extend({
	method: literal$1("tools/call"),
	params: CallToolRequestParamsSchema
});
/**
* An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.
*/
const ToolListChangedNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/tools/list_changed"),
	params: NotificationsParamsSchema.optional()
});
/**
* Base schema for list changed subscription options (without callback).
* Used internally for Zod validation of autoRefresh and debounceMs.
*/
const ListChangedOptionsBaseSchema = object$1({
	autoRefresh: boolean$3().default(true),
	debounceMs: number$3().int().nonnegative().default(300)
});
/**
* The severity of a log message.
*/
const LoggingLevelSchema = _enum$1([
	"debug",
	"info",
	"notice",
	"warning",
	"error",
	"critical",
	"alert",
	"emergency"
]);
/**
* Parameters for a `logging/setLevel` request.
*/
const SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({ level: LoggingLevelSchema });
/**
* A request from the client to the server, to enable or adjust logging.
*/
const SetLevelRequestSchema = RequestSchema.extend({
	method: literal$1("logging/setLevel"),
	params: SetLevelRequestParamsSchema
});
/**
* Parameters for a `notifications/message` notification.
*/
const LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
	level: LoggingLevelSchema,
	logger: string$3().optional(),
	data: unknown$1()
});
/**
* Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
*/
const LoggingMessageNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/message"),
	params: LoggingMessageNotificationParamsSchema
});
/**
* Hints to use for model selection.
*/
const ModelHintSchema = object$1({ name: string$3().optional() });
/**
* The server's preferences for model selection, requested of the client during sampling.
*/
const ModelPreferencesSchema = object$1({
	hints: array$1(ModelHintSchema).optional(),
	costPriority: number$3().min(0).max(1).optional(),
	speedPriority: number$3().min(0).max(1).optional(),
	intelligencePriority: number$3().min(0).max(1).optional()
});
/**
* Controls tool usage behavior in sampling requests.
*/
const ToolChoiceSchema = object$1({ mode: _enum$1([
	"auto",
	"required",
	"none"
]).optional() });
/**
* The result of a tool execution, provided by the user (server).
* Represents the outcome of invoking a tool requested via ToolUseContent.
*/
const ToolResultContentSchema = object$1({
	type: literal$1("tool_result"),
	toolUseId: string$3().describe("The unique identifier for the corresponding tool call."),
	content: array$1(ContentBlockSchema).default([]),
	structuredContent: object$1({}).loose().optional(),
	isError: boolean$3().optional(),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* Basic content types for sampling responses (without tool use).
* Used for backwards-compatible CreateMessageResult when tools are not used.
*/
const SamplingContentSchema = discriminatedUnion$1("type", [
	TextContentSchema,
	ImageContentSchema,
	AudioContentSchema
]);
/**
* Content block types allowed in sampling messages.
* This includes text, image, audio, tool use requests, and tool results.
*/
const SamplingMessageContentBlockSchema = discriminatedUnion$1("type", [
	TextContentSchema,
	ImageContentSchema,
	AudioContentSchema,
	ToolUseContentSchema,
	ToolResultContentSchema
]);
/**
* Describes a message issued to or received from an LLM API.
*/
const SamplingMessageSchema = object$1({
	role: RoleSchema,
	content: union$1([SamplingMessageContentBlockSchema, array$1(SamplingMessageContentBlockSchema)]),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* Parameters for a `sampling/createMessage` request.
*/
const CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
	messages: array$1(SamplingMessageSchema),
	modelPreferences: ModelPreferencesSchema.optional(),
	systemPrompt: string$3().optional(),
	includeContext: _enum$1([
		"none",
		"thisServer",
		"allServers"
	]).optional(),
	temperature: number$3().optional(),
	maxTokens: number$3().int(),
	stopSequences: array$1(string$3()).optional(),
	metadata: AssertObjectSchema.optional(),
	tools: array$1(ToolSchema).optional(),
	toolChoice: ToolChoiceSchema.optional()
});
/**
* A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
*/
const CreateMessageRequestSchema = RequestSchema.extend({
	method: literal$1("sampling/createMessage"),
	params: CreateMessageRequestParamsSchema
});
/**
* The client's response to a sampling/create_message request from the server.
* This is the backwards-compatible version that returns single content (no arrays).
* Used when the request does not include tools.
*/
const CreateMessageResultSchema = ResultSchema.extend({
	model: string$3(),
	stopReason: optional$1(_enum$1([
		"endTurn",
		"stopSequence",
		"maxTokens"
	]).or(string$3())),
	role: RoleSchema,
	content: SamplingContentSchema
});
/**
* The client's response to a sampling/create_message request when tools were provided.
* This version supports array content for tool use flows.
*/
const CreateMessageResultWithToolsSchema = ResultSchema.extend({
	model: string$3(),
	stopReason: optional$1(_enum$1([
		"endTurn",
		"stopSequence",
		"maxTokens",
		"toolUse"
	]).or(string$3())),
	role: RoleSchema,
	content: union$1([SamplingMessageContentBlockSchema, array$1(SamplingMessageContentBlockSchema)])
});
/**
* Primitive schema definition for boolean fields.
*/
const BooleanSchemaSchema = object$1({
	type: literal$1("boolean"),
	title: string$3().optional(),
	description: string$3().optional(),
	default: boolean$3().optional()
});
/**
* Primitive schema definition for string fields.
*/
const StringSchemaSchema = object$1({
	type: literal$1("string"),
	title: string$3().optional(),
	description: string$3().optional(),
	minLength: number$3().optional(),
	maxLength: number$3().optional(),
	format: _enum$1([
		"email",
		"uri",
		"date",
		"date-time"
	]).optional(),
	default: string$3().optional()
});
/**
* Primitive schema definition for number fields.
*/
const NumberSchemaSchema = object$1({
	type: _enum$1(["number", "integer"]),
	title: string$3().optional(),
	description: string$3().optional(),
	minimum: number$3().optional(),
	maximum: number$3().optional(),
	default: number$3().optional()
});
/**
* Schema for single-selection enumeration without display titles for options.
*/
const UntitledSingleSelectEnumSchemaSchema = object$1({
	type: literal$1("string"),
	title: string$3().optional(),
	description: string$3().optional(),
	enum: array$1(string$3()),
	default: string$3().optional()
});
/**
* Schema for single-selection enumeration with display titles for each option.
*/
const TitledSingleSelectEnumSchemaSchema = object$1({
	type: literal$1("string"),
	title: string$3().optional(),
	description: string$3().optional(),
	oneOf: array$1(object$1({
		const: string$3(),
		title: string$3()
	})),
	default: string$3().optional()
});
/**
* Use TitledSingleSelectEnumSchema instead.
* This interface will be removed in a future version.
*/
const LegacyTitledEnumSchemaSchema = object$1({
	type: literal$1("string"),
	title: string$3().optional(),
	description: string$3().optional(),
	enum: array$1(string$3()),
	enumNames: array$1(string$3()).optional(),
	default: string$3().optional()
});
const SingleSelectEnumSchemaSchema = union$1([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
/**
* Schema for multiple-selection enumeration without display titles for options.
*/
const UntitledMultiSelectEnumSchemaSchema = object$1({
	type: literal$1("array"),
	title: string$3().optional(),
	description: string$3().optional(),
	minItems: number$3().optional(),
	maxItems: number$3().optional(),
	items: object$1({
		type: literal$1("string"),
		enum: array$1(string$3())
	}),
	default: array$1(string$3()).optional()
});
/**
* Schema for multiple-selection enumeration with display titles for each option.
*/
const TitledMultiSelectEnumSchemaSchema = object$1({
	type: literal$1("array"),
	title: string$3().optional(),
	description: string$3().optional(),
	minItems: number$3().optional(),
	maxItems: number$3().optional(),
	items: object$1({ anyOf: array$1(object$1({
		const: string$3(),
		title: string$3()
	})) }),
	default: array$1(string$3()).optional()
});
/**
* Combined schema for multiple-selection enumeration
*/
const MultiSelectEnumSchemaSchema = union$1([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
/**
* Primitive schema definition for enum fields.
*/
const EnumSchemaSchema = union$1([
	LegacyTitledEnumSchemaSchema,
	SingleSelectEnumSchemaSchema,
	MultiSelectEnumSchemaSchema
]);
/**
* Union of all primitive schema definitions.
*/
const PrimitiveSchemaDefinitionSchema = union$1([
	EnumSchemaSchema,
	BooleanSchemaSchema,
	StringSchemaSchema,
	NumberSchemaSchema
]);
/**
* Parameters for an `elicitation/create` request for form-based elicitation.
*/
const ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
	mode: literal$1("form").optional(),
	message: string$3(),
	requestedSchema: object$1({
		type: literal$1("object"),
		properties: record$1(string$3(), PrimitiveSchemaDefinitionSchema),
		required: array$1(string$3()).optional()
	})
});
/**
* Parameters for an `elicitation/create` request for URL-based elicitation.
*/
const ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
	mode: literal$1("url"),
	message: string$3(),
	elicitationId: string$3(),
	url: string$3().url()
});
/**
* The parameters for a request to elicit additional information from the user via the client.
*/
const ElicitRequestParamsSchema = union$1([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
/**
* A request from the server to elicit user input via the client.
* The client should present the message and form fields to the user (form mode)
* or navigate to a URL (URL mode).
*/
const ElicitRequestSchema = RequestSchema.extend({
	method: literal$1("elicitation/create"),
	params: ElicitRequestParamsSchema
});
/**
* Parameters for a `notifications/elicitation/complete` notification.
*
* @category notifications/elicitation/complete
*/
const ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({ elicitationId: string$3() });
/**
* A notification from the server to the client, informing it of a completion of an out-of-band elicitation request.
*
* @category notifications/elicitation/complete
*/
const ElicitationCompleteNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/elicitation/complete"),
	params: ElicitationCompleteNotificationParamsSchema
});
/**
* The client's response to an elicitation/create request from the server.
*/
const ElicitResultSchema = ResultSchema.extend({
	action: _enum$1([
		"accept",
		"decline",
		"cancel"
	]),
	content: preprocess((val) => val === null ? undefined : val, record$1(string$3(), union$1([
		string$3(),
		number$3(),
		boolean$3(),
		array$1(string$3())
	])).optional())
});
/**
* A reference to a resource or resource template definition.
*/
const ResourceTemplateReferenceSchema = object$1({
	type: literal$1("ref/resource"),
	uri: string$3()
});
/**
* @deprecated Use ResourceTemplateReferenceSchema instead
*/
const ResourceReferenceSchema = ResourceTemplateReferenceSchema;
/**
* Identifies a prompt.
*/
const PromptReferenceSchema = object$1({
	type: literal$1("ref/prompt"),
	name: string$3()
});
/**
* Parameters for a `completion/complete` request.
*/
const CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
	ref: union$1([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
	argument: object$1({
		name: string$3(),
		value: string$3()
	}),
	context: object$1({ arguments: record$1(string$3(), string$3()).optional() }).optional()
});
/**
* A request from the client to the server, to ask for completion options.
*/
const CompleteRequestSchema = RequestSchema.extend({
	method: literal$1("completion/complete"),
	params: CompleteRequestParamsSchema
});
function assertCompleteRequestPrompt(request) {
	if (request.params.ref.type !== "ref/prompt") {
		throw new TypeError(`Expected CompleteRequestPrompt, but got ${request.params.ref.type}`);
	}
	void request;
}
function assertCompleteRequestResourceTemplate(request) {
	if (request.params.ref.type !== "ref/resource") {
		throw new TypeError(`Expected CompleteRequestResourceTemplate, but got ${request.params.ref.type}`);
	}
	void request;
}
/**
* The server's response to a completion/complete request
*/
const CompleteResultSchema = ResultSchema.extend({ completion: looseObject$1({
	values: array$1(string$3()).max(100),
	total: optional$1(number$3().int()),
	hasMore: optional$1(boolean$3())
}) });
/**
* Represents a root directory or file that the server can operate on.
*/
const RootSchema = object$1({
	uri: string$3().startsWith("file://"),
	name: string$3().optional(),
	_meta: record$1(string$3(), unknown$1()).optional()
});
/**
* Sent from the server to request a list of root URIs from the client.
*/
const ListRootsRequestSchema = RequestSchema.extend({
	method: literal$1("roots/list"),
	params: BaseRequestParamsSchema.optional()
});
/**
* The client's response to a roots/list request from the server.
*/
const ListRootsResultSchema = ResultSchema.extend({ roots: array$1(RootSchema) });
/**
* A notification from the client to the server, informing it that the list of roots has changed.
*/
const RootsListChangedNotificationSchema = NotificationSchema.extend({
	method: literal$1("notifications/roots/list_changed"),
	params: NotificationsParamsSchema.optional()
});
const ClientRequestSchema = union$1([
	PingRequestSchema,
	InitializeRequestSchema,
	CompleteRequestSchema,
	SetLevelRequestSchema,
	GetPromptRequestSchema,
	ListPromptsRequestSchema,
	ListResourcesRequestSchema,
	ListResourceTemplatesRequestSchema,
	ReadResourceRequestSchema,
	SubscribeRequestSchema,
	UnsubscribeRequestSchema,
	CallToolRequestSchema,
	ListToolsRequestSchema,
	GetTaskRequestSchema,
	GetTaskPayloadRequestSchema,
	ListTasksRequestSchema,
	CancelTaskRequestSchema
]);
const ClientNotificationSchema = union$1([
	CancelledNotificationSchema,
	ProgressNotificationSchema,
	InitializedNotificationSchema,
	RootsListChangedNotificationSchema,
	TaskStatusNotificationSchema
]);
const ClientResultSchema = union$1([
	EmptyResultSchema,
	CreateMessageResultSchema,
	CreateMessageResultWithToolsSchema,
	ElicitResultSchema,
	ListRootsResultSchema,
	GetTaskResultSchema,
	ListTasksResultSchema,
	CreateTaskResultSchema
]);
const ServerRequestSchema = union$1([
	PingRequestSchema,
	CreateMessageRequestSchema,
	ElicitRequestSchema,
	ListRootsRequestSchema,
	GetTaskRequestSchema,
	GetTaskPayloadRequestSchema,
	ListTasksRequestSchema,
	CancelTaskRequestSchema
]);
const ServerNotificationSchema = union$1([
	CancelledNotificationSchema,
	ProgressNotificationSchema,
	LoggingMessageNotificationSchema,
	ResourceUpdatedNotificationSchema,
	ResourceListChangedNotificationSchema,
	ToolListChangedNotificationSchema,
	PromptListChangedNotificationSchema,
	TaskStatusNotificationSchema,
	ElicitationCompleteNotificationSchema
]);
const ServerResultSchema = union$1([
	EmptyResultSchema,
	InitializeResultSchema,
	CompleteResultSchema,
	GetPromptResultSchema,
	ListPromptsResultSchema,
	ListResourcesResultSchema,
	ListResourceTemplatesResultSchema,
	ReadResourceResultSchema,
	CallToolResultSchema,
	ListToolsResultSchema,
	GetTaskResultSchema,
	ListTasksResultSchema,
	CreateTaskResultSchema
]);
var McpError = class McpError extends Error {
	constructor(code, message, data) {
		super(`MCP error ${code}: ${message}`);
		this.code = code;
		this.data = data;
		this.name = "McpError";
	}
	/**
	* Factory method to create the appropriate error type based on the error code and data
	*/
	static fromError(code, message, data) {
		if (code === ErrorCode.UrlElicitationRequired && data) {
			const errorData = data;
			if (errorData.elicitations) {
				return new UrlElicitationRequiredError(errorData.elicitations, message);
			}
		}
		return new McpError(code, message, data);
	}
};
/**
* Specialized error type when a tool requires a URL mode elicitation.
* This makes it nicer for the client to handle since there is specific data to work with instead of just a code to check against.
*/
var UrlElicitationRequiredError = class extends McpError {
	constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
		super(ErrorCode.UrlElicitationRequired, message, { elicitations });
	}
	get elicitations() {
		return this.data?.elicitations ?? [];
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth.js
/**
* Reusable URL validation that disallows javascript: scheme
*/
const SafeUrlSchema = url$1().superRefine((val, ctx) => {
	if (!URL.canParse(val)) {
		ctx.addIssue({
			code: ZodIssueCode$1.custom,
			message: "URL must be parseable",
			fatal: true
		});
		return NEVER$1;
	}
}).refine((url$2) => {
	const u = new URL(url$2);
	return u.protocol !== "javascript:" && u.protocol !== "data:" && u.protocol !== "vbscript:";
}, { message: "URL cannot use javascript:, data:, or vbscript: scheme" });
/**
* RFC 9728 OAuth Protected Resource Metadata
*/
const OAuthProtectedResourceMetadataSchema = looseObject$1({
	resource: string$3().url(),
	authorization_servers: array$1(SafeUrlSchema).optional(),
	jwks_uri: string$3().url().optional(),
	scopes_supported: array$1(string$3()).optional(),
	bearer_methods_supported: array$1(string$3()).optional(),
	resource_signing_alg_values_supported: array$1(string$3()).optional(),
	resource_name: string$3().optional(),
	resource_documentation: string$3().optional(),
	resource_policy_uri: string$3().url().optional(),
	resource_tos_uri: string$3().url().optional(),
	tls_client_certificate_bound_access_tokens: boolean$3().optional(),
	authorization_details_types_supported: array$1(string$3()).optional(),
	dpop_signing_alg_values_supported: array$1(string$3()).optional(),
	dpop_bound_access_tokens_required: boolean$3().optional()
});
/**
* RFC 8414 OAuth 2.0 Authorization Server Metadata
*/
const OAuthMetadataSchema = looseObject$1({
	issuer: string$3(),
	authorization_endpoint: SafeUrlSchema,
	token_endpoint: SafeUrlSchema,
	registration_endpoint: SafeUrlSchema.optional(),
	scopes_supported: array$1(string$3()).optional(),
	response_types_supported: array$1(string$3()),
	response_modes_supported: array$1(string$3()).optional(),
	grant_types_supported: array$1(string$3()).optional(),
	token_endpoint_auth_methods_supported: array$1(string$3()).optional(),
	token_endpoint_auth_signing_alg_values_supported: array$1(string$3()).optional(),
	service_documentation: SafeUrlSchema.optional(),
	revocation_endpoint: SafeUrlSchema.optional(),
	revocation_endpoint_auth_methods_supported: array$1(string$3()).optional(),
	revocation_endpoint_auth_signing_alg_values_supported: array$1(string$3()).optional(),
	introspection_endpoint: string$3().optional(),
	introspection_endpoint_auth_methods_supported: array$1(string$3()).optional(),
	introspection_endpoint_auth_signing_alg_values_supported: array$1(string$3()).optional(),
	code_challenge_methods_supported: array$1(string$3()).optional(),
	client_id_metadata_document_supported: boolean$3().optional()
});
/**
* OpenID Connect Discovery 1.0 Provider Metadata
* see: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
*/
const OpenIdProviderMetadataSchema = looseObject$1({
	issuer: string$3(),
	authorization_endpoint: SafeUrlSchema,
	token_endpoint: SafeUrlSchema,
	userinfo_endpoint: SafeUrlSchema.optional(),
	jwks_uri: SafeUrlSchema,
	registration_endpoint: SafeUrlSchema.optional(),
	scopes_supported: array$1(string$3()).optional(),
	response_types_supported: array$1(string$3()),
	response_modes_supported: array$1(string$3()).optional(),
	grant_types_supported: array$1(string$3()).optional(),
	acr_values_supported: array$1(string$3()).optional(),
	subject_types_supported: array$1(string$3()),
	id_token_signing_alg_values_supported: array$1(string$3()),
	id_token_encryption_alg_values_supported: array$1(string$3()).optional(),
	id_token_encryption_enc_values_supported: array$1(string$3()).optional(),
	userinfo_signing_alg_values_supported: array$1(string$3()).optional(),
	userinfo_encryption_alg_values_supported: array$1(string$3()).optional(),
	userinfo_encryption_enc_values_supported: array$1(string$3()).optional(),
	request_object_signing_alg_values_supported: array$1(string$3()).optional(),
	request_object_encryption_alg_values_supported: array$1(string$3()).optional(),
	request_object_encryption_enc_values_supported: array$1(string$3()).optional(),
	token_endpoint_auth_methods_supported: array$1(string$3()).optional(),
	token_endpoint_auth_signing_alg_values_supported: array$1(string$3()).optional(),
	display_values_supported: array$1(string$3()).optional(),
	claim_types_supported: array$1(string$3()).optional(),
	claims_supported: array$1(string$3()).optional(),
	service_documentation: string$3().optional(),
	claims_locales_supported: array$1(string$3()).optional(),
	ui_locales_supported: array$1(string$3()).optional(),
	claims_parameter_supported: boolean$3().optional(),
	request_parameter_supported: boolean$3().optional(),
	request_uri_parameter_supported: boolean$3().optional(),
	require_request_uri_registration: boolean$3().optional(),
	op_policy_uri: SafeUrlSchema.optional(),
	op_tos_uri: SafeUrlSchema.optional(),
	client_id_metadata_document_supported: boolean$3().optional()
});
/**
* OpenID Connect Discovery metadata that may include OAuth 2.0 fields
* This schema represents the real-world scenario where OIDC providers
* return a mix of OpenID Connect and OAuth 2.0 metadata fields
*/
const OpenIdProviderDiscoveryMetadataSchema = object$1({
	...OpenIdProviderMetadataSchema.shape,
	...OAuthMetadataSchema.pick({ code_challenge_methods_supported: true }).shape
});
/**
* OAuth 2.1 token response
*/
const OAuthTokensSchema = object$1({
	access_token: string$3(),
	id_token: string$3().optional(),
	token_type: string$3(),
	expires_in: number$2().optional(),
	scope: string$3().optional(),
	refresh_token: string$3().optional()
}).strip();
/**
* OAuth 2.1 error response
*/
const OAuthErrorResponseSchema = object$1({
	error: string$3(),
	error_description: string$3().optional(),
	error_uri: string$3().optional()
});
/**
* Optional version of SafeUrlSchema that allows empty string for retrocompatibility on tos_uri and logo_uri
*/
const OptionalSafeUrlSchema = SafeUrlSchema.optional().or(literal$1("").transform(() => undefined));
/**
* RFC 7591 OAuth 2.0 Dynamic Client Registration metadata
*/
const OAuthClientMetadataSchema = object$1({
	redirect_uris: array$1(SafeUrlSchema),
	token_endpoint_auth_method: string$3().optional(),
	grant_types: array$1(string$3()).optional(),
	response_types: array$1(string$3()).optional(),
	client_name: string$3().optional(),
	client_uri: SafeUrlSchema.optional(),
	logo_uri: OptionalSafeUrlSchema,
	scope: string$3().optional(),
	contacts: array$1(string$3()).optional(),
	tos_uri: OptionalSafeUrlSchema,
	policy_uri: string$3().optional(),
	jwks_uri: SafeUrlSchema.optional(),
	jwks: any$1().optional(),
	software_id: string$3().optional(),
	software_version: string$3().optional(),
	software_statement: string$3().optional()
}).strip();
/**
* RFC 7591 OAuth 2.0 Dynamic Client Registration client information
*/
const OAuthClientInformationSchema = object$1({
	client_id: string$3(),
	client_secret: string$3().optional(),
	client_id_issued_at: number$3().optional(),
	client_secret_expires_at: number$3().optional()
}).strip();
/**
* RFC 7591 OAuth 2.0 Dynamic Client Registration full response (client information plus metadata)
*/
const OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
/**
* RFC 7591 OAuth 2.0 Dynamic Client Registration error response
*/
const OAuthClientRegistrationErrorSchema = object$1({
	error: string$3(),
	error_description: string$3().optional()
}).strip();
/**
* RFC 7009 OAuth 2.0 Token Revocation request
*/
const OAuthTokenRevocationRequestSchema = object$1({
	token: string$3(),
	token_type_hint: string$3().optional()
}).strip();

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth-utils.js
/**
* Utilities for handling OAuth resource URIs.
*/
/**
* Converts a server URL to a resource URL by removing the fragment.
* RFC 8707 section 2 states that resource URIs "MUST NOT include a fragment component".
* Keeps everything else unchanged (scheme, domain, port, path, query).
*/
function resourceUrlFromServerUrl(url$2) {
	const resourceURL = typeof url$2 === "string" ? new URL(url$2) : new URL(url$2.href);
	resourceURL.hash = "";
	return resourceURL;
}
/**
* Checks if a requested resource URL matches a configured resource URL.
* A requested resource matches if it has the same scheme, domain, port,
* and its path starts with the configured resource's path.
*
* @param requestedResource The resource URL being requested
* @param configuredResource The resource URL that has been configured
* @returns true if the requested resource matches the configured resource, false otherwise
*/
function checkResourceAllowed({ requestedResource, configuredResource }) {
	const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
	const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
	if (requested.origin !== configured.origin) {
		return false;
	}
	if (requested.pathname.length < configured.pathname.length) {
		return false;
	}
	const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
	const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
	return requestedPath.startsWith(configuredPath);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/server/auth/errors.js
/**
* Base class for all OAuth errors
*/
var OAuthError = class extends Error {
	constructor(message, errorUri) {
		super(message);
		this.errorUri = errorUri;
		this.name = this.constructor.name;
	}
	/**
	* Converts the error to a standard OAuth error response object
	*/
	toResponseObject() {
		const response = {
			error: this.errorCode,
			error_description: this.message
		};
		if (this.errorUri) {
			response.error_uri = this.errorUri;
		}
		return response;
	}
	get errorCode() {
		return this.constructor.errorCode;
	}
};
/**
* Invalid request error - The request is missing a required parameter,
* includes an invalid parameter value, includes a parameter more than once,
* or is otherwise malformed.
*/
var InvalidRequestError = class extends OAuthError {};
InvalidRequestError.errorCode = "invalid_request";
/**
* Invalid client error - Client authentication failed (e.g., unknown client, no client
* authentication included, or unsupported authentication method).
*/
var InvalidClientError = class extends OAuthError {};
InvalidClientError.errorCode = "invalid_client";
/**
* Invalid grant error - The provided authorization grant or refresh token is
* invalid, expired, revoked, does not match the redirection URI used in the
* authorization request, or was issued to another client.
*/
var InvalidGrantError = class extends OAuthError {};
InvalidGrantError.errorCode = "invalid_grant";
/**
* Unauthorized client error - The authenticated client is not authorized to use
* this authorization grant type.
*/
var UnauthorizedClientError = class extends OAuthError {};
UnauthorizedClientError.errorCode = "unauthorized_client";
/**
* Unsupported grant type error - The authorization grant type is not supported
* by the authorization server.
*/
var UnsupportedGrantTypeError = class extends OAuthError {};
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
/**
* Invalid scope error - The requested scope is invalid, unknown, malformed, or
* exceeds the scope granted by the resource owner.
*/
var InvalidScopeError = class extends OAuthError {};
InvalidScopeError.errorCode = "invalid_scope";
/**
* Access denied error - The resource owner or authorization server denied the request.
*/
var AccessDeniedError = class extends OAuthError {};
AccessDeniedError.errorCode = "access_denied";
/**
* Server error - The authorization server encountered an unexpected condition
* that prevented it from fulfilling the request.
*/
var ServerError = class extends OAuthError {};
ServerError.errorCode = "server_error";
/**
* Temporarily unavailable error - The authorization server is currently unable to
* handle the request due to a temporary overloading or maintenance of the server.
*/
var TemporarilyUnavailableError = class extends OAuthError {};
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
/**
* Unsupported response type error - The authorization server does not support
* obtaining an authorization code using this method.
*/
var UnsupportedResponseTypeError = class extends OAuthError {};
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
/**
* Unsupported token type error - The authorization server does not support
* the requested token type.
*/
var UnsupportedTokenTypeError = class extends OAuthError {};
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
/**
* Invalid token error - The access token provided is expired, revoked, malformed,
* or invalid for other reasons.
*/
var InvalidTokenError = class extends OAuthError {};
InvalidTokenError.errorCode = "invalid_token";
/**
* Method not allowed error - The HTTP method used is not allowed for this endpoint.
* (Custom, non-standard error)
*/
var MethodNotAllowedError = class extends OAuthError {};
MethodNotAllowedError.errorCode = "method_not_allowed";
/**
* Too many requests error - Rate limit exceeded.
* (Custom, non-standard error based on RFC 6585)
*/
var TooManyRequestsError = class extends OAuthError {};
TooManyRequestsError.errorCode = "too_many_requests";
/**
* Invalid client metadata error - The client metadata is invalid.
* (Custom error for dynamic client registration - RFC 7591)
*/
var InvalidClientMetadataError = class extends OAuthError {};
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
/**
* Insufficient scope error - The request requires higher privileges than provided by the access token.
*/
var InsufficientScopeError = class extends OAuthError {};
InsufficientScopeError.errorCode = "insufficient_scope";
/**
* Invalid target error - The requested resource is invalid, missing, unknown, or malformed.
* (Custom error for resource indicators - RFC 8707)
*/
var InvalidTargetError = class extends OAuthError {};
InvalidTargetError.errorCode = "invalid_target";
/**
* A utility class for defining one-off error codes
*/
var CustomOAuthError = class extends OAuthError {
	constructor(customErrorCode, message, errorUri) {
		super(message, errorUri);
		this.customErrorCode = customErrorCode;
	}
	get errorCode() {
		return this.customErrorCode;
	}
};
/**
* A full list of all OAuthErrors, enabling parsing from error responses
*/
const OAUTH_ERRORS = {
	[InvalidRequestError.errorCode]: InvalidRequestError,
	[InvalidClientError.errorCode]: InvalidClientError,
	[InvalidGrantError.errorCode]: InvalidGrantError,
	[UnauthorizedClientError.errorCode]: UnauthorizedClientError,
	[UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
	[InvalidScopeError.errorCode]: InvalidScopeError,
	[AccessDeniedError.errorCode]: AccessDeniedError,
	[ServerError.errorCode]: ServerError,
	[TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
	[UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
	[UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
	[InvalidTokenError.errorCode]: InvalidTokenError,
	[MethodNotAllowedError.errorCode]: MethodNotAllowedError,
	[TooManyRequestsError.errorCode]: TooManyRequestsError,
	[InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
	[InsufficientScopeError.errorCode]: InsufficientScopeError,
	[InvalidTargetError.errorCode]: InvalidTargetError
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
var UnauthorizedError = class extends Error {
	constructor(message) {
		super(message ?? "Unauthorized");
	}
};
function isClientAuthMethod(method) {
	return [
		"client_secret_basic",
		"client_secret_post",
		"none"
	].includes(method);
}
const AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
const AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
/**
* Determines the best client authentication method to use based on server support and client configuration.
*
* Priority order (highest to lowest):
* 1. client_secret_basic (if client secret is available)
* 2. client_secret_post (if client secret is available)
* 3. none (for public clients)
*
* @param clientInformation - OAuth client information containing credentials
* @param supportedMethods - Authentication methods supported by the authorization server
* @returns The selected authentication method
*/
function selectClientAuthMethod(clientInformation, supportedMethods) {
	const hasClientSecret = clientInformation.client_secret !== undefined;
	if (supportedMethods.length === 0) {
		return hasClientSecret ? "client_secret_post" : "none";
	}
	if ("token_endpoint_auth_method" in clientInformation && clientInformation.token_endpoint_auth_method && isClientAuthMethod(clientInformation.token_endpoint_auth_method) && supportedMethods.includes(clientInformation.token_endpoint_auth_method)) {
		return clientInformation.token_endpoint_auth_method;
	}
	if (hasClientSecret && supportedMethods.includes("client_secret_basic")) {
		return "client_secret_basic";
	}
	if (hasClientSecret && supportedMethods.includes("client_secret_post")) {
		return "client_secret_post";
	}
	if (supportedMethods.includes("none")) {
		return "none";
	}
	return hasClientSecret ? "client_secret_post" : "none";
}
/**
* Applies client authentication to the request based on the specified method.
*
* Implements OAuth 2.1 client authentication methods:
* - client_secret_basic: HTTP Basic authentication (RFC 6749 Section 2.3.1)
* - client_secret_post: Credentials in request body (RFC 6749 Section 2.3.1)
* - none: Public client authentication (RFC 6749 Section 2.1)
*
* @param method - The authentication method to use
* @param clientInformation - OAuth client information containing credentials
* @param headers - HTTP headers object to modify
* @param params - URL search parameters to modify
* @throws {Error} When required credentials are missing
*/
function applyClientAuthentication(method, clientInformation, headers, params) {
	const { client_id, client_secret } = clientInformation;
	switch (method) {
		case "client_secret_basic":
			applyBasicAuth(client_id, client_secret, headers);
			return;
		case "client_secret_post":
			applyPostAuth(client_id, client_secret, params);
			return;
		case "none":
			applyPublicAuth(client_id, params);
			return;
		default: throw new Error(`Unsupported client authentication method: ${method}`);
	}
}
/**
* Applies HTTP Basic authentication (RFC 6749 Section 2.3.1)
*/
function applyBasicAuth(clientId, clientSecret, headers) {
	if (!clientSecret) {
		throw new Error("client_secret_basic authentication requires a client_secret");
	}
	const credentials = btoa(`${clientId}:${clientSecret}`);
	headers.set("Authorization", `Basic ${credentials}`);
}
/**
* Applies POST body authentication (RFC 6749 Section 2.3.1)
*/
function applyPostAuth(clientId, clientSecret, params) {
	params.set("client_id", clientId);
	if (clientSecret) {
		params.set("client_secret", clientSecret);
	}
}
/**
* Applies public client authentication (RFC 6749 Section 2.1)
*/
function applyPublicAuth(clientId, params) {
	params.set("client_id", clientId);
}
/**
* Parses an OAuth error response from a string or Response object.
*
* If the input is a standard OAuth2.0 error response, it will be parsed according to the spec
* and an instance of the appropriate OAuthError subclass will be returned.
* If parsing fails, it falls back to a generic ServerError that includes
* the response status (if available) and original content.
*
* @param input - A Response object or string containing the error response
* @returns A Promise that resolves to an OAuthError instance
*/
async function parseErrorResponse(input) {
	const statusCode = input instanceof Response ? input.status : undefined;
	const body = input instanceof Response ? await input.text() : input;
	try {
		const result = OAuthErrorResponseSchema.parse(JSON.parse(body));
		const { error: error$47, error_description, error_uri } = result;
		const errorClass = OAUTH_ERRORS[error$47] || ServerError;
		return new errorClass(error_description || "", error_uri);
	} catch (error$47) {
		const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error$47}. Raw body: ${body}`;
		return new ServerError(errorMessage);
	}
}
/**
* Orchestrates the full auth flow with a server.
*
* This can be used as a single entry point for all authorization functionality,
* instead of linking together the other lower-level functions in this module.
*/
async function auth(provider, options) {
	try {
		return await authInternal(provider, options);
	} catch (error$47) {
		if (error$47 instanceof InvalidClientError || error$47 instanceof UnauthorizedClientError) {
			await provider.invalidateCredentials?.("all");
			return await authInternal(provider, options);
		} else if (error$47 instanceof InvalidGrantError) {
			await provider.invalidateCredentials?.("tokens");
			return await authInternal(provider, options);
		}
		throw error$47;
	}
}
async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
	let resourceMetadata;
	let authorizationServerUrl;
	try {
		resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);
		if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
			authorizationServerUrl = resourceMetadata.authorization_servers[0];
		}
	} catch {}
	/**
	* If we don't get a valid authorization server metadata from protected resource metadata,
	* fallback to the legacy MCP spec's implementation (version 2025-03-26): MCP server base URL acts as the Authorization server.
	*/
	if (!authorizationServerUrl) {
		authorizationServerUrl = new URL("/", serverUrl);
	}
	const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
	const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn });
	let clientInformation = await Promise.resolve(provider.clientInformation());
	if (!clientInformation) {
		if (authorizationCode !== undefined) {
			throw new Error("Existing OAuth client information is required when exchanging an authorization code");
		}
		const supportsUrlBasedClientId = metadata?.client_id_metadata_document_supported === true;
		const clientMetadataUrl = provider.clientMetadataUrl;
		if (clientMetadataUrl && !isHttpsUrl(clientMetadataUrl)) {
			throw new InvalidClientMetadataError(`clientMetadataUrl must be a valid HTTPS URL with a non-root pathname, got: ${clientMetadataUrl}`);
		}
		const shouldUseUrlBasedClientId = supportsUrlBasedClientId && clientMetadataUrl;
		if (shouldUseUrlBasedClientId) {
			clientInformation = { client_id: clientMetadataUrl };
			await provider.saveClientInformation?.(clientInformation);
		} else {
			if (!provider.saveClientInformation) {
				throw new Error("OAuth client information must be saveable for dynamic registration");
			}
			const fullInformation = await registerClient(authorizationServerUrl, {
				metadata,
				clientMetadata: provider.clientMetadata,
				fetchFn
			});
			await provider.saveClientInformation(fullInformation);
			clientInformation = fullInformation;
		}
	}
	const nonInteractiveFlow = !provider.redirectUrl;
	if (authorizationCode !== undefined || nonInteractiveFlow) {
		const tokens$1 = await fetchToken(provider, authorizationServerUrl, {
			metadata,
			resource,
			authorizationCode,
			fetchFn
		});
		await provider.saveTokens(tokens$1);
		return "AUTHORIZED";
	}
	const tokens = await provider.tokens();
	if (tokens?.refresh_token) {
		try {
			const newTokens = await refreshAuthorization(authorizationServerUrl, {
				metadata,
				clientInformation,
				refreshToken: tokens.refresh_token,
				resource,
				addClientAuthentication: provider.addClientAuthentication,
				fetchFn
			});
			await provider.saveTokens(newTokens);
			return "AUTHORIZED";
		} catch (error$47) {
			if (!(error$47 instanceof OAuthError) || error$47 instanceof ServerError) {} else {
				throw error$47;
			}
		}
	}
	const state = provider.state ? await provider.state() : undefined;
	const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
		metadata,
		clientInformation,
		state,
		redirectUrl: provider.redirectUrl,
		scope: scope || resourceMetadata?.scopes_supported?.join(" ") || provider.clientMetadata.scope,
		resource
	});
	await provider.saveCodeVerifier(codeVerifier);
	await provider.redirectToAuthorization(authorizationUrl);
	return "REDIRECT";
}
/**
* SEP-991: URL-based Client IDs
* Validate that the client_id is a valid URL with https scheme
*/
function isHttpsUrl(value) {
	if (!value) return false;
	try {
		const url$2 = new URL(value);
		return url$2.protocol === "https:" && url$2.pathname !== "/";
	} catch {
		return false;
	}
}
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
	const defaultResource = resourceUrlFromServerUrl(serverUrl);
	if (provider.validateResourceURL) {
		return await provider.validateResourceURL(defaultResource, resourceMetadata?.resource);
	}
	if (!resourceMetadata) {
		return undefined;
	}
	if (!checkResourceAllowed({
		requestedResource: defaultResource,
		configuredResource: resourceMetadata.resource
	})) {
		throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
	}
	return new URL(resourceMetadata.resource);
}
/**
* Extract resource_metadata, scope, and error from WWW-Authenticate header.
*/
function extractWWWAuthenticateParams(res) {
	const authenticateHeader = res.headers.get("WWW-Authenticate");
	if (!authenticateHeader) {
		return {};
	}
	const [type, scheme] = authenticateHeader.split(" ");
	if (type.toLowerCase() !== "bearer" || !scheme) {
		return {};
	}
	const resourceMetadataMatch = extractFieldFromWwwAuth(res, "resource_metadata") || undefined;
	let resourceMetadataUrl;
	if (resourceMetadataMatch) {
		try {
			resourceMetadataUrl = new URL(resourceMetadataMatch);
		} catch {}
	}
	const scope = extractFieldFromWwwAuth(res, "scope") || undefined;
	const error$47 = extractFieldFromWwwAuth(res, "error") || undefined;
	return {
		resourceMetadataUrl,
		scope,
		error: error$47
	};
}
/**
* Extracts a specific field's value from the WWW-Authenticate header string.
*
* @param response The HTTP response object containing the headers.
* @param fieldName The name of the field to extract (e.g., "realm", "nonce").
* @returns The field value
*/
function extractFieldFromWwwAuth(response, fieldName) {
	const wwwAuthHeader = response.headers.get("WWW-Authenticate");
	if (!wwwAuthHeader) {
		return null;
	}
	const pattern = new RegExp(`${fieldName}=(?:"([^"]+)"|([^\\s,]+))`);
	const match = wwwAuthHeader.match(pattern);
	if (match) {
		return match[1] || match[2];
	}
	return null;
}
/**
* Extract resource_metadata from response header.
* @deprecated Use `extractWWWAuthenticateParams` instead.
*/
function extractResourceMetadataUrl(res) {
	const authenticateHeader = res.headers.get("WWW-Authenticate");
	if (!authenticateHeader) {
		return undefined;
	}
	const [type, scheme] = authenticateHeader.split(" ");
	if (type.toLowerCase() !== "bearer" || !scheme) {
		return undefined;
	}
	const regex = /resource_metadata="([^"]*)"/;
	const match = regex.exec(authenticateHeader);
	if (!match) {
		return undefined;
	}
	try {
		return new URL(match[1]);
	} catch {
		return undefined;
	}
}
/**
* Looks up RFC 9728 OAuth 2.0 Protected Resource Metadata.
*
* If the server returns a 404 for the well-known endpoint, this function will
* return `undefined`. Any other errors will be thrown as exceptions.
*/
async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
	const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
		protocolVersion: opts?.protocolVersion,
		metadataUrl: opts?.resourceMetadataUrl
	});
	if (!response || response.status === 404) {
		await response?.body?.cancel();
		throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
	}
	if (!response.ok) {
		await response.body?.cancel();
		throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
	}
	return OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
/**
* Helper function to handle fetch with CORS retry logic
*/
async function fetchWithCorsRetry(url$2, headers, fetchFn = fetch) {
	try {
		return await fetchFn(url$2, { headers });
	} catch (error$47) {
		if (error$47 instanceof TypeError) {
			if (headers) {
				return fetchWithCorsRetry(url$2, undefined, fetchFn);
			} else {
				return undefined;
			}
		}
		throw error$47;
	}
}
/**
* Constructs the well-known path for auth-related metadata discovery
*/
function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
	if (pathname.endsWith("/")) {
		pathname = pathname.slice(0, -1);
	}
	return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
/**
* Tries to discover OAuth metadata at a specific URL
*/
async function tryMetadataDiscovery(url$2, protocolVersion, fetchFn = fetch) {
	const headers = { "MCP-Protocol-Version": protocolVersion };
	return await fetchWithCorsRetry(url$2, headers, fetchFn);
}
/**
* Determines if fallback to root discovery should be attempted
*/
function shouldAttemptFallback(response, pathname) {
	return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
/**
* Generic function for discovering OAuth metadata with fallback support
*/
async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
	const issuer = new URL(serverUrl);
	const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;
	let url$2;
	if (opts?.metadataUrl) {
		url$2 = new URL(opts.metadataUrl);
	} else {
		const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
		url$2 = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);
		url$2.search = issuer.search;
	}
	let response = await tryMetadataDiscovery(url$2, protocolVersion, fetchFn);
	if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {
		const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
		response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
	}
	return response;
}
/**
* Looks up RFC 8414 OAuth 2.0 Authorization Server Metadata.
*
* If the server returns a 404 for the well-known endpoint, this function will
* return `undefined`. Any other errors will be thrown as exceptions.
*
* @deprecated This function is deprecated in favor of `discoverAuthorizationServerMetadata`.
*/
async function discoverOAuthMetadata(issuer, { authorizationServerUrl, protocolVersion } = {}, fetchFn = fetch) {
	if (typeof issuer === "string") {
		issuer = new URL(issuer);
	}
	if (!authorizationServerUrl) {
		authorizationServerUrl = issuer;
	}
	if (typeof authorizationServerUrl === "string") {
		authorizationServerUrl = new URL(authorizationServerUrl);
	}
	protocolVersion ?? (protocolVersion = LATEST_PROTOCOL_VERSION);
	const response = await discoverMetadataWithFallback(authorizationServerUrl, "oauth-authorization-server", fetchFn, {
		protocolVersion,
		metadataServerUrl: authorizationServerUrl
	});
	if (!response || response.status === 404) {
		await response?.body?.cancel();
		return undefined;
	}
	if (!response.ok) {
		await response.body?.cancel();
		throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);
	}
	return OAuthMetadataSchema.parse(await response.json());
}
/**
* Builds a list of discovery URLs to try for authorization server metadata.
* URLs are returned in priority order:
* 1. OAuth metadata at the given URL
* 2. OIDC metadata endpoints at the given URL
*/
function buildDiscoveryUrls(authorizationServerUrl) {
	const url$2 = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
	const hasPath = url$2.pathname !== "/";
	const urlsToTry = [];
	if (!hasPath) {
		urlsToTry.push({
			url: new URL("/.well-known/oauth-authorization-server", url$2.origin),
			type: "oauth"
		});
		urlsToTry.push({
			url: new URL(`/.well-known/openid-configuration`, url$2.origin),
			type: "oidc"
		});
		return urlsToTry;
	}
	let pathname = url$2.pathname;
	if (pathname.endsWith("/")) {
		pathname = pathname.slice(0, -1);
	}
	urlsToTry.push({
		url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url$2.origin),
		type: "oauth"
	});
	urlsToTry.push({
		url: new URL(`/.well-known/openid-configuration${pathname}`, url$2.origin),
		type: "oidc"
	});
	urlsToTry.push({
		url: new URL(`${pathname}/.well-known/openid-configuration`, url$2.origin),
		type: "oidc"
	});
	return urlsToTry;
}
/**
* Discovers authorization server metadata with support for RFC 8414 OAuth 2.0 Authorization Server Metadata
* and OpenID Connect Discovery 1.0 specifications.
*
* This function implements a fallback strategy for authorization server discovery:
* 1. Attempts RFC 8414 OAuth metadata discovery first
* 2. If OAuth discovery fails, falls back to OpenID Connect Discovery
*
* @param authorizationServerUrl - The authorization server URL obtained from the MCP Server's
*                                 protected resource metadata, or the MCP server's URL if the
*                                 metadata was not found.
* @param options - Configuration options
* @param options.fetchFn - Optional fetch function for making HTTP requests, defaults to global fetch
* @param options.protocolVersion - MCP protocol version to use, defaults to LATEST_PROTOCOL_VERSION
* @returns Promise resolving to authorization server metadata, or undefined if discovery fails
*/
async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = LATEST_PROTOCOL_VERSION } = {}) {
	const headers = {
		"MCP-Protocol-Version": protocolVersion,
		Accept: "application/json"
	};
	const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
	for (const { url: endpointUrl, type } of urlsToTry) {
		const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
		if (!response) {
			/**
			* CORS error occurred - don't throw as the endpoint may not allow CORS,
			* continue trying other possible endpoints
			*/
			continue;
		}
		if (!response.ok) {
			await response.body?.cancel();
			if (response.status >= 400 && response.status < 500) {
				continue;
			}
			throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
		}
		if (type === "oauth") {
			return OAuthMetadataSchema.parse(await response.json());
		} else {
			return OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
		}
	}
	return undefined;
}
/**
* Begins the authorization flow with the given server, by generating a PKCE challenge and constructing the authorization URL.
*/
async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
	let authorizationUrl;
	if (metadata) {
		authorizationUrl = new URL(metadata.authorization_endpoint);
		if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) {
			throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
		}
		if (metadata.code_challenge_methods_supported && !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) {
			throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
		}
	} else {
		authorizationUrl = new URL("/authorize", authorizationServerUrl);
	}
	const challenge = await pkceChallenge();
	const codeVerifier = challenge.code_verifier;
	const codeChallenge = challenge.code_challenge;
	authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
	authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
	authorizationUrl.searchParams.set("code_challenge", codeChallenge);
	authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
	authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
	if (state) {
		authorizationUrl.searchParams.set("state", state);
	}
	if (scope) {
		authorizationUrl.searchParams.set("scope", scope);
	}
	if (scope?.includes("offline_access")) {
		authorizationUrl.searchParams.append("prompt", "consent");
	}
	if (resource) {
		authorizationUrl.searchParams.set("resource", resource.href);
	}
	return {
		authorizationUrl,
		codeVerifier
	};
}
/**
* Prepares token request parameters for an authorization code exchange.
*
* This is the default implementation used by fetchToken when the provider
* doesn't implement prepareTokenRequest.
*
* @param authorizationCode - The authorization code received from the authorization endpoint
* @param codeVerifier - The PKCE code verifier
* @param redirectUri - The redirect URI used in the authorization request
* @returns URLSearchParams for the authorization_code grant
*/
function prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri) {
	return new URLSearchParams({
		grant_type: "authorization_code",
		code: authorizationCode,
		code_verifier: codeVerifier,
		redirect_uri: String(redirectUri)
	});
}
/**
* Internal helper to execute a token request with the given parameters.
* Used by exchangeAuthorization, refreshAuthorization, and fetchToken.
*/
async function executeTokenRequest(authorizationServerUrl, { metadata, tokenRequestParams, clientInformation, addClientAuthentication, resource, fetchFn }) {
	const tokenUrl = metadata?.token_endpoint ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
	const headers = new Headers({
		"Content-Type": "application/x-www-form-urlencoded",
		Accept: "application/json"
	});
	if (resource) {
		tokenRequestParams.set("resource", resource.href);
	}
	if (addClientAuthentication) {
		await addClientAuthentication(headers, tokenRequestParams, tokenUrl, metadata);
	} else if (clientInformation) {
		const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];
		const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
		applyClientAuthentication(authMethod, clientInformation, headers, tokenRequestParams);
	}
	const response = await (fetchFn ?? fetch)(tokenUrl, {
		method: "POST",
		headers,
		body: tokenRequestParams
	});
	if (!response.ok) {
		throw await parseErrorResponse(response);
	}
	return OAuthTokensSchema.parse(await response.json());
}
/**
* Exchanges an authorization code for an access token with the given server.
*
* Supports multiple client authentication methods as specified in OAuth 2.1:
* - Automatically selects the best authentication method based on server support
* - Falls back to appropriate defaults when server metadata is unavailable
*
* @param authorizationServerUrl - The authorization server's base URL
* @param options - Configuration object containing client info, auth code, etc.
* @returns Promise resolving to OAuth tokens
* @throws {Error} When token exchange fails or authentication is invalid
*/
async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri, resource, addClientAuthentication, fetchFn }) {
	const tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri);
	return executeTokenRequest(authorizationServerUrl, {
		metadata,
		tokenRequestParams,
		clientInformation,
		addClientAuthentication,
		resource,
		fetchFn
	});
}
/**
* Exchange a refresh token for an updated access token.
*
* Supports multiple client authentication methods as specified in OAuth 2.1:
* - Automatically selects the best authentication method based on server support
* - Preserves the original refresh token if a new one is not returned
*
* @param authorizationServerUrl - The authorization server's base URL
* @param options - Configuration object containing client info, refresh token, etc.
* @returns Promise resolving to OAuth tokens (preserves original refresh_token if not replaced)
* @throws {Error} When token refresh fails or authentication is invalid
*/
async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
	const tokenRequestParams = new URLSearchParams({
		grant_type: "refresh_token",
		refresh_token: refreshToken
	});
	const tokens = await executeTokenRequest(authorizationServerUrl, {
		metadata,
		tokenRequestParams,
		clientInformation,
		addClientAuthentication,
		resource,
		fetchFn
	});
	return {
		refresh_token: refreshToken,
		...tokens
	};
}
/**
* Unified token fetching that works with any grant type via provider.prepareTokenRequest().
*
* This function provides a single entry point for obtaining tokens regardless of the
* OAuth grant type. The provider's prepareTokenRequest() method determines which grant
* to use and supplies the grant-specific parameters.
*
* @param provider - OAuth client provider that implements prepareTokenRequest()
* @param authorizationServerUrl - The authorization server's base URL
* @param options - Configuration for the token request
* @returns Promise resolving to OAuth tokens
* @throws {Error} When provider doesn't implement prepareTokenRequest or token fetch fails
*
* @example
* // Provider for client_credentials:
* class MyProvider implements OAuthClientProvider {
*   prepareTokenRequest(scope) {
*     const params = new URLSearchParams({ grant_type: 'client_credentials' });
*     if (scope) params.set('scope', scope);
*     return params;
*   }
*   // ... other methods
* }
*
* const tokens = await fetchToken(provider, authServerUrl, { metadata });
*/
async function fetchToken(provider, authorizationServerUrl, { metadata, resource, authorizationCode, fetchFn } = {}) {
	const scope = provider.clientMetadata.scope;
	let tokenRequestParams;
	if (provider.prepareTokenRequest) {
		tokenRequestParams = await provider.prepareTokenRequest(scope);
	}
	if (!tokenRequestParams) {
		if (!authorizationCode) {
			throw new Error("Either provider.prepareTokenRequest() or authorizationCode is required");
		}
		if (!provider.redirectUrl) {
			throw new Error("redirectUrl is required for authorization_code flow");
		}
		const codeVerifier = await provider.codeVerifier();
		tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, provider.redirectUrl);
	}
	const clientInformation = await provider.clientInformation();
	return executeTokenRequest(authorizationServerUrl, {
		metadata,
		tokenRequestParams,
		clientInformation: clientInformation ?? undefined,
		addClientAuthentication: provider.addClientAuthentication,
		resource,
		fetchFn
	});
}
/**
* Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.
*/
async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
	let registrationUrl;
	if (metadata) {
		if (!metadata.registration_endpoint) {
			throw new Error("Incompatible auth server: does not support dynamic client registration");
		}
		registrationUrl = new URL(metadata.registration_endpoint);
	} else {
		registrationUrl = new URL("/register", authorizationServerUrl);
	}
	const response = await (fetchFn ?? fetch)(registrationUrl, {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify(clientMetadata)
	});
	if (!response.ok) {
		throw await parseErrorResponse(response);
	}
	return OAuthClientInformationFullSchema.parse(await response.json());
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/error-classifier.js
const AUTH_STATUSES = new Set([
	401,
	403,
	405
]);
const OFFLINE_PATTERNS = [
	"fetch failed",
	"econnrefused",
	"connection refused",
	"connection closed",
	"connection reset",
	"socket hang up",
	"connect timeout",
	"network is unreachable",
	"timed out",
	"timeout",
	"timeout after",
	"getaddrinfo",
	"enotfound",
	"enoent",
	"eai_again",
	"econnaborted",
	"ehostunreach",
	"no such host",
	"failed to start",
	"spawn enoent"
];
const HTTP_STATUS_FALLBACK = /\bhttps?:\/\/[^\s]+(?:\s+returned\s+)?(?:status|code)?\s*(\d{3})\b/i;
const STATUS_DIRECT_PATTERN = /\b(?:status(?:\s+code)?|http(?:\s+(?:status|code|error))?)[:\s]*(\d{3})\b/i;
const STDIO_EXIT_PATTERN = /exit(?:ed)?(?:\s+with)?(?:\s+(?:code|status))\s+(-?\d+)/i;
const STDIO_SIGNAL_PATTERN = /signal\s+([A-Z0-9]+)/i;
function analyzeConnectionError(error$47) {
	const rawMessage = extractMessage(error$47);
	if (error$47 instanceof UnauthorizedError) {
		return {
			kind: "auth",
			rawMessage
		};
	}
	const stdio = extractStdioExit(rawMessage);
	if (stdio) {
		return {
			kind: "stdio-exit",
			rawMessage,
			...stdio
		};
	}
	const statusCode = extractStatusCode(rawMessage);
	const normalized = rawMessage.toLowerCase();
	if (AUTH_STATUSES.has(statusCode ?? -1) || containsAuthToken(normalized)) {
		return {
			kind: "auth",
			rawMessage,
			statusCode
		};
	}
	if (statusCode && statusCode >= 400) {
		return {
			kind: "http",
			rawMessage,
			statusCode
		};
	}
	if (OFFLINE_PATTERNS.some((pattern) => normalized.includes(pattern))) {
		return {
			kind: "offline",
			rawMessage
		};
	}
	return {
		kind: "other",
		rawMessage
	};
}
function isAuthIssue(issue$1) {
	return issue$1.kind === "auth";
}
function extractMessage(error$47) {
	if (error$47 instanceof Error) {
		return error$47.message ?? "";
	}
	if (typeof error$47 === "string") {
		return error$47;
	}
	if (error$47 === undefined || error$47 === null) {
		return "";
	}
	try {
		return JSON.stringify(error$47);
	} catch {
		return "";
	}
}
function extractStatusCode(message) {
	const candidates = [
		message.match(/status code\s*\((\d{3})\)/i)?.[1],
		message.match(STATUS_DIRECT_PATTERN)?.[1],
		message.match(HTTP_STATUS_FALLBACK)?.[1]
	].filter(Boolean);
	for (const candidate of candidates) {
		const parsed = Number.parseInt(candidate, 10);
		if (Number.isFinite(parsed)) {
			return parsed;
		}
	}
	const trimmed = message.trim();
	if (trimmed.startsWith("{")) {
		try {
			const parsed = JSON.parse(trimmed);
			const candidate = findStatusInObject(parsed);
			if (typeof candidate === "number") {
				return candidate;
			}
			if (typeof candidate === "string") {
				const numeric = Number.parseInt(candidate, 10);
				if (Number.isFinite(numeric)) {
					return numeric;
				}
			}
		} catch {}
	}
	return undefined;
}
function containsAuthToken(normalizedMessage) {
	return normalizedMessage.includes("401") || normalizedMessage.includes("unauthorized") || normalizedMessage.includes("invalid_token") || normalizedMessage.includes("forbidden");
}
function extractStdioExit(message) {
	if (!message.toLowerCase().includes("stdio") && !STDIO_EXIT_PATTERN.test(message)) {
		return undefined;
	}
	const exitMatch = message.match(STDIO_EXIT_PATTERN);
	const signalMatch = message.match(STDIO_SIGNAL_PATTERN);
	if (!exitMatch && !signalMatch) {
		return undefined;
	}
	const exitCode = exitMatch ? Number.parseInt(exitMatch[1] ?? "", 10) : undefined;
	return {
		stdioExitCode: Number.isFinite(exitCode) ? exitCode : undefined,
		stdioSignal: signalMatch?.[1]
	};
}
function findStatusInObject(value) {
	if (!value || typeof value !== "object") {
		return undefined;
	}
	const record$2 = value;
	if (typeof record$2.status === "number" || typeof record$2.status === "string") {
		return record$2.status;
	}
	if (typeof record$2.code === "number" || typeof record$2.code === "string") {
		return record$2.code;
	}
	if (typeof record$2.error === "object" && record$2.error !== null) {
		return findStatusInObject(record$2.error);
	}
	return undefined;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/result-utils.js
function extractContentArray(raw) {
	if (!raw || typeof raw !== "object") {
		return null;
	}
	const obj = raw;
	if ("content" in obj && Array.isArray(obj.content)) {
		return obj.content;
	}
	if ("raw" in obj && obj.raw && typeof obj.raw === "object") {
		const nested = obj.raw;
		if ("content" in nested && Array.isArray(nested.content)) {
			return nested.content;
		}
	}
	return null;
}
function extractStructuredContent(raw) {
	if (!raw || typeof raw !== "object") {
		return null;
	}
	const obj = raw;
	if ("structuredContent" in obj) {
		return obj.structuredContent;
	}
	if ("raw" in obj && obj.raw && typeof obj.raw === "object") {
		const nested = obj.raw;
		if ("structuredContent" in nested) {
			return nested.structuredContent;
		}
	}
	return null;
}
function asString(value) {
	if (typeof value === "string") {
		return value;
	}
	if (value && typeof value === "object" && "text" in value) {
		const text = value.text;
		return typeof text === "string" ? text : null;
	}
	return null;
}
function collectText(content, joiner) {
	const pieces = [];
	for (const entry of content) {
		if (entry && typeof entry === "object" && "type" in entry) {
			const type = entry.type;
			if (type === "text" || type === "markdown") {
				const text = asString(entry);
				if (text) {
					pieces.push(text);
				}
			}
		}
	}
	if (pieces.length > 0) {
		return pieces.join(joiner);
	}
	return null;
}
function tryParseJson(value) {
	if (value === undefined || value === null) {
		return null;
	}
	if (typeof value === "object") {
		if ("json" in value) {
			return value.json ?? null;
		}
		if ("data" in value) {
			return value.data ?? null;
		}
	}
	if (typeof value === "string") {
		try {
			return JSON.parse(value);
		} catch {
			return null;
		}
	}
	return null;
}
function createCallResult(raw) {
	return {
		raw,
		text(joiner = "\n") {
			if (raw == null) {
				return null;
			}
			if (typeof raw === "string") {
				return raw;
			}
			const content = extractContentArray(raw);
			if (content) {
				const collected = collectText(content, joiner);
				if (collected) {
					return collected;
				}
			}
			const structured = extractStructuredContent(raw);
			const asStr = asString(structured);
			return asStr ?? null;
		},
		markdown(joiner = "\n") {
			const structured = extractStructuredContent(raw);
			if (structured && typeof structured === "object") {
				const markdown = structured.markdown;
				if (typeof markdown === "string") {
					return markdown;
				}
			}
			const content = extractContentArray(raw);
			if (!content) {
				return null;
			}
			const markdownEntries = content.filter((entry) => entry && typeof entry === "object" && entry.type === "markdown");
			if (markdownEntries.length === 0) {
				return null;
			}
			return markdownEntries.map((entry) => asString(entry) ?? "").filter(Boolean).join(joiner);
		},
		json() {
			const structured = extractStructuredContent(raw);
			const parsedStructured = tryParseJson(structured);
			if (parsedStructured !== null) {
				return parsedStructured;
			}
			const content = extractContentArray(raw);
			if (content) {
				for (const entry of content) {
					if (entry && typeof entry === "object") {
						const typedEntry = entry;
						if (typedEntry.type === "json") {
							const parsed = tryParseJson(entry);
							if (parsed !== null) {
								return parsed;
							}
							continue;
						}
						if (typedEntry.type === "text" || typedEntry.type === "markdown") {
							const text = asString(entry);
							if (typeof text === "string") {
								const parsedText = tryParseJson(text);
								if (parsedText !== null) {
									return parsedText;
								}
							}
							continue;
						}
					}
					if (typeof entry === "string") {
						const parsed = tryParseJson(entry);
						if (parsed !== null) {
							return parsed;
						}
					}
				}
			}
			if (typeof raw === "string") {
				const parsedRaw = tryParseJson(raw);
				if (parsedRaw !== null) {
					return parsedRaw;
				}
			}
			const textContent = this.text?.();
			if (typeof textContent === "string") {
				const parsedText = tryParseJson(textContent);
				if (parsedText !== null) {
					return parsedText;
				}
			}
			const markdownContent = this.markdown?.();
			if (typeof markdownContent === "string") {
				const parsedMarkdown = tryParseJson(markdownContent);
				if (parsedMarkdown !== null) {
					return parsedMarkdown;
				}
			}
			return null;
		},
		content() {
			return extractContentArray(raw);
		},
		structuredContent() {
			return extractStructuredContent(raw);
		}
	};
}
function describeConnectionIssue(error$47) {
	return analyzeConnectionError(error$47);
}
function wrapCallResult(raw) {
	return {
		raw,
		callResult: createCallResult(raw)
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/logging.js
const LOG_LEVEL_ORDER = {
	debug: 10,
	info: 20,
	warn: 30,
	error: 40
};
const LOG_LEVEL_ALIASES = {
	warning: "warn",
	verbose: "debug"
};
function parseLogLevel(value, defaultLevel = "warn") {
	if (!value) {
		return defaultLevel;
	}
	const normalized = value.trim().toLowerCase();
	if (!normalized) {
		return defaultLevel;
	}
	const alias = LOG_LEVEL_ALIASES[normalized];
	const candidate = alias ?? (normalized in LOG_LEVEL_ORDER ? normalized : undefined);
	if (!candidate) {
		const allowed = [...Object.keys(LOG_LEVEL_ORDER), ...Object.keys(LOG_LEVEL_ALIASES)].filter((key, index, array$2) => array$2.indexOf(key) === index).join(", ");
		throw new Error(`Invalid log level '${value}'. Expected one of: ${allowed}.`);
	}
	return candidate;
}
function resolveLogLevelFromEnv(env = process.env, defaultLevel = "warn") {
	try {
		return parseLogLevel(env.MCPORTER_LOG_LEVEL, defaultLevel);
	} catch (error$47) {
		const raw = env.MCPORTER_LOG_LEVEL;
		const message = error$47 instanceof Error ? error$47.message : String(error$47);
		console.warn(`[mcporter] Ignoring invalid MCPORTER_LOG_LEVEL value '${raw ?? ""}': ${message}`);
		return defaultLevel;
	}
}
function shouldLog(level, threshold) {
	return LOG_LEVEL_ORDER[level] >= LOG_LEVEL_ORDER[threshold];
}
function createPrefixedConsoleLogger(prefix, level) {
	const threshold = parseLogLevel(level);
	const format$2 = (message) => `[${prefix}] ${message}`;
	return {
		debug(message) {
			if (shouldLog("debug", threshold)) {
				console.debug(format$2(message));
			}
		},
		info(message) {
			if (shouldLog("info", threshold)) {
				console.log(format$2(message));
			}
		},
		warn(message) {
			if (shouldLog("warn", threshold)) {
				console.warn(format$2(message));
			}
		},
		error(message, error$47) {
			if (shouldLog("error", threshold)) {
				console.error(format$2(message));
				if (error$47) {
					console.error(error$47);
				}
			}
		}
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/isexe/windows.js
var require_windows = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = isexe;
	isexe.sync = sync;
	var fs$7 = require("fs");
	function checkPathExt(path$12, options) {
		var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
		if (!pathext) {
			return true;
		}
		pathext = pathext.split(";");
		if (pathext.indexOf("") !== -1) {
			return true;
		}
		for (var i = 0; i < pathext.length; i++) {
			var p = pathext[i].toLowerCase();
			if (p && path$12.substr(-p.length).toLowerCase() === p) {
				return true;
			}
		}
		return false;
	}
	function checkStat(stat, path$12, options) {
		if (!stat.isSymbolicLink() && !stat.isFile()) {
			return false;
		}
		return checkPathExt(path$12, options);
	}
	function isexe(path$12, options, cb) {
		fs$7.stat(path$12, function(er, stat) {
			cb(er, er ? false : checkStat(stat, path$12, options));
		});
	}
	function sync(path$12, options) {
		return checkStat(fs$7.statSync(path$12), path$12, options);
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/isexe/mode.js
var require_mode = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = isexe;
	isexe.sync = sync;
	var fs$6 = require("fs");
	function isexe(path$12, options, cb) {
		fs$6.stat(path$12, function(er, stat) {
			cb(er, er ? false : checkStat(stat, options));
		});
	}
	function sync(path$12, options) {
		return checkStat(fs$6.statSync(path$12), options);
	}
	function checkStat(stat, options) {
		return stat.isFile() && checkMode(stat, options);
	}
	function checkMode(stat, options) {
		var mod = stat.mode;
		var uid = stat.uid;
		var gid = stat.gid;
		var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
		var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
		var u = parseInt("100", 8);
		var g = parseInt("010", 8);
		var o = parseInt("001", 8);
		var ug = u | g;
		var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
		return ret;
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/isexe/index.js
var require_isexe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fs$5 = require("fs");
	var core;
	if (process.platform === "win32" || global.TESTING_WINDOWS) {
		core = require_windows();
	} else {
		core = require_mode();
	}
	module.exports = isexe;
	isexe.sync = sync;
	function isexe(path$12, options, cb) {
		if (typeof options === "function") {
			cb = options;
			options = {};
		}
		if (!cb) {
			if (typeof Promise !== "function") {
				throw new TypeError("callback not provided");
			}
			return new Promise(function(resolve, reject) {
				isexe(path$12, options || {}, function(er, is) {
					if (er) {
						reject(er);
					} else {
						resolve(is);
					}
				});
			});
		}
		core(path$12, options || {}, function(er, is) {
			if (er) {
				if (er.code === "EACCES" || options && options.ignoreErrors) {
					er = null;
					is = false;
				}
			}
			cb(er, is);
		});
	}
	function sync(path$12, options) {
		try {
			return core.sync(path$12, options || {});
		} catch (er) {
			if (options && options.ignoreErrors || er.code === "EACCES") {
				return false;
			} else {
				throw er;
			}
		}
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/which/which.js
var require_which = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
	const path$6 = require("path");
	const COLON = isWindows ? ";" : ":";
	const isexe = require_isexe();
	const getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
	const getPathInfo = (cmd, opt) => {
		const colon = opt.colon || COLON;
		const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [...isWindows ? [process.cwd()] : [], ...(opt.path || process.env.PATH || "").split(colon)];
		const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
		const pathExt = isWindows ? pathExtExe.split(colon) : [""];
		if (isWindows) {
			if (cmd.indexOf(".") !== -1 && pathExt[0] !== "") pathExt.unshift("");
		}
		return {
			pathEnv,
			pathExt,
			pathExtExe
		};
	};
	const which = (cmd, opt, cb) => {
		if (typeof opt === "function") {
			cb = opt;
			opt = {};
		}
		if (!opt) opt = {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found = [];
		const step = (i) => new Promise((resolve, reject) => {
			if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
			const ppRaw = pathEnv[i];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$6.join(pathPart, cmd);
			const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
			resolve(subStep(p, i, 0));
		});
		const subStep = (p, i, ii) => new Promise((resolve, reject) => {
			if (ii === pathExt.length) return resolve(step(i + 1));
			const ext = pathExt[ii];
			isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
				if (!er && is) {
					if (opt.all) found.push(p + ext);
					else return resolve(p + ext);
				}
				return resolve(subStep(p, i, ii + 1));
			});
		});
		return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
	};
	const whichSync = (cmd, opt) => {
		opt = opt || {};
		const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
		const found = [];
		for (let i = 0; i < pathEnv.length; i++) {
			const ppRaw = pathEnv[i];
			const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
			const pCmd = path$6.join(pathPart, cmd);
			const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
			for (let j = 0; j < pathExt.length; j++) {
				const cur = p + pathExt[j];
				try {
					const is = isexe.sync(cur, { pathExt: pathExtExe });
					if (is) {
						if (opt.all) found.push(cur);
						else return cur;
					}
				} catch (ex) {}
			}
		}
		if (opt.all && found.length) return found;
		if (opt.nothrow) return null;
		throw getNotFoundError(cmd);
	};
	module.exports = which;
	which.sync = whichSync;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/path-key/index.js
var require_path_key = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const pathKey = (options = {}) => {
		const environment = options.env || process.env;
		const platform = options.platform || process.platform;
		if (platform !== "win32") {
			return "PATH";
		}
		return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
	};
	module.exports = pathKey;
	module.exports.default = pathKey;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const path$5 = require("path");
	const which = require_which();
	const getPathKey = require_path_key();
	function resolveCommandAttempt(parsed, withoutPathExt) {
		const env = parsed.options.env || process.env;
		const cwd = process.cwd();
		const hasCustomCwd = parsed.options.cwd != null;
		const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
		if (shouldSwitchCwd) {
			try {
				process.chdir(parsed.options.cwd);
			} catch (err) {}
		}
		let resolved;
		try {
			resolved = which.sync(parsed.command, {
				path: env[getPathKey({ env })],
				pathExt: withoutPathExt ? path$5.delimiter : undefined
			});
		} catch (e) {} finally {
			if (shouldSwitchCwd) {
				process.chdir(cwd);
			}
		}
		if (resolved) {
			resolved = path$5.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
		}
		return resolved;
	}
	function resolveCommand(parsed) {
		return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
	}
	module.exports = resolveCommand;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/cross-spawn/lib/util/escape.js
var require_escape = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
	function escapeCommand(arg) {
		arg = arg.replace(metaCharsRegExp, "^$1");
		return arg;
	}
	function escapeArgument(arg, doubleEscapeMetaChars) {
		arg = `${arg}`;
		arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
		arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
		arg = `"${arg}"`;
		arg = arg.replace(metaCharsRegExp, "^$1");
		if (doubleEscapeMetaChars) {
			arg = arg.replace(metaCharsRegExp, "^$1");
		}
		return arg;
	}
	module.exports.command = escapeCommand;
	module.exports.argument = escapeArgument;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/shebang-regex/index.js
var require_shebang_regex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = /^#!(.*)/;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/shebang-command/index.js
var require_shebang_command = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const shebangRegex = require_shebang_regex();
	module.exports = (string$5 = "") => {
		const match = string$5.match(shebangRegex);
		if (!match) {
			return null;
		}
		const [path$12, argument] = match[0].replace(/#! ?/, "").split(" ");
		const binary = path$12.split("/").pop();
		if (binary === "env") {
			return argument;
		}
		return argument ? `${binary} ${argument}` : binary;
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const fs$4 = require("fs");
	const shebangCommand = require_shebang_command();
	function readShebang(command) {
		const size = 150;
		const buffer = Buffer.alloc(size);
		let fd;
		try {
			fd = fs$4.openSync(command, "r");
			fs$4.readSync(fd, buffer, 0, size, 0);
			fs$4.closeSync(fd);
		} catch (e) {}
		return shebangCommand(buffer.toString());
	}
	module.exports = readShebang;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/cross-spawn/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const path$4 = require("path");
	const resolveCommand = require_resolveCommand();
	const escape = require_escape();
	const readShebang = require_readShebang();
	const isWin = process.platform === "win32";
	const isExecutableRegExp = /\.(?:com|exe)$/i;
	const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
	function detectShebang(parsed) {
		parsed.file = resolveCommand(parsed);
		const shebang = parsed.file && readShebang(parsed.file);
		if (shebang) {
			parsed.args.unshift(parsed.file);
			parsed.command = shebang;
			return resolveCommand(parsed);
		}
		return parsed.file;
	}
	function parseNonShell(parsed) {
		if (!isWin) {
			return parsed;
		}
		const commandFile = detectShebang(parsed);
		const needsShell = !isExecutableRegExp.test(commandFile);
		if (parsed.options.forceShell || needsShell) {
			const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
			parsed.command = path$4.normalize(parsed.command);
			parsed.command = escape.command(parsed.command);
			parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
			const shellCommand = [parsed.command].concat(parsed.args).join(" ");
			parsed.args = [
				"/d",
				"/s",
				"/c",
				`"${shellCommand}"`
			];
			parsed.command = process.env.comspec || "cmd.exe";
			parsed.options.windowsVerbatimArguments = true;
		}
		return parsed;
	}
	function parse(command, args, options) {
		if (args && !Array.isArray(args)) {
			options = args;
			args = null;
		}
		args = args ? args.slice(0) : [];
		options = Object.assign({}, options);
		const parsed = {
			command,
			args,
			options,
			file: undefined,
			original: {
				command,
				args
			}
		};
		return options.shell ? parsed : parseNonShell(parsed);
	}
	module.exports = parse;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/cross-spawn/lib/enoent.js
var require_enoent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const isWin = process.platform === "win32";
	function notFoundError(original, syscall) {
		return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
			code: "ENOENT",
			errno: "ENOENT",
			syscall: `${syscall} ${original.command}`,
			path: original.command,
			spawnargs: original.args
		});
	}
	function hookChildProcess(cp$1, parsed) {
		if (!isWin) {
			return;
		}
		const originalEmit = cp$1.emit;
		cp$1.emit = function(name, arg1) {
			if (name === "exit") {
				const err = verifyENOENT(arg1, parsed);
				if (err) {
					return originalEmit.call(cp$1, "error", err);
				}
			}
			return originalEmit.apply(cp$1, arguments);
		};
	}
	function verifyENOENT(status, parsed) {
		if (isWin && status === 1 && !parsed.file) {
			return notFoundError(parsed.original, "spawn");
		}
		return null;
	}
	function verifyENOENTSync(status, parsed) {
		if (isWin && status === 1 && !parsed.file) {
			return notFoundError(parsed.original, "spawnSync");
		}
		return null;
	}
	module.exports = {
		hookChildProcess,
		verifyENOENT,
		verifyENOENTSync,
		notFoundError
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/cross-spawn/index.js
var require_cross_spawn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const cp = require("child_process");
	const parse = require_parse();
	const enoent = require_enoent();
	function spawn(command, args, options) {
		const parsed = parse(command, args, options);
		const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
		enoent.hookChildProcess(spawned, parsed);
		return spawned;
	}
	function spawnSync(command, args, options) {
		const parsed = parse(command, args, options);
		const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
		result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
		return result;
	}
	module.exports = spawn;
	module.exports.spawn = spawn;
	module.exports.sync = spawnSync;
	module.exports._parse = parse;
	module.exports._enoent = enoent;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var import_cross_spawn = /* @__PURE__ */ __toESM(require_cross_spawn(), 1);
/**
* Buffers a continuous stdio stream into discrete JSON-RPC messages.
*/
var ReadBuffer = class {
	append(chunk) {
		this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
	}
	readMessage() {
		if (!this._buffer) {
			return null;
		}
		const index = this._buffer.indexOf("\n");
		if (index === -1) {
			return null;
		}
		const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
		this._buffer = this._buffer.subarray(index + 1);
		return deserializeMessage(line);
	}
	clear() {
		this._buffer = undefined;
	}
};
function deserializeMessage(line) {
	return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
	return JSON.stringify(message) + "\n";
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js
/**
* Environment variables to inherit by default, if an environment is not explicitly given.
*/
const DEFAULT_INHERITED_ENV_VARS = node_process.default.platform === "win32" ? [
	"APPDATA",
	"HOMEDRIVE",
	"HOMEPATH",
	"LOCALAPPDATA",
	"PATH",
	"PROCESSOR_ARCHITECTURE",
	"SYSTEMDRIVE",
	"SYSTEMROOT",
	"TEMP",
	"USERNAME",
	"USERPROFILE",
	"PROGRAMFILES"
] : [
	"HOME",
	"LOGNAME",
	"PATH",
	"SHELL",
	"TERM",
	"USER"
];
/**
* Returns a default environment object including only environment variables deemed safe to inherit.
*/
function getDefaultEnvironment() {
	const env = {};
	for (const key of DEFAULT_INHERITED_ENV_VARS) {
		const value = node_process.default.env[key];
		if (value === undefined) {
			continue;
		}
		if (value.startsWith("()")) {
			continue;
		}
		env[key] = value;
	}
	return env;
}
/**
* Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.
*
* This transport is only available in Node.js environments.
*/
var StdioClientTransport = class {
	constructor(server) {
		this._readBuffer = new ReadBuffer();
		this._stderrStream = null;
		this._serverParams = server;
		if (server.stderr === "pipe" || server.stderr === "overlapped") {
			this._stderrStream = new node_stream.PassThrough();
		}
	}
	/**
	* Starts the server process and prepares to communicate with it.
	*/
	async start() {
		if (this._process) {
			throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
		}
		return new Promise((resolve, reject) => {
			this._process = (0, import_cross_spawn.default)(this._serverParams.command, this._serverParams.args ?? [], {
				env: {
					...getDefaultEnvironment(),
					...this._serverParams.env
				},
				stdio: [
					"pipe",
					"pipe",
					this._serverParams.stderr ?? "inherit"
				],
				shell: false,
				windowsHide: node_process.default.platform === "win32" && isElectron(),
				cwd: this._serverParams.cwd
			});
			this._process.on("error", (error$47) => {
				reject(error$47);
				this.onerror?.(error$47);
			});
			this._process.on("spawn", () => {
				resolve();
			});
			this._process.on("close", (_code) => {
				this._process = undefined;
				this.onclose?.();
			});
			this._process.stdin?.on("error", (error$47) => {
				this.onerror?.(error$47);
			});
			this._process.stdout?.on("data", (chunk) => {
				this._readBuffer.append(chunk);
				this.processReadBuffer();
			});
			this._process.stdout?.on("error", (error$47) => {
				this.onerror?.(error$47);
			});
			if (this._stderrStream && this._process.stderr) {
				this._process.stderr.pipe(this._stderrStream);
			}
		});
	}
	/**
	* The stderr stream of the child process, if `StdioServerParameters.stderr` was set to "pipe" or "overlapped".
	*
	* If stderr piping was requested, a PassThrough stream is returned _immediately_, allowing callers to
	* attach listeners before the start method is invoked. This prevents loss of any early
	* error output emitted by the child process.
	*/
	get stderr() {
		if (this._stderrStream) {
			return this._stderrStream;
		}
		return this._process?.stderr ?? null;
	}
	/**
	* The child process pid spawned by this transport.
	*
	* This is only available after the transport has been started.
	*/
	get pid() {
		return this._process?.pid ?? null;
	}
	processReadBuffer() {
		while (true) {
			try {
				const message = this._readBuffer.readMessage();
				if (message === null) {
					break;
				}
				this.onmessage?.(message);
			} catch (error$47) {
				this.onerror?.(error$47);
			}
		}
	}
	async close() {
		if (this._process) {
			const processToClose = this._process;
			this._process = undefined;
			const closePromise = new Promise((resolve) => {
				processToClose.once("close", () => {
					resolve();
				});
			});
			try {
				processToClose.stdin?.end();
			} catch {}
			await Promise.race([closePromise, new Promise((resolve) => setTimeout(resolve, 2e3).unref())]);
			if (processToClose.exitCode === null) {
				try {
					processToClose.kill("SIGTERM");
				} catch {}
				await Promise.race([closePromise, new Promise((resolve) => setTimeout(resolve, 2e3).unref())]);
			}
			if (processToClose.exitCode === null) {
				try {
					processToClose.kill("SIGKILL");
				} catch {}
			}
		}
		this._readBuffer.clear();
	}
	send(message) {
		return new Promise((resolve) => {
			if (!this._process?.stdin) {
				throw new Error("Not connected");
			}
			const json$2 = serializeMessage(message);
			if (this._process.stdin.write(json$2)) {
				resolve();
			} else {
				this._process.stdin.once("drain", resolve);
			}
		});
	}
};
function isElectron() {
	return "type" in node_process.default;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime-process-utils.js
async function closeTransportAndWait(logger, transport) {
	const pidBeforeClose = getTransportPid(transport);
	const childProcess$1 = transport instanceof StdioClientTransport ? transport._process ?? null : null;
	try {
		await transport.close();
	} catch (error$47) {
		logger.warn(`Failed to close transport cleanly: ${error$47.message}`);
	}
	if (childProcess$1) {
		await waitForChildClose$1(childProcess$1, 1e3).catch(() => {});
	}
	if (!pidBeforeClose) {
		return;
	}
	await ensureProcessTerminated(logger, pidBeforeClose);
}
function getTransportPid(transport) {
	if (transport instanceof StdioClientTransport) {
		const pid = transport.pid;
		return typeof pid === "number" && pid > 0 ? pid : null;
	}
	if ("pid" in transport) {
		const candidate = transport.pid;
		if (typeof candidate === "number" && candidate > 0) {
			return candidate;
		}
	}
	const rawPid = transport._process?.pid;
	return typeof rawPid === "number" && rawPid > 0 ? rawPid : null;
}
async function ensureProcessTerminated(logger, pid) {
	await ensureProcessTreeTerminated(logger, pid);
}
async function waitForChildClose$1(child, timeoutMs) {
	if (child.exitCode !== null && child.exitCode !== undefined) {
		return;
	}
	await new Promise((resolve) => {
		let settled = false;
		const finish = () => {
			if (settled) {
				return;
			}
			settled = true;
			cleanup();
			resolve();
		};
		const cleanup = () => {
			child.removeListener("close", finish);
			child.removeListener("exit", finish);
			child.removeListener("error", finish);
			if (timer) {
				clearTimeout(timer);
			}
		};
		child.once("close", finish);
		child.once("exit", finish);
		child.once("error", finish);
		let timer;
		if (Number.isFinite(timeoutMs) && timeoutMs > 0) {
			timer = setTimeout(finish, timeoutMs);
			timer.unref?.();
		}
	});
	try {
		child.stdin?.end?.();
	} catch {}
	try {
		child.stdout?.destroy?.();
		child.stdout?.removeAllListeners?.();
		child.stdout?.unref?.();
	} catch {}
	try {
		child.stderr?.destroy?.();
		child.stderr?.removeAllListeners?.();
		child.stderr?.unref?.();
	} catch {}
	try {
		const stdio = child.stdio;
		if (Array.isArray(stdio)) {
			for (const stream$1 of stdio) {
				if (!stream$1 || typeof stream$1 !== "object") {
					continue;
				}
				try {
					stream$1.removeAllListeners?.();
					stream$1.destroy?.();
					stream$1.end?.();
				} catch {}
			}
		}
	} catch {}
	try {
		child.removeAllListeners();
	} catch {}
	try {
		child.unref?.();
	} catch {}
}
function isProcessAlive(pid) {
	try {
		process.kill(pid, 0);
		return true;
	} catch {
		return false;
	}
}
async function ensureProcessTreeTerminated(logger, rootPid) {
	if (!isProcessAlive(rootPid)) {
		return;
	}
	let targets = await collectProcessTreePids(rootPid);
	if (await waitForTreeExit(targets, 300)) {
		return;
	}
	await sendSignalToTargets(targets, "SIGTERM");
	targets = await collectProcessTreePids(rootPid);
	if (await waitForTreeExit(targets, 700)) {
		return;
	}
	targets = await collectProcessTreePids(rootPid);
	await sendSignalToTargets(targets, "SIGKILL");
	if (await waitForTreeExit(targets, 500)) {
		return;
	}
	logger.warn(`Process tree rooted at pid=${rootPid} did not exit after SIGKILL.`);
}
async function sendSignalToTargets(pids, signal) {
	const seen = new Set();
	for (const pid of pids) {
		if (seen.has(pid)) {
			continue;
		}
		seen.add(pid);
		sendSignal(pid, signal);
	}
}
function sendSignal(pid, signal) {
	try {
		process.kill(pid, signal);
	} catch (error$47) {
		if (typeof error$47 === "object" && error$47 && "code" in error$47 && error$47.code === "ESRCH") {
			return;
		}
		throw error$47;
	}
}
async function listDescendantPids(rootPid) {
	if (!isProcessAlive(rootPid)) {
		return [];
	}
	if (process.platform === "win32") {
		return listDescendantPidsWindows(rootPid);
	}
	try {
		const { stdout } = await execFileAsync("ps", ["-eo", "pid=,ppid="]);
		const children = new Map();
		for (const line of stdout.split("\n")) {
			const trimmed = line.trim();
			if (!trimmed) {
				continue;
			}
			const [pidText, ppidText] = trimmed.split(/\s+/, 2);
			const pid = Number.parseInt(pidText ?? "", 10);
			const ppid = Number.parseInt(ppidText ?? "", 10);
			if (!Number.isFinite(pid) || !Number.isFinite(ppid)) {
				continue;
			}
			const bucket = children.get(ppid) ?? [];
			bucket.push(pid);
			children.set(ppid, bucket);
		}
		return collectDescendantsFromChildren(rootPid, children);
	} catch {
		return [];
	}
}
async function listDescendantPidsWindows(rootPid) {
	try {
		const powershellScript = "Get-CimInstance Win32_Process | Select-Object ProcessId,ParentProcessId | ConvertTo-Json -Compress";
		const { stdout } = await execFileAsync("powershell.exe", [
			"-NoProfile",
			"-Command",
			powershellScript
		]);
		const trimmed = stdout.trim();
		if (!trimmed) {
			return [];
		}
		const parsed = JSON.parse(trimmed);
		const entries = Array.isArray(parsed) ? parsed : [parsed];
		const children = new Map();
		for (const entry of entries) {
			const pidCandidate = entry?.ProcessId;
			const ppidCandidate = entry?.ParentProcessId;
			if (typeof pidCandidate !== "number" || typeof ppidCandidate !== "number") {
				continue;
			}
			const pid = Number.isFinite(pidCandidate) ? pidCandidate : undefined;
			const ppid = Number.isFinite(ppidCandidate) ? ppidCandidate : undefined;
			if (pid === undefined || ppid === undefined) {
				continue;
			}
			const bucket = children.get(ppid) ?? [];
			bucket.push(pid);
			children.set(ppid, bucket);
		}
		return collectDescendantsFromChildren(rootPid, children);
	} catch {
		return [];
	}
}
function execFileAsync(command, args) {
	return new Promise((resolve, reject) => {
		(0, node_child_process.execFile)(command, args, { encoding: "utf8" }, (error$47, stdout, stderr) => {
			if (error$47) {
				reject(error$47);
				return;
			}
			resolve({
				stdout,
				stderr
			});
		});
	});
}
async function collectProcessTreePids(rootPid) {
	const descendants = await listDescendantPids(rootPid);
	return [...descendants, rootPid];
}
function collectDescendantsFromChildren(rootPid, children) {
	const result = [];
	const queue = [...children.get(rootPid) ?? []];
	const seen = new Set(queue);
	while (queue.length > 0) {
		const current = queue.shift();
		if (current === undefined) {
			continue;
		}
		result.push(current);
		for (const child of children.get(current) ?? []) {
			if (!seen.has(child)) {
				seen.add(child);
				queue.push(child);
			}
		}
	}
	return result;
}
const __testHooks = { listDescendantPids };
async function waitForTreeExit(pids, durationMs) {
	const deadline = Date.now() + durationMs;
	while (true) {
		if (pids.every((pid) => !isProcessAlive(pid))) {
			return true;
		}
		if (Date.now() >= deadline) {
			return false;
		}
		const remaining = Math.max(10, Math.min(100, deadline - Date.now()));
		await delay(remaining);
	}
}
function delay(ms) {
	return new Promise((resolve) => {
		const timer = setTimeout(resolve, ms);
		if (typeof timer.unref === "function") {
			timer.unref?.();
		}
	});
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/sdk-patches.js
const PROCESS_BUFFERS = new WeakMap();
const TRANSPORT_BUFFERS = new WeakMap();
const STDIO_LOGS_FORCED = process.env.MCPORTER_STDIO_LOGS === "1";
const STDIO_TRACE_ENABLED$1 = process.env.MCPORTER_STDIO_TRACE === "1";
let stdioLogMode = STDIO_LOGS_FORCED ? "always" : "auto";
function getStdioLogMode() {
	return stdioLogMode;
}
function setStdioLogMode(mode) {
	const previous = stdioLogMode;
	if (!STDIO_LOGS_FORCED) {
		stdioLogMode = mode;
	}
	return previous;
}
function evaluateStdioLogPolicy(mode, hasStderr, exitCode) {
	if (!hasStderr) {
		return false;
	}
	if (mode === "silent") {
		return false;
	}
	if (mode === "always") {
		return true;
	}
	return typeof exitCode === "number" && exitCode !== 0;
}
function shouldPrintStdioLogs(meta$3) {
	return evaluateStdioLogPolicy(stdioLogMode, meta$3.stderrChunks.length > 0, meta$3.code);
}
if (STDIO_TRACE_ENABLED$1) {
	console.log("[mcporter] STDIO trace logging enabled (set MCPORTER_STDIO_TRACE=0 to disable).");
}
function destroyStream(stream$1) {
	if (!stream$1 || typeof stream$1 !== "object") {
		return;
	}
	const emitter = stream$1;
	const swallowError = () => {};
	try {
		emitter.on?.("error", swallowError);
	} catch {}
	try {
		emitter.destroy?.();
	} catch {}
	try {
		emitter.end?.();
	} catch {}
	try {
		emitter.unref?.();
	} catch {}
	try {
		emitter.off?.("error", swallowError);
	} catch {}
	try {
		emitter.removeListener?.("error", swallowError);
	} catch {}
}
function waitForChildClose(child, timeoutMs) {
	if (!child) {
		return Promise.resolve();
	}
	if (child.exitCode !== null && child.exitCode !== undefined) {
		return Promise.resolve();
	}
	return new Promise((resolve) => {
		let settled = false;
		const swallowProcessError = () => {};
		try {
			child.on?.("error", swallowProcessError);
		} catch {}
		const finish = () => {
			if (settled) {
				return;
			}
			settled = true;
			cleanup();
			resolve();
		};
		const cleanup = () => {
			child.removeListener("exit", finish);
			child.removeListener("close", finish);
			child.removeListener("error", finish);
			try {
				child.removeListener?.("error", swallowProcessError);
			} catch {}
			if (timer) {
				clearTimeout(timer);
			}
		};
		child.once("exit", finish);
		child.once("close", finish);
		child.once("error", finish);
		let timer;
		if (Number.isFinite(timeoutMs) && timeoutMs > 0) {
			timer = setTimeout(finish, timeoutMs);
			timer.unref?.();
		}
	});
}
function flushProcessLogs(_child, meta$3) {
	if (meta$3.flushed) {
		return;
	}
	meta$3.flushed = true;
	if (STDIO_TRACE_ENABLED$1) {
		const stderrChunks = meta$3.stderrChunks.length;
		const stdoutChunks = meta$3.stdoutChunks?.length ?? 0;
		const stdinChunks = meta$3.stdinChunks?.length ?? 0;
		const label = meta$3.command ?? "stdio server";
		console.log(`[mcporter] STDIO trace summary for ${label}: stdin=${stdinChunks} message(s), stdout=${stdoutChunks} chunk(s), stderr=${stderrChunks} chunk(s).`);
	}
	for (const { stream: stream$1, event, handler } of meta$3.listeners) {
		try {
			stream$1.removeListener?.(event, handler);
		} catch {}
	}
	meta$3.listeners.length = 0;
	if (shouldPrintStdioLogs(meta$3)) {
		const heading = meta$3.command ? `[mcporter] stderr from ${meta$3.command}` : "[mcporter] stderr from stdio server";
		console.log(heading);
		process.stdout.write(meta$3.stderrChunks.join(""));
		if (!meta$3.stderrChunks[meta$3.stderrChunks.length - 1]?.endsWith("\n")) {
			console.log("");
		}
	}
	if (STDIO_TRACE_ENABLED$1 && meta$3.stdoutChunks && meta$3.stdoutChunks.length > 0) {
		const heading = meta$3.command ? `[mcporter] stdout from ${meta$3.command}` : "[mcporter] stdout from stdio server";
		console.log(heading);
		process.stdout.write(meta$3.stdoutChunks.join(""));
		if (!meta$3.stdoutChunks[meta$3.stdoutChunks.length - 1]?.endsWith("\n")) {
			console.log("");
		}
	}
	if (STDIO_TRACE_ENABLED$1 && meta$3.stdinChunks && meta$3.stdinChunks.length > 0) {
		const heading = meta$3.command ? `[mcporter] stdin to ${meta$3.command}` : "[mcporter] stdin to stdio server";
		console.log(heading);
		for (const entry of meta$3.stdinChunks) {
			console.log(entry);
		}
	}
	if (meta$3.child) {
		PROCESS_BUFFERS.delete(meta$3.child);
	}
	if (meta$3.transport) {
		TRANSPORT_BUFFERS.delete(meta$3.transport);
	}
}
function patchStdioClose() {
	const marker = Symbol.for("mcporter.stdio.patched");
	const proto = StdioClientTransport.prototype;
	if (proto[marker]) {
		return;
	}
	patchStdioStart();
	StdioClientTransport.prototype.close = async function patchedClose() {
		const transport = this;
		const child = transport._process ?? null;
		const stderrStream = transport._stderrStream ?? null;
		const meta$3 = (child ? PROCESS_BUFFERS.get(child) : undefined) ?? TRANSPORT_BUFFERS.get(transport);
		if (stderrStream) {
			destroyStream(stderrStream);
			transport._stderrStream = null;
		}
		transport._abortController?.abort();
		transport._abortController = null;
		transport._readBuffer?.clear?.();
		transport._readBuffer = null;
		if (!child) {
			transport.onclose?.();
			return;
		}
		destroyStream(child.stdin);
		destroyStream(child.stdout);
		destroyStream(child.stderr);
		const stdio = Array.isArray(child.stdio) ? child.stdio : [];
		for (const stream$1 of stdio) {
			destroyStream(stream$1);
		}
		let exited = await waitForChildClose(child, 700).then(() => true, () => false);
		if (!exited) {
			try {
				child.kill("SIGTERM");
			} catch {}
			exited = await waitForChildClose(child, 700).then(() => true, () => false);
		}
		if (!exited) {
			try {
				child.kill("SIGKILL");
			} catch {}
			await waitForChildClose(child, 500).catch(() => {});
		}
		destroyStream(child.stdin);
		destroyStream(child.stdout);
		destroyStream(child.stderr);
		const stdioAfter = Array.isArray(child.stdio) ? child.stdio : [];
		for (const stream$1 of stdioAfter) {
			destroyStream(stream$1);
		}
		child.unref?.();
		if (meta$3) {
			flushProcessLogs(meta$3.child ?? child, meta$3);
		} else if (STDIO_TRACE_ENABLED$1) {
			console.log("[mcporter] STDIO trace: attempted to close transport without recorded metadata.");
		}
		transport._process = null;
		transport.onclose?.();
	};
	proto[marker] = true;
}
function patchStdioStart() {
	const marker = Symbol.for("mcporter.stdio.startPatched");
	const proto = StdioClientTransport.prototype;
	if (proto[marker]) {
		return;
	}
	const originalStart = StdioClientTransport.prototype.start;
	StdioClientTransport.prototype.start = async function patchedStart() {
		const transport = this;
		if (STDIO_TRACE_ENABLED$1) {
			console.log("[mcporter] STDIO trace: start() invoked for stdio transport.");
		}
		if (transport._serverParams && transport._serverParams.stderr !== "pipe") {
			transport._serverParams = {
				...transport._serverParams,
				stderr: "pipe"
			};
		}
		const startPromise = originalStart.apply(this);
		const child = transport._process ?? null;
		const meta$3 = {
			stderrChunks: [],
			stdoutChunks: STDIO_TRACE_ENABLED$1 ? [] : undefined,
			stdinChunks: STDIO_TRACE_ENABLED$1 ? [] : undefined,
			command: transport._serverParams?.command,
			code: null,
			listeners: [],
			child,
			transport
		};
		TRANSPORT_BUFFERS.set(transport, meta$3);
		if (child) {
			PROCESS_BUFFERS.set(child, meta$3);
			if (STDIO_TRACE_ENABLED$1) {
				const pid = typeof child.pid === "number" ? child.pid : "unknown";
				console.log(`[mcporter] STDIO trace: spawned ${meta$3.command ?? "stdio server"} (pid=${pid}).`);
			}
		} else if (STDIO_TRACE_ENABLED$1) {
			console.log(`[mcporter] STDIO trace: transport for ${meta$3.command ?? "stdio server"} exited before spawn listeners attached.`);
		}
		const targetStream = transport._stderrStream ?? child?.stderr ?? null;
		if (targetStream) {
			if (typeof targetStream.setEncoding === "function") {
				targetStream.setEncoding?.("utf8");
			}
			const handleChunk = (chunk) => {
				if (typeof chunk === "string") {
					meta$3.stderrChunks.push(chunk);
				} else if (Buffer.isBuffer(chunk)) {
					meta$3.stderrChunks.push(chunk.toString("utf8"));
				}
			};
			const swallowError = () => {};
			targetStream.on("data", handleChunk);
			targetStream.on("error", swallowError);
			meta$3.listeners.push({
				stream: targetStream,
				event: "data",
				handler: handleChunk
			});
			meta$3.listeners.push({
				stream: targetStream,
				event: "error",
				handler: swallowError
			});
		}
		if (STDIO_TRACE_ENABLED$1 && child?.stdout) {
			const stdoutStream$1 = child.stdout;
			const handleStdout = (chunk) => {
				if (!meta$3.stdoutChunks) {
					meta$3.stdoutChunks = [];
				}
				if (typeof chunk === "string") {
					meta$3.stdoutChunks.push(chunk);
				} else if (Buffer.isBuffer(chunk)) {
					meta$3.stdoutChunks.push(chunk.toString("utf8"));
				}
			};
			const swallowStdoutError = () => {};
			stdoutStream$1.on("data", handleStdout);
			stdoutStream$1.on("error", swallowStdoutError);
			meta$3.listeners.push({
				stream: stdoutStream$1,
				event: "data",
				handler: handleStdout
			});
			meta$3.listeners.push({
				stream: stdoutStream$1,
				event: "error",
				handler: swallowStdoutError
			});
		}
		if (child) {
			child.once("exit", (code) => {
				const entry = PROCESS_BUFFERS.get(child);
				if (entry) {
					entry.code = code;
					flushProcessLogs(child, entry);
				}
			});
		}
		await startPromise;
	};
	proto[marker] = true;
}
patchStdioClose();
patchStdioSend();
function patchStdioSend() {
	if (!STDIO_TRACE_ENABLED$1) {
		return;
	}
	const marker = Symbol.for("mcporter.stdio.sendPatched");
	const proto = StdioClientTransport.prototype;
	if (proto[marker]) {
		return;
	}
	const originalSend = StdioClientTransport.prototype.send;
	StdioClientTransport.prototype.send = function patchedSend(message) {
		if (STDIO_TRACE_ENABLED$1) {
			try {
				const transport = this;
				const child = transport._process ?? null;
				if (child) {
					const meta$3 = PROCESS_BUFFERS.get(child);
					if (meta$3) {
						if (!meta$3.stdinChunks) {
							meta$3.stdinChunks = [];
						}
						meta$3.stdinChunks.push(JSON.stringify(message));
					}
				}
			} catch {}
		}
		return originalSend.call(this, message);
	};
	proto[marker] = true;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime/errors.js
const NON_FATAL_MCP_ERROR_CODES = new Set([
	ErrorCode.InvalidRequest,
	ErrorCode.MethodNotFound,
	ErrorCode.InvalidParams
]);
function shouldResetConnection(error$47) {
	if (!error$47) {
		return false;
	}
	if (error$47 instanceof McpError) {
		return !NON_FATAL_MCP_ERROR_CODES.has(error$47.code);
	}
	return error$47 instanceof Error;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime-oauth-support.js
function maybeEnableOAuth(definition, logger) {
	if (definition.auth === "oauth") {
		return undefined;
	}
	if (definition.command.kind !== "http") {
		return undefined;
	}
	const isAdHocSource = definition.source && definition.source.kind === "local" && definition.source.path === "<adhoc>";
	if (!isAdHocSource) {
		return undefined;
	}
	logger.info(`Detected OAuth requirement for '${definition.name}'. Launching browser flow...`);
	return {
		...definition,
		auth: "oauth"
	};
}
function isUnauthorizedError(error$47) {
	const issue$1 = analyzeConnectionError(error$47);
	return issue$1.kind === "auth";
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime/oauth.js
const DEFAULT_OAUTH_CODE_TIMEOUT_MS = 6e4;
var OAuthTimeoutError = class extends Error {
	timeoutMs;
	serverName;
	constructor(serverName, timeoutMs) {
		const seconds = Math.round(timeoutMs / 1e3);
		super(`OAuth authorization for '${serverName}' timed out after ${seconds}s; aborting.`);
		this.name = "OAuthTimeoutError";
		this.timeoutMs = timeoutMs;
		this.serverName = serverName;
	}
};
async function connectWithAuth(client, transport, session, logger, options = {}) {
	const { serverName, maxAttempts = 3, oauthTimeoutMs = DEFAULT_OAUTH_CODE_TIMEOUT_MS } = options;
	let attempt = 0;
	while (true) {
		try {
			await client.connect(transport);
			return;
		} catch (error$47) {
			if (!isUnauthorizedError(error$47) || !session) {
				throw error$47;
			}
			attempt += 1;
			if (attempt > maxAttempts) {
				throw error$47;
			}
			logger.warn(`OAuth authorization required for '${serverName ?? "unknown"}'. Waiting for browser approval...`);
			try {
				const code = await waitForAuthorizationCodeWithTimeout(session, logger, serverName, oauthTimeoutMs ?? DEFAULT_OAUTH_CODE_TIMEOUT_MS);
				if (typeof transport.finishAuth === "function") {
					await transport.finishAuth(code);
					logger.info("Authorization code accepted. Retrying connection...");
				} else {
					logger.warn("Transport does not support finishAuth; cannot complete OAuth flow automatically.");
					throw error$47;
				}
			} catch (authError) {
				logger.error("OAuth authorization failed while waiting for callback.", authError);
				throw authError;
			}
		}
	}
}
function waitForAuthorizationCodeWithTimeout(session, logger, serverName, timeoutMs = DEFAULT_OAUTH_CODE_TIMEOUT_MS) {
	if (!Number.isFinite(timeoutMs) || timeoutMs <= 0) {
		return session.waitForAuthorizationCode();
	}
	const displayName = serverName ?? "unknown";
	return new Promise((resolve, reject) => {
		const timer = setTimeout(() => {
			const error$47 = new OAuthTimeoutError(displayName, timeoutMs);
			logger.warn(error$47.message);
			reject(error$47);
		}, timeoutMs);
		session.waitForAuthorizationCode().then((code) => {
			clearTimeout(timer);
			resolve(code);
		}, (error$47) => {
			clearTimeout(timer);
			reject(error$47);
		});
	});
}
function parseOAuthTimeout(raw) {
	if (!raw) {
		return DEFAULT_OAUTH_CODE_TIMEOUT_MS;
	}
	const parsed = Number.parseInt(raw, 10);
	if (!Number.isFinite(parsed) || parsed <= 0) {
		return DEFAULT_OAUTH_CODE_TIMEOUT_MS;
	}
	return parsed;
}
function resolveOAuthTimeoutFromEnv() {
	return parseOAuthTimeout(process.env.MCPORTER_OAUTH_TIMEOUT_MS ?? process.env.MCPORTER_OAUTH_TIMEOUT);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/helpers/util.js
var util;
(function(util$1) {
	util$1.assertEqual = (_) => {};
	function assertIs$1(_arg) {}
	util$1.assertIs = assertIs$1;
	function assertNever$1(_x) {
		throw new Error();
	}
	util$1.assertNever = assertNever$1;
	util$1.arrayToEnum = (items) => {
		const obj = {};
		for (const item of items) {
			obj[item] = item;
		}
		return obj;
	};
	util$1.getValidEnumValues = (obj) => {
		const validKeys = util$1.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
		const filtered = {};
		for (const k of validKeys) {
			filtered[k] = obj[k];
		}
		return util$1.objectValues(filtered);
	};
	util$1.objectValues = (obj) => {
		return util$1.objectKeys(obj).map(function(e) {
			return obj[e];
		});
	};
	util$1.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object$2) => {
		const keys = [];
		for (const key in object$2) {
			if (Object.prototype.hasOwnProperty.call(object$2, key)) {
				keys.push(key);
			}
		}
		return keys;
	};
	util$1.find = (arr, checker) => {
		for (const item of arr) {
			if (checker(item)) return item;
		}
		return undefined;
	};
	util$1.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
	function joinValues$1(array$2, separator = " | ") {
		return array$2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
	}
	util$1.joinValues = joinValues$1;
	util$1.jsonStringifyReplacer = (_, value) => {
		if (typeof value === "bigint") {
			return value.toString();
		}
		return value;
	};
})(util || (util = {}));
var objectUtil;
(function(objectUtil$1) {
	objectUtil$1.mergeShapes = (first, second) => {
		return {
			...first,
			...second
		};
	};
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
	"string",
	"nan",
	"number",
	"integer",
	"float",
	"boolean",
	"date",
	"bigint",
	"symbol",
	"function",
	"undefined",
	"null",
	"array",
	"object",
	"unknown",
	"promise",
	"void",
	"never",
	"map",
	"set"
]);
const getParsedType = (data) => {
	const t = typeof data;
	switch (t) {
		case "undefined": return ZodParsedType.undefined;
		case "string": return ZodParsedType.string;
		case "number": return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
		case "boolean": return ZodParsedType.boolean;
		case "function": return ZodParsedType.function;
		case "bigint": return ZodParsedType.bigint;
		case "symbol": return ZodParsedType.symbol;
		case "object":
			if (Array.isArray(data)) {
				return ZodParsedType.array;
			}
			if (data === null) {
				return ZodParsedType.null;
			}
			if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
				return ZodParsedType.promise;
			}
			if (typeof Map !== "undefined" && data instanceof Map) {
				return ZodParsedType.map;
			}
			if (typeof Set !== "undefined" && data instanceof Set) {
				return ZodParsedType.set;
			}
			if (typeof Date !== "undefined" && data instanceof Date) {
				return ZodParsedType.date;
			}
			return ZodParsedType.object;
		default: return ZodParsedType.unknown;
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/ZodError.js
const ZodIssueCode = util.arrayToEnum([
	"invalid_type",
	"invalid_literal",
	"custom",
	"invalid_union",
	"invalid_union_discriminator",
	"invalid_enum_value",
	"unrecognized_keys",
	"invalid_arguments",
	"invalid_return_type",
	"invalid_date",
	"invalid_string",
	"too_small",
	"too_big",
	"invalid_intersection_types",
	"not_multiple_of",
	"not_finite"
]);
const quotelessJson = (obj) => {
	const json$2 = JSON.stringify(obj, null, 2);
	return json$2.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class ZodError extends Error {
	get errors() {
		return this.issues;
	}
	constructor(issues) {
		super();
		this.issues = [];
		this.addIssue = (sub) => {
			this.issues = [...this.issues, sub];
		};
		this.addIssues = (subs = []) => {
			this.issues = [...this.issues, ...subs];
		};
		const actualProto = new.target.prototype;
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(this, actualProto);
		} else {
			this.__proto__ = actualProto;
		}
		this.name = "ZodError";
		this.issues = issues;
	}
	format(_mapper) {
		const mapper = _mapper || function(issue$1) {
			return issue$1.message;
		};
		const fieldErrors = { _errors: [] };
		const processError = (error$47) => {
			for (const issue$1 of error$47.issues) {
				if (issue$1.code === "invalid_union") {
					issue$1.unionErrors.map(processError);
				} else if (issue$1.code === "invalid_return_type") {
					processError(issue$1.returnTypeError);
				} else if (issue$1.code === "invalid_arguments") {
					processError(issue$1.argumentsError);
				} else if (issue$1.path.length === 0) {
					fieldErrors._errors.push(mapper(issue$1));
				} else {
					let curr = fieldErrors;
					let i = 0;
					while (i < issue$1.path.length) {
						const el = issue$1.path[i];
						const terminal = i === issue$1.path.length - 1;
						if (!terminal) {
							curr[el] = curr[el] || { _errors: [] };
						} else {
							curr[el] = curr[el] || { _errors: [] };
							curr[el]._errors.push(mapper(issue$1));
						}
						curr = curr[el];
						i++;
					}
				}
			}
		};
		processError(this);
		return fieldErrors;
	}
	static assert(value) {
		if (!(value instanceof ZodError)) {
			throw new Error(`Not a ZodError: ${value}`);
		}
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue$1) => issue$1.message) {
		const fieldErrors = Object.create(null);
		const formErrors = [];
		for (const sub of this.issues) {
			if (sub.path.length > 0) {
				const firstEl = sub.path[0];
				fieldErrors[firstEl] = fieldErrors[firstEl] || [];
				fieldErrors[firstEl].push(mapper(sub));
			} else {
				formErrors.push(mapper(sub));
			}
		}
		return {
			formErrors,
			fieldErrors
		};
	}
	get formErrors() {
		return this.flatten();
	}
};
ZodError.create = (issues) => {
	const error$47 = new ZodError(issues);
	return error$47;
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/locales/en.js
const errorMap = (issue$1, _ctx) => {
	let message;
	switch (issue$1.code) {
		case ZodIssueCode.invalid_type:
			if (issue$1.received === ZodParsedType.undefined) {
				message = "Required";
			} else {
				message = `Expected ${issue$1.expected}, received ${issue$1.received}`;
			}
			break;
		case ZodIssueCode.invalid_literal:
			message = `Invalid literal value, expected ${JSON.stringify(issue$1.expected, util.jsonStringifyReplacer)}`;
			break;
		case ZodIssueCode.unrecognized_keys:
			message = `Unrecognized key(s) in object: ${util.joinValues(issue$1.keys, ", ")}`;
			break;
		case ZodIssueCode.invalid_union:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_union_discriminator:
			message = `Invalid discriminator value. Expected ${util.joinValues(issue$1.options)}`;
			break;
		case ZodIssueCode.invalid_enum_value:
			message = `Invalid enum value. Expected ${util.joinValues(issue$1.options)}, received '${issue$1.received}'`;
			break;
		case ZodIssueCode.invalid_arguments:
			message = `Invalid function arguments`;
			break;
		case ZodIssueCode.invalid_return_type:
			message = `Invalid function return type`;
			break;
		case ZodIssueCode.invalid_date:
			message = `Invalid date`;
			break;
		case ZodIssueCode.invalid_string:
			if (typeof issue$1.validation === "object") {
				if ("includes" in issue$1.validation) {
					message = `Invalid input: must include "${issue$1.validation.includes}"`;
					if (typeof issue$1.validation.position === "number") {
						message = `${message} at one or more positions greater than or equal to ${issue$1.validation.position}`;
					}
				} else if ("startsWith" in issue$1.validation) {
					message = `Invalid input: must start with "${issue$1.validation.startsWith}"`;
				} else if ("endsWith" in issue$1.validation) {
					message = `Invalid input: must end with "${issue$1.validation.endsWith}"`;
				} else {
					util.assertNever(issue$1.validation);
				}
			} else if (issue$1.validation !== "regex") {
				message = `Invalid ${issue$1.validation}`;
			} else {
				message = "Invalid";
			}
			break;
		case ZodIssueCode.too_small:
			if (issue$1.type === "array") message = `Array must contain ${issue$1.exact ? "exactly" : issue$1.inclusive ? `at least` : `more than`} ${issue$1.minimum} element(s)`;
			else if (issue$1.type === "string") message = `String must contain ${issue$1.exact ? "exactly" : issue$1.inclusive ? `at least` : `over`} ${issue$1.minimum} character(s)`;
			else if (issue$1.type === "number") message = `Number must be ${issue$1.exact ? `exactly equal to ` : issue$1.inclusive ? `greater than or equal to ` : `greater than `}${issue$1.minimum}`;
			else if (issue$1.type === "bigint") message = `Number must be ${issue$1.exact ? `exactly equal to ` : issue$1.inclusive ? `greater than or equal to ` : `greater than `}${issue$1.minimum}`;
			else if (issue$1.type === "date") message = `Date must be ${issue$1.exact ? `exactly equal to ` : issue$1.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue$1.minimum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.too_big:
			if (issue$1.type === "array") message = `Array must contain ${issue$1.exact ? `exactly` : issue$1.inclusive ? `at most` : `less than`} ${issue$1.maximum} element(s)`;
			else if (issue$1.type === "string") message = `String must contain ${issue$1.exact ? `exactly` : issue$1.inclusive ? `at most` : `under`} ${issue$1.maximum} character(s)`;
			else if (issue$1.type === "number") message = `Number must be ${issue$1.exact ? `exactly` : issue$1.inclusive ? `less than or equal to` : `less than`} ${issue$1.maximum}`;
			else if (issue$1.type === "bigint") message = `BigInt must be ${issue$1.exact ? `exactly` : issue$1.inclusive ? `less than or equal to` : `less than`} ${issue$1.maximum}`;
			else if (issue$1.type === "date") message = `Date must be ${issue$1.exact ? `exactly` : issue$1.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue$1.maximum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.custom:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_intersection_types:
			message = `Intersection results could not be merged`;
			break;
		case ZodIssueCode.not_multiple_of:
			message = `Number must be a multiple of ${issue$1.multipleOf}`;
			break;
		case ZodIssueCode.not_finite:
			message = "Number must be finite";
			break;
		default:
			message = _ctx.defaultError;
			util.assertNever(issue$1);
	}
	return { message };
};
var en_default = errorMap;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/errors.js
let overrideErrorMap = en_default;
function setErrorMap(map$2) {
	overrideErrorMap = map$2;
}
function getErrorMap() {
	return overrideErrorMap;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/helpers/parseUtil.js
const makeIssue = (params) => {
	const { data, path: path$12, errorMaps, issueData } = params;
	const fullPath = [...path$12, ...issueData.path || []];
	const fullIssue = {
		...issueData,
		path: fullPath
	};
	if (issueData.message !== undefined) {
		return {
			...issueData,
			path: fullPath,
			message: issueData.message
		};
	}
	let errorMessage = "";
	const maps = errorMaps.filter((m) => !!m).slice().reverse();
	for (const map$2 of maps) {
		errorMessage = map$2(fullIssue, {
			data,
			defaultError: errorMessage
		}).message;
	}
	return {
		...issueData,
		path: fullPath,
		message: errorMessage
	};
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
	const overrideMap = getErrorMap();
	const issue$1 = makeIssue({
		issueData,
		data: ctx.data,
		path: ctx.path,
		errorMaps: [
			ctx.common.contextualErrorMap,
			ctx.schemaErrorMap,
			overrideMap,
			overrideMap === en_default ? undefined : en_default
		].filter((x) => !!x)
	});
	ctx.common.issues.push(issue$1);
}
var ParseStatus = class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status, results) {
		const arrayValue = [];
		for (const s of results) {
			if (s.status === "aborted") return INVALID;
			if (s.status === "dirty") status.dirty();
			arrayValue.push(s.value);
		}
		return {
			status: status.value,
			value: arrayValue
		};
	}
	static async mergeObjectAsync(status, pairs) {
		const syncPairs = [];
		for (const pair of pairs) {
			const key = await pair.key;
			const value = await pair.value;
			syncPairs.push({
				key,
				value
			});
		}
		return ParseStatus.mergeObjectSync(status, syncPairs);
	}
	static mergeObjectSync(status, pairs) {
		const finalObject = {};
		for (const pair of pairs) {
			const { key, value } = pair;
			if (key.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key.status === "dirty") status.dirty();
			if (value.status === "dirty") status.dirty();
			if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
				finalObject[key.value] = value.value;
			}
		}
		return {
			status: status.value,
			value: finalObject
		};
	}
};
const INVALID = Object.freeze({ status: "aborted" });
const DIRTY = (value) => ({
	status: "dirty",
	value
});
const OK = (value) => ({
	status: "valid",
	value
});
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil$1) {
	errorUtil$1.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	errorUtil$1.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
	constructor(parent, value, path$12, key) {
		this._cachedPath = [];
		this.parent = parent;
		this.data = value;
		this._path = path$12;
		this._key = key;
	}
	get path() {
		if (!this._cachedPath.length) {
			if (Array.isArray(this._key)) {
				this._cachedPath.push(...this._path, ...this._key);
			} else {
				this._cachedPath.push(...this._path, this._key);
			}
		}
		return this._cachedPath;
	}
};
const handleResult = (ctx, result) => {
	if (isValid(result)) {
		return {
			success: true,
			data: result.value
		};
	} else {
		if (!ctx.common.issues.length) {
			throw new Error("Validation failed but no issues detected.");
		}
		return {
			success: false,
			get error() {
				if (this._error) return this._error;
				const error$47 = new ZodError(ctx.common.issues);
				this._error = error$47;
				return this._error;
			}
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	const { errorMap: errorMap$1, invalid_type_error, required_error, description } = params;
	if (errorMap$1 && (invalid_type_error || required_error)) {
		throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	}
	if (errorMap$1) return {
		errorMap: errorMap$1,
		description
	};
	const customMap = (iss, ctx) => {
		const { message } = params;
		if (iss.code === "invalid_enum_value") {
			return { message: message ?? ctx.defaultError };
		}
		if (typeof ctx.data === "undefined") {
			return { message: message ?? required_error ?? ctx.defaultError };
		}
		if (iss.code !== "invalid_type") return { message: ctx.defaultError };
		return { message: message ?? invalid_type_error ?? ctx.defaultError };
	};
	return {
		errorMap: customMap,
		description
	};
}
var ZodType = class {
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return ctx || {
			common: input.parent.common,
			data: input.data,
			parsedType: getParsedType(input.data),
			schemaErrorMap: this._def.errorMap,
			path: input.path,
			parent: input.parent
		};
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent
			}
		};
	}
	_parseSync(input) {
		const result = this._parse(input);
		if (isAsync(result)) {
			throw new Error("Synchronous parse encountered promise.");
		}
		return result;
	}
	_parseAsync(input) {
		const result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data, params) {
		const result = this.safeParse(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data, params) {
		const ctx = {
			common: {
				issues: [],
				async: params?.async ?? false,
				contextualErrorMap: params?.errorMap
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		const result = this._parseSync({
			data,
			path: ctx.path,
			parent: ctx
		});
		return handleResult(ctx, result);
	}
	"~validate"(data) {
		const ctx = {
			common: {
				issues: [],
				async: !!this["~standard"].async
			},
			path: [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		if (!this["~standard"].async) {
			try {
				const result = this._parseSync({
					data,
					path: [],
					parent: ctx
				});
				return isValid(result) ? { value: result.value } : { issues: ctx.common.issues };
			} catch (err) {
				if (err?.message?.toLowerCase()?.includes("encountered")) {
					this["~standard"].async = true;
				}
				ctx.common = {
					issues: [],
					async: true
				};
			}
		}
		return this._parseAsync({
			data,
			path: [],
			parent: ctx
		}).then((result) => isValid(result) ? { value: result.value } : { issues: ctx.common.issues });
	}
	async parseAsync(data, params) {
		const result = await this.safeParseAsync(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data, params) {
		const ctx = {
			common: {
				issues: [],
				contextualErrorMap: params?.errorMap,
				async: true
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		const maybeAsyncResult = this._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
		const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
		return handleResult(ctx, result);
	}
	refine(check$2, message) {
		const getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined") {
				return { message };
			} else if (typeof message === "function") {
				return message(val);
			} else {
				return message;
			}
		};
		return this._refinement((val, ctx) => {
			const result = check$2(val);
			const setError = () => ctx.addIssue({
				code: ZodIssueCode.custom,
				...getIssueProperties(val)
			});
			if (typeof Promise !== "undefined" && result instanceof Promise) {
				return result.then((data) => {
					if (!data) {
						setError();
						return false;
					} else {
						return true;
					}
				});
			}
			if (!result) {
				setError();
				return false;
			} else {
				return true;
			}
		});
	}
	refinement(check$2, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check$2(val)) {
				ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
				return false;
			} else {
				return true;
			}
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "refinement",
				refinement
			}
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	constructor(def) {
		/** Alias of safeParseAsync */
		this.spa = this.safeParseAsync;
		this._def = def;
		this.parse = this.parse.bind(this);
		this.safeParse = this.safeParse.bind(this);
		this.parseAsync = this.parseAsync.bind(this);
		this.safeParseAsync = this.safeParseAsync.bind(this);
		this.spa = this.spa.bind(this);
		this.refine = this.refine.bind(this);
		this.refinement = this.refinement.bind(this);
		this.superRefine = this.superRefine.bind(this);
		this.optional = this.optional.bind(this);
		this.nullable = this.nullable.bind(this);
		this.nullish = this.nullish.bind(this);
		this.array = this.array.bind(this);
		this.promise = this.promise.bind(this);
		this.or = this.or.bind(this);
		this.and = this.and.bind(this);
		this.transform = this.transform.bind(this);
		this.brand = this.brand.bind(this);
		this.default = this.default.bind(this);
		this.catch = this.catch.bind(this);
		this.describe = this.describe.bind(this);
		this.pipe = this.pipe.bind(this);
		this.readonly = this.readonly.bind(this);
		this.isNullable = this.isNullable.bind(this);
		this.isOptional = this.isOptional.bind(this);
		this["~standard"] = {
			version: 1,
			vendor: "zod",
			validate: (data) => this["~validate"](data)
		};
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform$2) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "transform",
				transform: transform$2
			}
		});
	}
	default(def) {
		const defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def)
		});
	}
	catch(def) {
		const catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch
		});
	}
	describe(description) {
		const This = this.constructor;
		return new This({
			...this._def,
			description
		});
	}
	pipe(target) {
		return ZodPipeline.create(this, target);
	}
	readonly() {
		return ZodReadonly.create(this);
	}
	isOptional() {
		return this.safeParse(undefined).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
};
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$1;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
	let secondsRegexSource = `[0-5]\\d`;
	if (args.precision) {
		secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
	} else if (args.precision == null) {
		secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
	}
	const secondsQuantifier = args.precision ? "+" : "?";
	return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
	return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
	let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
	const opts = [];
	opts.push(args.local ? `Z?` : `Z`);
	if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
	regex = `${regex}(${opts.join("|")})`;
	return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version$1) {
	if ((version$1 === "v4" || !version$1) && ipv4Regex.test(ip)) {
		return true;
	}
	if ((version$1 === "v6" || !version$1) && ipv6Regex.test(ip)) {
		return true;
	}
	return false;
}
function isValidJWT(jwt$2, alg) {
	if (!jwtRegex.test(jwt$2)) return false;
	try {
		const [header] = jwt$2.split(".");
		if (!header) return false;
		const base64$3 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
		const decoded = JSON.parse(atob(base64$3));
		if (typeof decoded !== "object" || decoded === null) return false;
		if ("typ" in decoded && decoded?.typ !== "JWT") return false;
		if (!decoded.alg) return false;
		if (alg && decoded.alg !== alg) return false;
		return true;
	} catch {
		return false;
	}
}
function isValidCidr(ip, version$1) {
	if ((version$1 === "v4" || !version$1) && ipv4CidrRegex.test(ip)) {
		return true;
	}
	if ((version$1 === "v6" || !version$1) && ipv6CidrRegex.test(ip)) {
		return true;
	}
	return false;
}
var ZodString = class ZodString extends ZodType {
	_parse(input) {
		if (this._def.coerce) {
			input.data = String(input.data);
		}
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.string) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.string,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = undefined;
		for (const check$2 of this._def.checks) {
			if (check$2.kind === "min") {
				if (input.data.length < check$2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						minimum: check$2.value,
						type: "string",
						inclusive: true,
						exact: false,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "max") {
				if (input.data.length > check$2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						maximum: check$2.value,
						type: "string",
						inclusive: true,
						exact: false,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "length") {
				const tooBig = input.data.length > check$2.value;
				const tooSmall = input.data.length < check$2.value;
				if (tooBig || tooSmall) {
					ctx = this._getOrReturnCtx(input, ctx);
					if (tooBig) {
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_big,
							maximum: check$2.value,
							type: "string",
							inclusive: true,
							exact: true,
							message: check$2.message
						});
					} else if (tooSmall) {
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_small,
							minimum: check$2.value,
							type: "string",
							inclusive: true,
							exact: true,
							message: check$2.message
						});
					}
					status.dirty();
				}
			} else if (check$2.kind === "email") {
				if (!emailRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "email",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "emoji") {
				if (!emojiRegex$1) {
					emojiRegex$1 = new RegExp(_emojiRegex, "u");
				}
				if (!emojiRegex$1.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "emoji",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "uuid") {
				if (!uuidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "uuid",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "nanoid") {
				if (!nanoidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "nanoid",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "cuid") {
				if (!cuidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "cuid",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "cuid2") {
				if (!cuid2Regex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "cuid2",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "ulid") {
				if (!ulidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "ulid",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "url") {
				try {
					new URL(input.data);
				} catch {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "url",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "regex") {
				check$2.regex.lastIndex = 0;
				const testResult = check$2.regex.test(input.data);
				if (!testResult) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "regex",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "trim") {
				input.data = input.data.trim();
			} else if (check$2.kind === "includes") {
				if (!input.data.includes(check$2.value, check$2.position)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: {
							includes: check$2.value,
							position: check$2.position
						},
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "toLowerCase") {
				input.data = input.data.toLowerCase();
			} else if (check$2.kind === "toUpperCase") {
				input.data = input.data.toUpperCase();
			} else if (check$2.kind === "startsWith") {
				if (!input.data.startsWith(check$2.value)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: { startsWith: check$2.value },
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "endsWith") {
				if (!input.data.endsWith(check$2.value)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: { endsWith: check$2.value },
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "datetime") {
				const regex = datetimeRegex(check$2);
				if (!regex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: "datetime",
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "date") {
				const regex = dateRegex;
				if (!regex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: "date",
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "time") {
				const regex = timeRegex(check$2);
				if (!regex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: "time",
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "duration") {
				if (!durationRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "duration",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "ip") {
				if (!isValidIP(input.data, check$2.version)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "ip",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "jwt") {
				if (!isValidJWT(input.data, check$2.alg)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "jwt",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "cidr") {
				if (!isValidCidr(input.data, check$2.version)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "cidr",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "base64") {
				if (!base64Regex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "base64",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "base64url") {
				if (!base64urlRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "base64url",
						code: ZodIssueCode.invalid_string,
						message: check$2.message
					});
					status.dirty();
				}
			} else {
				util.assertNever(check$2);
			}
		}
		return {
			status: status.value,
			value: input.data
		};
	}
	_regex(regex, validation, message) {
		return this.refinement((data) => regex.test(data), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message)
		});
	}
	_addCheck(check$2) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check$2]
		});
	}
	email(message) {
		return this._addCheck({
			kind: "email",
			...errorUtil.errToObj(message)
		});
	}
	url(message) {
		return this._addCheck({
			kind: "url",
			...errorUtil.errToObj(message)
		});
	}
	emoji(message) {
		return this._addCheck({
			kind: "emoji",
			...errorUtil.errToObj(message)
		});
	}
	uuid(message) {
		return this._addCheck({
			kind: "uuid",
			...errorUtil.errToObj(message)
		});
	}
	nanoid(message) {
		return this._addCheck({
			kind: "nanoid",
			...errorUtil.errToObj(message)
		});
	}
	cuid(message) {
		return this._addCheck({
			kind: "cuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid2(message) {
		return this._addCheck({
			kind: "cuid2",
			...errorUtil.errToObj(message)
		});
	}
	ulid(message) {
		return this._addCheck({
			kind: "ulid",
			...errorUtil.errToObj(message)
		});
	}
	base64(message) {
		return this._addCheck({
			kind: "base64",
			...errorUtil.errToObj(message)
		});
	}
	base64url(message) {
		return this._addCheck({
			kind: "base64url",
			...errorUtil.errToObj(message)
		});
	}
	jwt(options) {
		return this._addCheck({
			kind: "jwt",
			...errorUtil.errToObj(options)
		});
	}
	ip(options) {
		return this._addCheck({
			kind: "ip",
			...errorUtil.errToObj(options)
		});
	}
	cidr(options) {
		return this._addCheck({
			kind: "cidr",
			...errorUtil.errToObj(options)
		});
	}
	datetime(options) {
		if (typeof options === "string") {
			return this._addCheck({
				kind: "datetime",
				precision: null,
				offset: false,
				local: false,
				message: options
			});
		}
		return this._addCheck({
			kind: "datetime",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			offset: options?.offset ?? false,
			local: options?.local ?? false,
			...errorUtil.errToObj(options?.message)
		});
	}
	date(message) {
		return this._addCheck({
			kind: "date",
			message
		});
	}
	time(options) {
		if (typeof options === "string") {
			return this._addCheck({
				kind: "time",
				precision: null,
				message: options
			});
		}
		return this._addCheck({
			kind: "time",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			...errorUtil.errToObj(options?.message)
		});
	}
	duration(message) {
		return this._addCheck({
			kind: "duration",
			...errorUtil.errToObj(message)
		});
	}
	regex(regex, message) {
		return this._addCheck({
			kind: "regex",
			regex,
			...errorUtil.errToObj(message)
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position: options?.position,
			...errorUtil.errToObj(options?.message)
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	min(minLength, message) {
		return this._addCheck({
			kind: "min",
			value: minLength,
			...errorUtil.errToObj(message)
		});
	}
	max(maxLength, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength,
			...errorUtil.errToObj(message)
		});
	}
	length(len, message) {
		return this._addCheck({
			kind: "length",
			value: len,
			...errorUtil.errToObj(message)
		});
	}
	/**
	* Equivalent to `.min(1)`
	*/
	nonempty(message) {
		return this.min(1, errorUtil.errToObj(message));
	}
	trim() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }]
		});
	}
	toLowerCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }]
		});
	}
	toUpperCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }]
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isDate() {
		return !!this._def.checks.find((ch) => ch.kind === "date");
	}
	get isTime() {
		return !!this._def.checks.find((ch) => ch.kind === "time");
	}
	get isDuration() {
		return !!this._def.checks.find((ch) => ch.kind === "duration");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isNANOID() {
		return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get isCIDR() {
		return !!this._def.checks.find((ch) => ch.kind === "cidr");
	}
	get isBase64() {
		return !!this._def.checks.find((ch) => ch.kind === "base64");
	}
	get isBase64url() {
		return !!this._def.checks.find((ch) => ch.kind === "base64url");
	}
	get minLength() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min;
	}
	get maxLength() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max;
	}
};
ZodString.create = (params) => {
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
	const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
	return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
		this.step = this.multipleOf;
	}
	_parse(input) {
		if (this._def.coerce) {
			input.data = Number(input.data);
		}
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.number) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.number,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = undefined;
		const status = new ParseStatus();
		for (const check$2 of this._def.checks) {
			if (check$2.kind === "int") {
				if (!util.isInteger(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_type,
						expected: "integer",
						received: "float",
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "min") {
				const tooSmall = check$2.inclusive ? input.data < check$2.value : input.data <= check$2.value;
				if (tooSmall) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						minimum: check$2.value,
						type: "number",
						inclusive: check$2.inclusive,
						exact: false,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "max") {
				const tooBig = check$2.inclusive ? input.data > check$2.value : input.data >= check$2.value;
				if (tooBig) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						maximum: check$2.value,
						type: "number",
						inclusive: check$2.inclusive,
						exact: false,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "multipleOf") {
				if (floatSafeRemainder(input.data, check$2.value) !== 0) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.not_multiple_of,
						multipleOf: check$2.value,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "finite") {
				if (!Number.isFinite(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.not_finite,
						message: check$2.message
					});
					status.dirty();
				}
			} else {
				util.assertNever(check$2);
			}
		}
		return {
			status: status.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check$2) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check$2]
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message)
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message)
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: true,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message)
		})._addCheck({
			kind: "max",
			inclusive: true,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max;
	}
	get isInt() {
		return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
	}
	get isFinite() {
		let max = null;
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
				return true;
			} else if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			} else if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return Number.isFinite(min) && Number.isFinite(max);
	}
};
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodBigInt = class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
	}
	_parse(input) {
		if (this._def.coerce) {
			try {
				input.data = BigInt(input.data);
			} catch {
				return this._getInvalidInput(input);
			}
		}
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.bigint) {
			return this._getInvalidInput(input);
		}
		let ctx = undefined;
		const status = new ParseStatus();
		for (const check$2 of this._def.checks) {
			if (check$2.kind === "min") {
				const tooSmall = check$2.inclusive ? input.data < check$2.value : input.data <= check$2.value;
				if (tooSmall) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						type: "bigint",
						minimum: check$2.value,
						inclusive: check$2.inclusive,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "max") {
				const tooBig = check$2.inclusive ? input.data > check$2.value : input.data >= check$2.value;
				if (tooBig) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						type: "bigint",
						maximum: check$2.value,
						inclusive: check$2.inclusive,
						message: check$2.message
					});
					status.dirty();
				}
			} else if (check$2.kind === "multipleOf") {
				if (input.data % check$2.value !== BigInt(0)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.not_multiple_of,
						multipleOf: check$2.value,
						message: check$2.message
					});
					status.dirty();
				}
			} else {
				util.assertNever(check$2);
			}
		}
		return {
			status: status.value,
			value: input.data
		};
	}
	_getInvalidInput(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.bigint,
			received: ctx.parsedType
		});
		return INVALID;
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check$2) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check$2]
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max;
	}
};
ZodBigInt.create = (params) => {
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
var ZodBoolean = class extends ZodType {
	_parse(input) {
		if (this._def.coerce) {
			input.data = Boolean(input.data);
		}
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.boolean) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.boolean,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodDate = class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) {
			input.data = new Date(input.data);
		}
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.date) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.date,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		if (Number.isNaN(input.data.getTime())) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, { code: ZodIssueCode.invalid_date });
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = undefined;
		for (const check$2 of this._def.checks) {
			if (check$2.kind === "min") {
				if (input.data.getTime() < check$2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						message: check$2.message,
						inclusive: true,
						exact: false,
						minimum: check$2.value,
						type: "date"
					});
					status.dirty();
				}
			} else if (check$2.kind === "max") {
				if (input.data.getTime() > check$2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						message: check$2.message,
						inclusive: true,
						exact: false,
						maximum: check$2.value,
						type: "date"
					});
					status.dirty();
				}
			} else {
				util.assertNever(check$2);
			}
		}
		return {
			status: status.value,
			value: new Date(input.data.getTime())
		};
	}
	_addCheck(check$2) {
		return new ZodDate({
			...this._def,
			checks: [...this._def.checks, check$2]
		});
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	get minDate() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min != null ? new Date(min) : null;
	}
	get maxDate() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max != null ? new Date(max) : null;
	}
};
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce: params?.coerce || false,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params)
	});
};
var ZodSymbol = class extends ZodType {
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.symbol) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.symbol,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params)
	});
};
var ZodUndefined = class extends ZodType {
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.undefined,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params)
	});
};
var ZodNull = class extends ZodType {
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.null) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.null,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params)
	});
};
var ZodAny = class extends ZodType {
	constructor() {
		super(...arguments);
		this._any = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params)
	});
};
var ZodUnknown = class extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params)
	});
};
var ZodNever = class extends ZodType {
	_parse(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.never,
			received: ctx.parsedType
		});
		return INVALID;
	}
};
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params)
	});
};
var ZodVoid = class extends ZodType {
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.void,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params)
	});
};
var ZodArray = class ZodArray extends ZodType {
	_parse(input) {
		const { ctx, status } = this._processInputParams(input);
		const def = this._def;
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (def.exactLength !== null) {
			const tooBig = ctx.data.length > def.exactLength.value;
			const tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall) {
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : undefined,
					maximum: tooBig ? def.exactLength.value : undefined,
					type: "array",
					inclusive: true,
					exact: true,
					message: def.exactLength.message
				});
				status.dirty();
			}
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.minLength.message
				});
				status.dirty();
			}
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.maxLength.message
				});
				status.dirty();
			}
		}
		if (ctx.common.async) {
			return Promise.all([...ctx.data].map((item, i) => {
				return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
			})).then((result$1) => {
				return ParseStatus.mergeArray(status, result$1);
			});
		}
		const result = [...ctx.data].map((item, i) => {
			return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
		});
		return ParseStatus.mergeArray(status, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength, message) {
		return new ZodArray({
			...this._def,
			minLength: {
				value: minLength,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxLength, message) {
		return new ZodArray({
			...this._def,
			maxLength: {
				value: maxLength,
				message: errorUtil.toString(message)
			}
		});
	}
	length(len, message) {
		return new ZodArray({
			...this._def,
			exactLength: {
				value: len,
				message: errorUtil.toString(message)
			}
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params)
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		const newShape = {};
		for (const key in schema.shape) {
			const fieldSchema = schema.shape[key];
			newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({
			...schema._def,
			shape: () => newShape
		});
	} else if (schema instanceof ZodArray) {
		return new ZodArray({
			...schema._def,
			type: deepPartialify(schema.element)
		});
	} else if (schema instanceof ZodOptional) {
		return ZodOptional.create(deepPartialify(schema.unwrap()));
	} else if (schema instanceof ZodNullable) {
		return ZodNullable.create(deepPartialify(schema.unwrap()));
	} else if (schema instanceof ZodTuple) {
		return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	} else {
		return schema;
	}
}
var ZodObject = class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		this._cached = null;
		/**
		* @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
		* If you want to pass through unknown properties, use `.passthrough()` instead.
		*/
		this.nonstrict = this.passthrough;
		/**
		* @deprecated Use `.extend` instead
		*  */
		this.augment = this.extend;
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		const shape = this._def.shape();
		const keys = util.objectKeys(shape);
		this._cached = {
			shape,
			keys
		};
		return this._cached;
	}
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.object) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const { status, ctx } = this._processInputParams(input);
		const { shape, keys: shapeKeys } = this._getCached();
		const extraKeys = [];
		if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
			for (const key in ctx.data) {
				if (!shapeKeys.includes(key)) {
					extraKeys.push(key);
				}
			}
		}
		const pairs = [];
		for (const key of shapeKeys) {
			const keyValidator = shape[key];
			const value = ctx.data[key];
			pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
				alwaysSet: key in ctx.data
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			const unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough") {
				for (const key of extraKeys) {
					pairs.push({
						key: {
							status: "valid",
							value: key
						},
						value: {
							status: "valid",
							value: ctx.data[key]
						}
					});
				}
			} else if (unknownKeys === "strict") {
				if (extraKeys.length > 0) {
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys
					});
					status.dirty();
				}
			} else if (unknownKeys === "strip") {} else {
				throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
			}
		} else {
			const catchall$1 = this._def.catchall;
			for (const key of extraKeys) {
				const value = ctx.data[key];
				pairs.push({
					key: {
						status: "valid",
						value: key
					},
					value: catchall$1._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
					alwaysSet: key in ctx.data
				});
			}
		}
		if (ctx.common.async) {
			return Promise.resolve().then(async () => {
				const syncPairs = [];
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					syncPairs.push({
						key,
						value,
						alwaysSet: pair.alwaysSet
					});
				}
				return syncPairs;
			}).then((syncPairs) => {
				return ParseStatus.mergeObjectSync(status, syncPairs);
			});
		} else {
			return ParseStatus.mergeObjectSync(status, pairs);
		}
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		errorUtil.errToObj;
		return new ZodObject({
			...this._def,
			unknownKeys: "strict",
			...message !== undefined ? { errorMap: (issue$1, ctx) => {
				const defaultError = this._def.errorMap?.(issue$1, ctx).message ?? ctx.defaultError;
				if (issue$1.code === "unrecognized_keys") return { message: errorUtil.errToObj(message).message ?? defaultError };
				return { message: defaultError };
			} } : {}
		});
	}
	strip() {
		return new ZodObject({
			...this._def,
			unknownKeys: "strip"
		});
	}
	passthrough() {
		return new ZodObject({
			...this._def,
			unknownKeys: "passthrough"
		});
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({
				...this._def.shape(),
				...augmentation
			})
		});
	}
	/**
	* Prior to zod@1.0.12 there was a bug in the
	* inferred type of merged objects. Please
	* upgrade if you are experiencing issues.
	*/
	merge(merging) {
		const merged = new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({
				...this._def.shape(),
				...merging._def.shape()
			}),
			typeName: ZodFirstPartyTypeKind.ZodObject
		});
		return merged;
	}
	setKey(key, schema) {
		return this.augment({ [key]: schema });
	}
	catchall(index) {
		return new ZodObject({
			...this._def,
			catchall: index
		});
	}
	pick(mask) {
		const shape = {};
		for (const key of util.objectKeys(mask)) {
			if (mask[key] && this.shape[key]) {
				shape[key] = this.shape[key];
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	omit(mask) {
		const shape = {};
		for (const key of util.objectKeys(this.shape)) {
			if (!mask[key]) {
				shape[key] = this.shape[key];
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	/**
	* @deprecated
	*/
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) {
			const fieldSchema = this.shape[key];
			if (mask && !mask[key]) {
				newShape[key] = fieldSchema;
			} else {
				newShape[key] = fieldSchema.optional();
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	required(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) {
			if (mask && !mask[key]) {
				newShape[key] = this.shape[key];
			} else {
				const fieldSchema = this.shape[key];
				let newField = fieldSchema;
				while (newField instanceof ZodOptional) {
					newField = newField._def.innerType;
				}
				newShape[key] = newField;
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	keyof() {
		return createZodEnum(util.objectKeys(this.shape));
	}
};
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
var ZodUnion = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const options = this._def.options;
		function handleResults(results) {
			for (const result of results) {
				if (result.result.status === "valid") {
					return result.result;
				}
			}
			for (const result of results) {
				if (result.result.status === "dirty") {
					ctx.common.issues.push(...result.ctx.common.issues);
					return result.result;
				}
			}
			const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
		if (ctx.common.async) {
			return Promise.all(options.map(async (option) => {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: []
					},
					parent: null
				};
				return {
					result: await option._parseAsync({
						data: ctx.data,
						path: ctx.path,
						parent: childCtx
					}),
					ctx: childCtx
				};
			})).then(handleResults);
		} else {
			let dirty = undefined;
			const issues = [];
			for (const option of options) {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: []
					},
					parent: null
				};
				const result = option._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				});
				if (result.status === "valid") {
					return result;
				} else if (result.status === "dirty" && !dirty) {
					dirty = {
						result,
						ctx: childCtx
					};
				}
				if (childCtx.common.issues.length) {
					issues.push(childCtx.common.issues);
				}
			}
			if (dirty) {
				ctx.common.issues.push(...dirty.ctx.common.issues);
				return dirty.result;
			}
			const unionErrors = issues.map((issues$1) => new ZodError(issues$1));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
	}
	get options() {
		return this._def.options;
	}
};
ZodUnion.create = (types, params) => {
	return new ZodUnion({
		options: types,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params)
	});
};
const getDiscriminator = (type) => {
	if (type instanceof ZodLazy) {
		return getDiscriminator(type.schema);
	} else if (type instanceof ZodEffects) {
		return getDiscriminator(type.innerType());
	} else if (type instanceof ZodLiteral) {
		return [type.value];
	} else if (type instanceof ZodEnum) {
		return type.options;
	} else if (type instanceof ZodNativeEnum) {
		return util.objectValues(type.enum);
	} else if (type instanceof ZodDefault) {
		return getDiscriminator(type._def.innerType);
	} else if (type instanceof ZodUndefined) {
		return [undefined];
	} else if (type instanceof ZodNull) {
		return [null];
	} else if (type instanceof ZodOptional) {
		return [undefined, ...getDiscriminator(type.unwrap())];
	} else if (type instanceof ZodNullable) {
		return [null, ...getDiscriminator(type.unwrap())];
	} else if (type instanceof ZodBranded) {
		return getDiscriminator(type.unwrap());
	} else if (type instanceof ZodReadonly) {
		return getDiscriminator(type.unwrap());
	} else if (type instanceof ZodCatch) {
		return getDiscriminator(type._def.innerType);
	} else {
		return [];
	}
};
var ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const discriminator = this.discriminator;
		const discriminatorValue = ctx.data[discriminator];
		const option = this.optionsMap.get(discriminatorValue);
		if (!option) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union_discriminator,
				options: Array.from(this.optionsMap.keys()),
				path: [discriminator]
			});
			return INVALID;
		}
		if (ctx.common.async) {
			return option._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
		} else {
			return option._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
		}
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	/**
	* The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	* However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	* have a different value for each object in the union.
	* @param discriminator the name of the discriminator property
	* @param types an array of object schemas
	* @param params
	*/
	static create(discriminator, options, params) {
		const optionsMap = new Map();
		for (const type of options) {
			const discriminatorValues = getDiscriminator(type.shape[discriminator]);
			if (!discriminatorValues.length) {
				throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
			}
			for (const value of discriminatorValues) {
				if (optionsMap.has(value)) {
					throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
				}
				optionsMap.set(value, type);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params)
		});
	}
};
function mergeValues(a, b) {
	const aType = getParsedType(a);
	const bType = getParsedType(b);
	if (a === b) {
		return {
			valid: true,
			data: a
		};
	} else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		const bKeys = util.objectKeys(b);
		const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) {
				return { valid: false };
			}
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a.length !== b.length) {
			return { valid: false };
		}
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) {
				return { valid: false };
			}
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	} else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
		return {
			valid: true,
			data: a
		};
	} else {
		return { valid: false };
	}
}
var ZodIntersection = class extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const handleParsed = (parsedLeft, parsedRight) => {
			if (isAborted(parsedLeft) || isAborted(parsedRight)) {
				return INVALID;
			}
			const merged = mergeValues(parsedLeft.value, parsedRight.value);
			if (!merged.valid) {
				addIssueToContext(ctx, { code: ZodIssueCode.invalid_intersection_types });
				return INVALID;
			}
			if (isDirty(parsedLeft) || isDirty(parsedRight)) {
				status.dirty();
			}
			return {
				status: status.value,
				value: merged.data
			};
		};
		if (ctx.common.async) {
			return Promise.all([this._def.left._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}), this._def.right._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			})]).then(([left, right]) => handleParsed(left, right));
		} else {
			return handleParsed(this._def.left._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}), this._def.right._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}));
		}
	}
};
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params)
	});
};
var ZodTuple = class ZodTuple extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (ctx.data.length < this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_small,
				minimum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			return INVALID;
		}
		const rest = this._def.rest;
		if (!rest && ctx.data.length > this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			status.dirty();
		}
		const items = [...ctx.data].map((item, itemIndex) => {
			const schema = this._def.items[itemIndex] || this._def.rest;
			if (!schema) return null;
			return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
		}).filter((x) => !!x);
		if (ctx.common.async) {
			return Promise.all(items).then((results) => {
				return ParseStatus.mergeArray(status, results);
			});
		} else {
			return ParseStatus.mergeArray(status, items);
		}
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({
			...this._def,
			rest
		});
	}
};
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas)) {
		throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	}
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params)
	});
};
var ZodRecord = class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const pairs = [];
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		for (const key in ctx.data) {
			pairs.push({
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
				value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
				alwaysSet: key in ctx.data
			});
		}
		if (ctx.common.async) {
			return ParseStatus.mergeObjectAsync(status, pairs);
		} else {
			return ParseStatus.mergeObjectSync(status, pairs);
		}
	}
	get element() {
		return this._def.valueType;
	}
	static create(first, second, third) {
		if (second instanceof ZodType) {
			return new ZodRecord({
				keyType: first,
				valueType: second,
				typeName: ZodFirstPartyTypeKind.ZodRecord,
				...processCreateParams(third)
			});
		}
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second)
		});
	}
};
var ZodMap = class extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.map,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		const pairs = [...ctx.data.entries()].map(([key, value], index) => {
			return {
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
				value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
			};
		});
		if (ctx.common.async) {
			const finalMap = new Map();
			return Promise.resolve().then(async () => {
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					if (key.status === "aborted" || value.status === "aborted") {
						return INVALID;
					}
					if (key.status === "dirty" || value.status === "dirty") {
						status.dirty();
					}
					finalMap.set(key.value, value.value);
				}
				return {
					status: status.value,
					value: finalMap
				};
			});
		} else {
			const finalMap = new Map();
			for (const pair of pairs) {
				const key = pair.key;
				const value = pair.value;
				if (key.status === "aborted" || value.status === "aborted") {
					return INVALID;
				}
				if (key.status === "dirty" || value.status === "dirty") {
					status.dirty();
				}
				finalMap.set(key.value, value.value);
			}
			return {
				status: status.value,
				value: finalMap
			};
		}
	}
};
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params)
	});
};
var ZodSet = class ZodSet extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.set,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.minSize.message
				});
				status.dirty();
			}
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.maxSize.message
				});
				status.dirty();
			}
		}
		const valueType = this._def.valueType;
		function finalizeSet(elements$1) {
			const parsedSet = new Set();
			for (const element of elements$1) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status.dirty();
				parsedSet.add(element.value);
			}
			return {
				status: status.value,
				value: parsedSet
			};
		}
		const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
		if (ctx.common.async) {
			return Promise.all(elements).then((elements$1) => finalizeSet(elements$1));
		} else {
			return finalizeSet(elements);
		}
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: {
				value: minSize,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: {
				value: maxSize,
				message: errorUtil.toString(message)
			}
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params)
	});
};
var ZodFunction = class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.function,
				received: ctx.parsedType
			});
			return INVALID;
		}
		function makeArgsIssue(args, error$47) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error$47
				}
			});
		}
		function makeReturnsIssue(returns, error$47) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error$47
				}
			});
		}
		const params = { errorMap: ctx.common.contextualErrorMap };
		const fn = ctx.data;
		if (this._def.returns instanceof ZodPromise) {
			const me = this;
			return OK(async function(...args) {
				const error$47 = new ZodError([]);
				const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
					error$47.addIssue(makeArgsIssue(args, e));
					throw error$47;
				});
				const result = await Reflect.apply(fn, this, parsedArgs);
				const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
					error$47.addIssue(makeReturnsIssue(result, e));
					throw error$47;
				});
				return parsedReturns;
			});
		} else {
			const me = this;
			return OK(function(...args) {
				const parsedArgs = me._def.args.safeParse(args, params);
				if (!parsedArgs.success) {
					throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
				}
				const result = Reflect.apply(fn, this, parsedArgs.data);
				const parsedReturns = me._def.returns.safeParse(result, params);
				if (!parsedReturns.success) {
					throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
				}
				return parsedReturns.data;
			});
		}
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create())
		});
	}
	returns(returnType) {
		return new ZodFunction({
			...this._def,
			returns: returnType
		});
	}
	implement(func) {
		const validatedFunc = this.parse(func);
		return validatedFunc;
	}
	strictImplement(func) {
		const validatedFunc = this.parse(func);
		return validatedFunc;
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params)
		});
	}
};
var ZodLazy = class extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const lazySchema = this._def.getter();
		return lazySchema._parse({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
};
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params)
	});
};
var ZodLiteral = class extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_literal,
				expected: this._def.value
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
	get value() {
		return this._def.value;
	}
};
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params)
	});
};
function createZodEnum(values, params) {
	return new ZodEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params)
	});
}
var ZodEnum = class ZodEnum extends ZodType {
	_parse(input) {
		if (typeof input.data !== "string") {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) {
			this._cache = new Set(this._def.values);
		}
		if (!this._cache.has(input.data)) {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		const enumValues = {};
		for (const val of this._def.values) {
			enumValues[val] = val;
		}
		return enumValues;
	}
	get Values() {
		const enumValues = {};
		for (const val of this._def.values) {
			enumValues[val] = val;
		}
		return enumValues;
	}
	get Enum() {
		const enumValues = {};
		for (const val of this._def.values) {
			enumValues[val] = val;
		}
		return enumValues;
	}
	extract(values, newDef = this._def) {
		return ZodEnum.create(values, {
			...this._def,
			...newDef
		});
	}
	exclude(values, newDef = this._def) {
		return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
			...this._def,
			...newDef
		});
	}
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
	_parse(input) {
		const nativeEnumValues = util.getValidEnumValues(this._def.values);
		const ctx = this._getOrReturnCtx(input);
		if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) {
			this._cache = new Set(util.getValidEnumValues(this._def.values));
		}
		if (!this._cache.has(input.data)) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
};
ZodNativeEnum.create = (values, params) => {
	return new ZodNativeEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params)
	});
};
var ZodPromise = class extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.promise,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
		return OK(promisified.then((data) => {
			return this._def.type.parseAsync(data, {
				path: ctx.path,
				errorMap: ctx.common.contextualErrorMap
			});
		}));
	}
};
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params)
	});
};
var ZodEffects = class extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const effect = this._def.effect || null;
		const checkCtx = {
			addIssue: (arg) => {
				addIssueToContext(ctx, arg);
				if (arg.fatal) {
					status.abort();
				} else {
					status.dirty();
				}
			},
			get path() {
				return ctx.path;
			}
		};
		checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
		if (effect.type === "preprocess") {
			const processed = effect.transform(ctx.data, checkCtx);
			if (ctx.common.async) {
				return Promise.resolve(processed).then(async (processed$1) => {
					if (status.value === "aborted") return INVALID;
					const result = await this._def.schema._parseAsync({
						data: processed$1,
						path: ctx.path,
						parent: ctx
					});
					if (result.status === "aborted") return INVALID;
					if (result.status === "dirty") return DIRTY(result.value);
					if (status.value === "dirty") return DIRTY(result.value);
					return result;
				});
			} else {
				if (status.value === "aborted") return INVALID;
				const result = this._def.schema._parseSync({
					data: processed,
					path: ctx.path,
					parent: ctx
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status.value === "dirty") return DIRTY(result.value);
				return result;
			}
		}
		if (effect.type === "refinement") {
			const executeRefinement = (acc) => {
				const result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) {
					return Promise.resolve(result);
				}
				if (result instanceof Promise) {
					throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
				}
				return acc;
			};
			if (ctx.common.async === false) {
				const inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				executeRefinement(inner.value);
				return {
					status: status.value,
					value: inner.value
				};
			} else {
				return this._def.schema._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				}).then((inner) => {
					if (inner.status === "aborted") return INVALID;
					if (inner.status === "dirty") status.dirty();
					return executeRefinement(inner.value).then(() => {
						return {
							status: status.value,
							value: inner.value
						};
					});
				});
			}
		}
		if (effect.type === "transform") {
			if (ctx.common.async === false) {
				const base = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (!isValid(base)) return INVALID;
				const result = effect.transform(base.value, checkCtx);
				if (result instanceof Promise) {
					throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
				}
				return {
					status: status.value,
					value: result
				};
			} else {
				return this._def.schema._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				}).then((base) => {
					if (!isValid(base)) return INVALID;
					return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
						status: status.value,
						value: result
					}));
				});
			}
		}
		util.assertNever(effect);
	}
};
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params)
	});
};
ZodEffects.createWithPreprocess = (preprocess$1, schema, params) => {
	return new ZodEffects({
		schema,
		effect: {
			type: "preprocess",
			transform: preprocess$1
		},
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params)
	});
};
var ZodOptional = class extends ZodType {
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 === ZodParsedType.undefined) {
			return OK(undefined);
		}
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodOptional.create = (type, params) => {
	return new ZodOptional({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params)
	});
};
var ZodNullable = class extends ZodType {
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 === ZodParsedType.null) {
			return OK(null);
		}
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodNullable.create = (type, params) => {
	return new ZodNullable({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params)
	});
};
var ZodDefault = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		let data = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined) {
			data = this._def.defaultValue();
		}
		return this._def.innerType._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	removeDefault() {
		return this._def.innerType;
	}
};
ZodDefault.create = (type, params) => {
	return new ZodDefault({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue: typeof params.default === "function" ? params.default : () => params.default,
		...processCreateParams(params)
	});
};
var ZodCatch = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const newCtx = {
			...ctx,
			common: {
				...ctx.common,
				issues: []
			}
		};
		const result = this._def.innerType._parse({
			data: newCtx.data,
			path: newCtx.path,
			parent: { ...newCtx }
		});
		if (isAsync(result)) {
			return result.then((result$1) => {
				return {
					status: "valid",
					value: result$1.status === "valid" ? result$1.value : this._def.catchValue({
						get error() {
							return new ZodError(newCtx.common.issues);
						},
						input: newCtx.data
					})
				};
			});
		} else {
			return {
				status: "valid",
				value: result.status === "valid" ? result.value : this._def.catchValue({
					get error() {
						return new ZodError(newCtx.common.issues);
					},
					input: newCtx.data
				})
			};
		}
	}
	removeCatch() {
		return this._def.innerType;
	}
};
ZodCatch.create = (type, params) => {
	return new ZodCatch({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params)
	});
};
var ZodNaN = class extends ZodType {
	_parse(input) {
		const parsedType$1 = this._getType(input);
		if (parsedType$1 !== ZodParsedType.nan) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.nan,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
};
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params)
	});
};
const BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const data = ctx.data;
		return this._def.type._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	unwrap() {
		return this._def.type;
	}
};
var ZodPipeline = class ZodPipeline extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.common.async) {
			const handleAsync = async () => {
				const inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty") {
					status.dirty();
					return DIRTY(inResult.value);
				} else {
					return this._def.out._parseAsync({
						data: inResult.value,
						path: ctx.path,
						parent: ctx
					});
				}
			};
			return handleAsync();
		} else {
			const inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty") {
				status.dirty();
				return {
					status: "dirty",
					value: inResult.value
				};
			} else {
				return this._def.out._parseSync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx
				});
			}
		}
	}
	static create(a, b) {
		return new ZodPipeline({
			in: a,
			out: b,
			typeName: ZodFirstPartyTypeKind.ZodPipeline
		});
	}
};
var ZodReadonly = class extends ZodType {
	_parse(input) {
		const result = this._def.innerType._parse(input);
		const freeze = (data) => {
			if (isValid(data)) {
				data.value = Object.freeze(data.value);
			}
			return data;
		};
		return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodReadonly.create = (type, params) => {
	return new ZodReadonly({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodReadonly,
		...processCreateParams(params)
	});
};
function cleanParams(params, data) {
	const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
	const p2 = typeof p === "string" ? { message: p } : p;
	return p2;
}
function custom$1(check$2, _params = {}, fatal) {
	if (check$2) return ZodAny.create().superRefine((data, ctx) => {
		const r = check$2(data);
		if (r instanceof Promise) {
			return r.then((r$1) => {
				if (!r$1) {
					const params = cleanParams(_params, data);
					const _fatal = params.fatal ?? fatal ?? true;
					ctx.addIssue({
						code: "custom",
						...params,
						fatal: _fatal
					});
				}
			});
		}
		if (!r) {
			const params = cleanParams(_params, data);
			const _fatal = params.fatal ?? fatal ?? true;
			ctx.addIssue({
				code: "custom",
				...params,
				fatal: _fatal
			});
		}
		return;
	});
	return ZodAny.create();
}
const late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind$2) {
	ZodFirstPartyTypeKind$2["ZodString"] = "ZodString";
	ZodFirstPartyTypeKind$2["ZodNumber"] = "ZodNumber";
	ZodFirstPartyTypeKind$2["ZodNaN"] = "ZodNaN";
	ZodFirstPartyTypeKind$2["ZodBigInt"] = "ZodBigInt";
	ZodFirstPartyTypeKind$2["ZodBoolean"] = "ZodBoolean";
	ZodFirstPartyTypeKind$2["ZodDate"] = "ZodDate";
	ZodFirstPartyTypeKind$2["ZodSymbol"] = "ZodSymbol";
	ZodFirstPartyTypeKind$2["ZodUndefined"] = "ZodUndefined";
	ZodFirstPartyTypeKind$2["ZodNull"] = "ZodNull";
	ZodFirstPartyTypeKind$2["ZodAny"] = "ZodAny";
	ZodFirstPartyTypeKind$2["ZodUnknown"] = "ZodUnknown";
	ZodFirstPartyTypeKind$2["ZodNever"] = "ZodNever";
	ZodFirstPartyTypeKind$2["ZodVoid"] = "ZodVoid";
	ZodFirstPartyTypeKind$2["ZodArray"] = "ZodArray";
	ZodFirstPartyTypeKind$2["ZodObject"] = "ZodObject";
	ZodFirstPartyTypeKind$2["ZodUnion"] = "ZodUnion";
	ZodFirstPartyTypeKind$2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	ZodFirstPartyTypeKind$2["ZodIntersection"] = "ZodIntersection";
	ZodFirstPartyTypeKind$2["ZodTuple"] = "ZodTuple";
	ZodFirstPartyTypeKind$2["ZodRecord"] = "ZodRecord";
	ZodFirstPartyTypeKind$2["ZodMap"] = "ZodMap";
	ZodFirstPartyTypeKind$2["ZodSet"] = "ZodSet";
	ZodFirstPartyTypeKind$2["ZodFunction"] = "ZodFunction";
	ZodFirstPartyTypeKind$2["ZodLazy"] = "ZodLazy";
	ZodFirstPartyTypeKind$2["ZodLiteral"] = "ZodLiteral";
	ZodFirstPartyTypeKind$2["ZodEnum"] = "ZodEnum";
	ZodFirstPartyTypeKind$2["ZodEffects"] = "ZodEffects";
	ZodFirstPartyTypeKind$2["ZodNativeEnum"] = "ZodNativeEnum";
	ZodFirstPartyTypeKind$2["ZodOptional"] = "ZodOptional";
	ZodFirstPartyTypeKind$2["ZodNullable"] = "ZodNullable";
	ZodFirstPartyTypeKind$2["ZodDefault"] = "ZodDefault";
	ZodFirstPartyTypeKind$2["ZodCatch"] = "ZodCatch";
	ZodFirstPartyTypeKind$2["ZodPromise"] = "ZodPromise";
	ZodFirstPartyTypeKind$2["ZodBranded"] = "ZodBranded";
	ZodFirstPartyTypeKind$2["ZodPipeline"] = "ZodPipeline";
	ZodFirstPartyTypeKind$2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var Class$1 = class {
	constructor(..._) {}
};
const instanceOfType = (cls, params = { message: `Input not instance of ${cls.name}` }) => custom$1((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
	string: ((arg) => ZodString.create({
		...arg,
		coerce: true
	})),
	number: ((arg) => ZodNumber.create({
		...arg,
		coerce: true
	})),
	boolean: ((arg) => ZodBoolean.create({
		...arg,
		coerce: true
	})),
	bigint: ((arg) => ZodBigInt.create({
		...arg,
		coerce: true
	})),
	date: ((arg) => ZodDate.create({
		...arg,
		coerce: true
	}))
};
const NEVER = INVALID;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/external.js
var external_exports$1 = /* @__PURE__ */ __exportAll({
	BRAND: () => BRAND,
	DIRTY: () => DIRTY,
	EMPTY_PATH: () => EMPTY_PATH,
	INVALID: () => INVALID,
	NEVER: () => NEVER,
	OK: () => OK,
	ParseStatus: () => ParseStatus,
	Schema: () => ZodType,
	ZodAny: () => ZodAny,
	ZodArray: () => ZodArray,
	ZodBigInt: () => ZodBigInt,
	ZodBoolean: () => ZodBoolean,
	ZodBranded: () => ZodBranded,
	ZodCatch: () => ZodCatch,
	ZodDate: () => ZodDate,
	ZodDefault: () => ZodDefault,
	ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
	ZodEffects: () => ZodEffects,
	ZodEnum: () => ZodEnum,
	ZodError: () => ZodError,
	ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
	ZodFunction: () => ZodFunction,
	ZodIntersection: () => ZodIntersection,
	ZodIssueCode: () => ZodIssueCode,
	ZodLazy: () => ZodLazy,
	ZodLiteral: () => ZodLiteral,
	ZodMap: () => ZodMap,
	ZodNaN: () => ZodNaN,
	ZodNativeEnum: () => ZodNativeEnum,
	ZodNever: () => ZodNever,
	ZodNull: () => ZodNull,
	ZodNullable: () => ZodNullable,
	ZodNumber: () => ZodNumber,
	ZodObject: () => ZodObject,
	ZodOptional: () => ZodOptional,
	ZodParsedType: () => ZodParsedType,
	ZodPipeline: () => ZodPipeline,
	ZodPromise: () => ZodPromise,
	ZodReadonly: () => ZodReadonly,
	ZodRecord: () => ZodRecord,
	ZodSchema: () => ZodType,
	ZodSet: () => ZodSet,
	ZodString: () => ZodString,
	ZodSymbol: () => ZodSymbol,
	ZodTransformer: () => ZodEffects,
	ZodTuple: () => ZodTuple,
	ZodType: () => ZodType,
	ZodUndefined: () => ZodUndefined,
	ZodUnion: () => ZodUnion,
	ZodUnknown: () => ZodUnknown,
	ZodVoid: () => ZodVoid,
	addIssueToContext: () => addIssueToContext,
	any: () => anyType,
	array: () => arrayType,
	bigint: () => bigIntType,
	boolean: () => booleanType,
	coerce: () => coerce,
	custom: () => custom$1,
	date: () => dateType,
	datetimeRegex: () => datetimeRegex,
	defaultErrorMap: () => en_default,
	discriminatedUnion: () => discriminatedUnionType,
	effect: () => effectsType,
	enum: () => enumType,
	function: () => functionType,
	getErrorMap: () => getErrorMap,
	getParsedType: () => getParsedType,
	instanceof: () => instanceOfType,
	intersection: () => intersectionType,
	isAborted: () => isAborted,
	isAsync: () => isAsync,
	isDirty: () => isDirty,
	isValid: () => isValid,
	late: () => late,
	lazy: () => lazyType,
	literal: () => literalType,
	makeIssue: () => makeIssue,
	map: () => mapType,
	nan: () => nanType,
	nativeEnum: () => nativeEnumType,
	never: () => neverType,
	null: () => nullType,
	nullable: () => nullableType,
	number: () => numberType,
	object: () => objectType,
	objectUtil: () => objectUtil,
	oboolean: () => oboolean,
	onumber: () => onumber,
	optional: () => optionalType,
	ostring: () => ostring,
	pipeline: () => pipelineType,
	preprocess: () => preprocessType,
	promise: () => promiseType,
	quotelessJson: () => quotelessJson,
	record: () => recordType,
	set: () => setType,
	setErrorMap: () => setErrorMap,
	strictObject: () => strictObjectType,
	string: () => stringType,
	symbol: () => symbolType,
	transformer: () => effectsType,
	tuple: () => tupleType,
	undefined: () => undefinedType,
	union: () => unionType,
	unknown: () => unknownType,
	util: () => util,
	void: () => voidType
});

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v3/index.js
var v3_default = external_exports$1;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/mini/schemas.js
const ZodMiniType = /* @__PURE__ */ $constructor("ZodMiniType", (inst, def) => {
	if (!inst._zod) throw new Error("Uninitialized schema in ZodMiniType.");
	$ZodType.init(inst, def);
	inst.def = def;
	inst.type = def.type;
	inst.parse = (data, params) => parse$3(inst, data, params, { callee: inst.parse });
	inst.safeParse = (data, params) => safeParse$2(inst, data, params);
	inst.parseAsync = async (data, params) => parseAsync$1(inst, data, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data, params) => safeParseAsync$2(inst, data, params);
	inst.check = (...checks) => {
		return inst.clone({
			...def,
			checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
				check: ch,
				def: { check: "custom" },
				onattach: []
			} } : ch)]
		}, { parent: true });
	};
	inst.with = inst.check;
	inst.clone = (_def, params) => clone(inst, _def, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta$3) => {
		reg.add(inst, meta$3);
		return inst;
	});
	inst.apply = (fn) => fn(inst);
});
const ZodMiniString = /* @__PURE__ */ $constructor("ZodMiniString", (inst, def) => {
	$ZodString.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function string$1(params) {
	return _string(ZodMiniString, params);
}
const ZodMiniStringFormat = /* @__PURE__ */ $constructor("ZodMiniStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	ZodMiniString.init(inst, def);
});
const ZodMiniEmail = /* @__PURE__ */ $constructor("ZodMiniEmail", (inst, def) => {
	$ZodEmail.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function email(params) {
	return _email(ZodMiniEmail, params);
}
const ZodMiniGUID = /* @__PURE__ */ $constructor("ZodMiniGUID", (inst, def) => {
	$ZodGUID.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function guid(params) {
	return _guid(ZodMiniGUID, params);
}
const ZodMiniUUID = /* @__PURE__ */ $constructor("ZodMiniUUID", (inst, def) => {
	$ZodUUID.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function uuid(params) {
	return _uuid(ZodMiniUUID, params);
}
/* @__NO_SIDE_EFFECTS__ */
function uuidv4(params) {
	return _uuidv4(ZodMiniUUID, params);
}
/* @__NO_SIDE_EFFECTS__ */
function uuidv6(params) {
	return _uuidv6(ZodMiniUUID, params);
}
/* @__NO_SIDE_EFFECTS__ */
function uuidv7(params) {
	return _uuidv7(ZodMiniUUID, params);
}
const ZodMiniURL = /* @__PURE__ */ $constructor("ZodMiniURL", (inst, def) => {
	$ZodURL.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function url(params) {
	return _url$1(ZodMiniURL, params);
}
/* @__NO_SIDE_EFFECTS__ */
function httpUrl(params) {
	return _url$1(ZodMiniURL, {
		protocol: /^https?$/,
		hostname: domain,
		...normalizeParams(params)
	});
}
const ZodMiniEmoji = /* @__PURE__ */ $constructor("ZodMiniEmoji", (inst, def) => {
	$ZodEmoji.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function emoji(params) {
	return _emoji(ZodMiniEmoji, params);
}
const ZodMiniNanoID = /* @__PURE__ */ $constructor("ZodMiniNanoID", (inst, def) => {
	$ZodNanoID.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function nanoid(params) {
	return _nanoid(ZodMiniNanoID, params);
}
const ZodMiniCUID = /* @__PURE__ */ $constructor("ZodMiniCUID", (inst, def) => {
	$ZodCUID.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function cuid(params) {
	return _cuid(ZodMiniCUID, params);
}
const ZodMiniCUID2 = /* @__PURE__ */ $constructor("ZodMiniCUID2", (inst, def) => {
	$ZodCUID2.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function cuid2(params) {
	return _cuid2(ZodMiniCUID2, params);
}
const ZodMiniULID = /* @__PURE__ */ $constructor("ZodMiniULID", (inst, def) => {
	$ZodULID.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function ulid(params) {
	return _ulid(ZodMiniULID, params);
}
const ZodMiniXID = /* @__PURE__ */ $constructor("ZodMiniXID", (inst, def) => {
	$ZodXID.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function xid(params) {
	return _xid(ZodMiniXID, params);
}
const ZodMiniKSUID = /* @__PURE__ */ $constructor("ZodMiniKSUID", (inst, def) => {
	$ZodKSUID.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function ksuid(params) {
	return _ksuid(ZodMiniKSUID, params);
}
const ZodMiniIPv4 = /* @__PURE__ */ $constructor("ZodMiniIPv4", (inst, def) => {
	$ZodIPv4.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function ipv4(params) {
	return _ipv4(ZodMiniIPv4, params);
}
const ZodMiniIPv6 = /* @__PURE__ */ $constructor("ZodMiniIPv6", (inst, def) => {
	$ZodIPv6.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function ipv6(params) {
	return _ipv6(ZodMiniIPv6, params);
}
const ZodMiniCIDRv4 = /* @__PURE__ */ $constructor("ZodMiniCIDRv4", (inst, def) => {
	$ZodCIDRv4.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function cidrv4(params) {
	return _cidrv4(ZodMiniCIDRv4, params);
}
const ZodMiniCIDRv6 = /* @__PURE__ */ $constructor("ZodMiniCIDRv6", (inst, def) => {
	$ZodCIDRv6.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function cidrv6(params) {
	return _cidrv6(ZodMiniCIDRv6, params);
}
const ZodMiniMAC = /* @__PURE__ */ $constructor("ZodMiniMAC", (inst, def) => {
	$ZodMAC.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function mac(params) {
	return _mac(ZodMiniMAC, params);
}
const ZodMiniBase64 = /* @__PURE__ */ $constructor("ZodMiniBase64", (inst, def) => {
	$ZodBase64.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function base64(params) {
	return _base64(ZodMiniBase64, params);
}
const ZodMiniBase64URL = /* @__PURE__ */ $constructor("ZodMiniBase64URL", (inst, def) => {
	$ZodBase64URL.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function base64url(params) {
	return _base64url(ZodMiniBase64URL, params);
}
const ZodMiniE164 = /* @__PURE__ */ $constructor("ZodMiniE164", (inst, def) => {
	$ZodE164.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function e164(params) {
	return _e164(ZodMiniE164, params);
}
const ZodMiniJWT = /* @__PURE__ */ $constructor("ZodMiniJWT", (inst, def) => {
	$ZodJWT.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function jwt(params) {
	return _jwt(ZodMiniJWT, params);
}
const ZodMiniCustomStringFormat = /* @__PURE__ */ $constructor("ZodMiniCustomStringFormat", (inst, def) => {
	$ZodCustomStringFormat.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function stringFormat(format$2, fnOrRegex, _params = {}) {
	return _stringFormat(ZodMiniCustomStringFormat, format$2, fnOrRegex, _params);
}
/* @__NO_SIDE_EFFECTS__ */
function hostname(_params) {
	return _stringFormat(ZodMiniCustomStringFormat, "hostname", hostname$2, _params);
}
/* @__NO_SIDE_EFFECTS__ */
function hex(_params) {
	return _stringFormat(ZodMiniCustomStringFormat, "hex", hex$2, _params);
}
/* @__NO_SIDE_EFFECTS__ */
function hash(alg, params) {
	const enc = params?.enc ?? "hex";
	const format$2 = `${alg}_${enc}`;
	const regex = regexes_exports[format$2];
	if (!regex) throw new Error(`Unrecognized hash format: ${format$2}`);
	return _stringFormat(ZodMiniCustomStringFormat, format$2, regex, params);
}
const ZodMiniNumber = /* @__PURE__ */ $constructor("ZodMiniNumber", (inst, def) => {
	$ZodNumber.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function number$1(params) {
	return _number(ZodMiniNumber, params);
}
const ZodMiniNumberFormat = /* @__PURE__ */ $constructor("ZodMiniNumberFormat", (inst, def) => {
	$ZodNumberFormat.init(inst, def);
	ZodMiniNumber.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function int(params) {
	return _int(ZodMiniNumberFormat, params);
}
/* @__NO_SIDE_EFFECTS__ */
function float32(params) {
	return _float32(ZodMiniNumberFormat, params);
}
/* @__NO_SIDE_EFFECTS__ */
function float64(params) {
	return _float64(ZodMiniNumberFormat, params);
}
/* @__NO_SIDE_EFFECTS__ */
function int32(params) {
	return _int32(ZodMiniNumberFormat, params);
}
/* @__NO_SIDE_EFFECTS__ */
function uint32(params) {
	return _uint32(ZodMiniNumberFormat, params);
}
const ZodMiniBoolean = /* @__PURE__ */ $constructor("ZodMiniBoolean", (inst, def) => {
	$ZodBoolean.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function boolean$1(params) {
	return _boolean(ZodMiniBoolean, params);
}
const ZodMiniBigInt = /* @__PURE__ */ $constructor("ZodMiniBigInt", (inst, def) => {
	$ZodBigInt.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function bigint$1(params) {
	return _bigint(ZodMiniBigInt, params);
}
const ZodMiniBigIntFormat = /* @__PURE__ */ $constructor("ZodMiniBigIntFormat", (inst, def) => {
	$ZodBigIntFormat.init(inst, def);
	ZodMiniBigInt.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function int64(params) {
	return _int64(ZodMiniBigIntFormat, params);
}
/* @__NO_SIDE_EFFECTS__ */
function uint64(params) {
	return _uint64(ZodMiniBigIntFormat, params);
}
const ZodMiniSymbol = /* @__PURE__ */ $constructor("ZodMiniSymbol", (inst, def) => {
	$ZodSymbol.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function symbol(params) {
	return _symbol(ZodMiniSymbol, params);
}
const ZodMiniUndefined = /* @__PURE__ */ $constructor("ZodMiniUndefined", (inst, def) => {
	$ZodUndefined.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function _undefined(params) {
	return _undefined$2(ZodMiniUndefined, params);
}
const ZodMiniNull = /* @__PURE__ */ $constructor("ZodMiniNull", (inst, def) => {
	$ZodNull.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function _null(params) {
	return _null$2(ZodMiniNull, params);
}
const ZodMiniAny = /* @__PURE__ */ $constructor("ZodMiniAny", (inst, def) => {
	$ZodAny.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function any() {
	return _any(ZodMiniAny);
}
const ZodMiniUnknown = /* @__PURE__ */ $constructor("ZodMiniUnknown", (inst, def) => {
	$ZodUnknown.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function unknown() {
	return _unknown(ZodMiniUnknown);
}
const ZodMiniNever = /* @__PURE__ */ $constructor("ZodMiniNever", (inst, def) => {
	$ZodNever.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function never(params) {
	return _never(ZodMiniNever, params);
}
const ZodMiniVoid = /* @__PURE__ */ $constructor("ZodMiniVoid", (inst, def) => {
	$ZodVoid.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function _void(params) {
	return _void$2(ZodMiniVoid, params);
}
const ZodMiniDate = /* @__PURE__ */ $constructor("ZodMiniDate", (inst, def) => {
	$ZodDate.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function date$2(params) {
	return _date(ZodMiniDate, params);
}
const ZodMiniArray = /* @__PURE__ */ $constructor("ZodMiniArray", (inst, def) => {
	$ZodArray.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function array(element, params) {
	return new ZodMiniArray({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function keyof(schema) {
	const shape = schema._zod.def.shape;
	return _enum(Object.keys(shape));
}
const ZodMiniObject = /* @__PURE__ */ $constructor("ZodMiniObject", (inst, def) => {
	$ZodObject.init(inst, def);
	ZodMiniType.init(inst, def);
	defineLazy(inst, "shape", () => def.shape);
});
/* @__NO_SIDE_EFFECTS__ */
function object(shape, params) {
	const def = {
		type: "object",
		shape: shape ?? {},
		...normalizeParams(params)
	};
	return new ZodMiniObject(def);
}
/* @__NO_SIDE_EFFECTS__ */
function strictObject(shape, params) {
	return new ZodMiniObject({
		type: "object",
		shape,
		catchall: /* @__PURE__ */ never(),
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function looseObject(shape, params) {
	return new ZodMiniObject({
		type: "object",
		shape,
		catchall: /* @__PURE__ */ unknown(),
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function extend(schema, shape) {
	return extend$1(schema, shape);
}
/* @__NO_SIDE_EFFECTS__ */
function safeExtend(schema, shape) {
	return safeExtend$1(schema, shape);
}
/* @__NO_SIDE_EFFECTS__ */
function merge(schema, shape) {
	return extend$1(schema, shape);
}
/* @__NO_SIDE_EFFECTS__ */
function pick(schema, mask) {
	return pick$1(schema, mask);
}
/* @__NO_SIDE_EFFECTS__ */
function omit(schema, mask) {
	return omit$1(schema, mask);
}
/* @__NO_SIDE_EFFECTS__ */
function partial(schema, mask) {
	return partial$1(ZodMiniOptional, schema, mask);
}
/* @__NO_SIDE_EFFECTS__ */
function required(schema, mask) {
	return required$1(ZodMiniNonOptional, schema, mask);
}
/* @__NO_SIDE_EFFECTS__ */
function catchall(inst, catchall$1) {
	return inst.clone({
		...inst._zod.def,
		catchall: catchall$1
	});
}
const ZodMiniUnion = /* @__PURE__ */ $constructor("ZodMiniUnion", (inst, def) => {
	$ZodUnion.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function union(options, params) {
	return new ZodMiniUnion({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodMiniXor = /* @__PURE__ */ $constructor("ZodMiniXor", (inst, def) => {
	ZodMiniUnion.init(inst, def);
	$ZodXor.init(inst, def);
});
/** Creates an exclusive union (XOR) where exactly one option must match.
* Unlike regular unions that succeed when any option matches, xor fails if
* zero or more than one option matches the input. */
function xor(options, params) {
	return new ZodMiniXor({
		type: "union",
		options,
		inclusive: false,
		...normalizeParams(params)
	});
}
const ZodMiniDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodMiniDiscriminatedUnion", (inst, def) => {
	$ZodDiscriminatedUnion.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function discriminatedUnion(discriminator, options, params) {
	return new ZodMiniDiscriminatedUnion({
		type: "union",
		options,
		discriminator,
		...normalizeParams(params)
	});
}
const ZodMiniIntersection = /* @__PURE__ */ $constructor("ZodMiniIntersection", (inst, def) => {
	$ZodIntersection.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function intersection(left, right) {
	return new ZodMiniIntersection({
		type: "intersection",
		left,
		right
	});
}
const ZodMiniTuple = /* @__PURE__ */ $constructor("ZodMiniTuple", (inst, def) => {
	$ZodTuple.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function tuple(items, _paramsOrRest, _params) {
	const hasRest = _paramsOrRest instanceof $ZodType;
	const params = hasRest ? _params : _paramsOrRest;
	const rest = hasRest ? _paramsOrRest : null;
	return new ZodMiniTuple({
		type: "tuple",
		items,
		rest,
		...normalizeParams(params)
	});
}
const ZodMiniRecord = /* @__PURE__ */ $constructor("ZodMiniRecord", (inst, def) => {
	$ZodRecord.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function record(keyType, valueType, params) {
	return new ZodMiniRecord({
		type: "record",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function partialRecord(keyType, valueType, params) {
	const k = clone(keyType);
	k._zod.values = undefined;
	return new ZodMiniRecord({
		type: "record",
		keyType: k,
		valueType,
		...normalizeParams(params)
	});
}
function looseRecord(keyType, valueType, params) {
	return new ZodMiniRecord({
		type: "record",
		keyType,
		valueType,
		mode: "loose",
		...normalizeParams(params)
	});
}
const ZodMiniMap = /* @__PURE__ */ $constructor("ZodMiniMap", (inst, def) => {
	$ZodMap.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function map(keyType, valueType, params) {
	return new ZodMiniMap({
		type: "map",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
const ZodMiniSet = /* @__PURE__ */ $constructor("ZodMiniSet", (inst, def) => {
	$ZodSet.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function set(valueType, params) {
	return new ZodMiniSet({
		type: "set",
		valueType,
		...normalizeParams(params)
	});
}
const ZodMiniEnum = /* @__PURE__ */ $constructor("ZodMiniEnum", (inst, def) => {
	$ZodEnum.init(inst, def);
	ZodMiniType.init(inst, def);
	inst.options = Object.values(def.entries);
});
/* @__NO_SIDE_EFFECTS__ */
function _enum(values, params) {
	const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
	return new ZodMiniEnum({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
*
* ```ts
* enum Colors { red, green, blue }
* z.enum(Colors);
* ```
*/
/* @__NO_SIDE_EFFECTS__ */
function nativeEnum(entries, params) {
	return new ZodMiniEnum({
		type: "enum",
		entries,
		...normalizeParams(params)
	});
}
const ZodMiniLiteral = /* @__PURE__ */ $constructor("ZodMiniLiteral", (inst, def) => {
	$ZodLiteral.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function literal(value, params) {
	return new ZodMiniLiteral({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
const ZodMiniFile = /* @__PURE__ */ $constructor("ZodMiniFile", (inst, def) => {
	$ZodFile.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function file(params) {
	return _file(ZodMiniFile, params);
}
const ZodMiniTransform = /* @__PURE__ */ $constructor("ZodMiniTransform", (inst, def) => {
	$ZodTransform.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function transform(fn) {
	return new ZodMiniTransform({
		type: "transform",
		transform: fn
	});
}
const ZodMiniOptional = /* @__PURE__ */ $constructor("ZodMiniOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function optional(innerType) {
	return new ZodMiniOptional({
		type: "optional",
		innerType
	});
}
const ZodMiniExactOptional = /* @__PURE__ */ $constructor("ZodMiniExactOptional", (inst, def) => {
	$ZodExactOptional.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function exactOptional(innerType) {
	return new ZodMiniExactOptional({
		type: "optional",
		innerType
	});
}
const ZodMiniNullable = /* @__PURE__ */ $constructor("ZodMiniNullable", (inst, def) => {
	$ZodNullable.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function nullable(innerType) {
	return new ZodMiniNullable({
		type: "nullable",
		innerType
	});
}
/* @__NO_SIDE_EFFECTS__ */
function nullish(innerType) {
	return /* @__PURE__ */ optional(/* @__PURE__ */ nullable(innerType));
}
const ZodMiniDefault = /* @__PURE__ */ $constructor("ZodMiniDefault", (inst, def) => {
	$ZodDefault.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function _default(innerType, defaultValue) {
	return new ZodMiniDefault({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodMiniPrefault = /* @__PURE__ */ $constructor("ZodMiniPrefault", (inst, def) => {
	$ZodPrefault.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function prefault(innerType, defaultValue) {
	return new ZodMiniPrefault({
		type: "prefault",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodMiniNonOptional = /* @__PURE__ */ $constructor("ZodMiniNonOptional", (inst, def) => {
	$ZodNonOptional.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function nonoptional(innerType, params) {
	return new ZodMiniNonOptional({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
const ZodMiniSuccess = /* @__PURE__ */ $constructor("ZodMiniSuccess", (inst, def) => {
	$ZodSuccess.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function success(innerType) {
	return new ZodMiniSuccess({
		type: "success",
		innerType
	});
}
const ZodMiniCatch = /* @__PURE__ */ $constructor("ZodMiniCatch", (inst, def) => {
	$ZodCatch.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function _catch(innerType, catchValue) {
	return new ZodMiniCatch({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
const ZodMiniNaN = /* @__PURE__ */ $constructor("ZodMiniNaN", (inst, def) => {
	$ZodNaN.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function nan(params) {
	return _nan(ZodMiniNaN, params);
}
const ZodMiniPipe = /* @__PURE__ */ $constructor("ZodMiniPipe", (inst, def) => {
	$ZodPipe.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function pipe(in_, out) {
	return new ZodMiniPipe({
		type: "pipe",
		in: in_,
		out
	});
}
const ZodMiniCodec = /* @__PURE__ */ $constructor("ZodMiniCodec", (inst, def) => {
	ZodMiniPipe.init(inst, def);
	$ZodCodec.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function codec(in_, out, params) {
	return new ZodMiniCodec({
		type: "pipe",
		in: in_,
		out,
		transform: params.decode,
		reverseTransform: params.encode
	});
}
const ZodMiniReadonly = /* @__PURE__ */ $constructor("ZodMiniReadonly", (inst, def) => {
	$ZodReadonly.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function readonly(innerType) {
	return new ZodMiniReadonly({
		type: "readonly",
		innerType
	});
}
const ZodMiniTemplateLiteral = /* @__PURE__ */ $constructor("ZodMiniTemplateLiteral", (inst, def) => {
	$ZodTemplateLiteral.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function templateLiteral(parts, params) {
	return new ZodMiniTemplateLiteral({
		type: "template_literal",
		parts,
		...normalizeParams(params)
	});
}
const ZodMiniLazy = /* @__PURE__ */ $constructor("ZodMiniLazy", (inst, def) => {
	$ZodLazy.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function _lazy(getter) {
	return new ZodMiniLazy({
		type: "lazy",
		getter
	});
}
const ZodMiniPromise = /* @__PURE__ */ $constructor("ZodMiniPromise", (inst, def) => {
	$ZodPromise.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function promise(innerType) {
	return new ZodMiniPromise({
		type: "promise",
		innerType
	});
}
const ZodMiniCustom = /* @__PURE__ */ $constructor("ZodMiniCustom", (inst, def) => {
	$ZodCustom.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function check(fn, params) {
	const ch = new $ZodCheck({
		check: "custom",
		...normalizeParams(params)
	});
	ch._zod.check = fn;
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function custom(fn, _params) {
	return _custom(ZodMiniCustom, fn ?? (() => true), _params);
}
/* @__NO_SIDE_EFFECTS__ */
function refine(fn, _params = {}) {
	return _refine(ZodMiniCustom, fn, _params);
}
/* @__NO_SIDE_EFFECTS__ */
function superRefine(fn) {
	return _superRefine(fn);
}
const describe = describe$2;
const meta = meta$2;
var Class = class {
	constructor(..._args) {}
};
/* @__NO_SIDE_EFFECTS__ */
function _instanceof(cls, params = {}) {
	const inst = /* @__PURE__ */ custom((data) => data instanceof cls, params);
	inst._zod.bag.Class = cls;
	inst._zod.check = (payload) => {
		if (!(payload.value instanceof cls)) {
			payload.issues.push({
				code: "invalid_type",
				expected: cls.name,
				input: payload.value,
				inst,
				path: [...inst._zod.def.path ?? []]
			});
		}
	};
	return inst;
}
const stringbool = (...args) => _stringbool({
	Codec: ZodMiniCodec,
	Boolean: ZodMiniBoolean,
	String: ZodMiniString
}, ...args);
/* @__NO_SIDE_EFFECTS__ */
function json() {
	const jsonSchema = _lazy(() => {
		return /* @__PURE__ */ union([
			/* @__PURE__ */ string$1(),
			/* @__PURE__ */ number$1(),
			/* @__PURE__ */ boolean$1(),
			_null(),
			/* @__PURE__ */ array(jsonSchema),
			/* @__PURE__ */ record(/* @__PURE__ */ string$1(), jsonSchema)
		]);
	});
	return jsonSchema;
}
const ZodMiniFunction = /* @__PURE__ */ $constructor("ZodMiniFunction", (inst, def) => {
	$ZodFunction.init(inst, def);
	ZodMiniType.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function _function(params) {
	return new ZodMiniFunction({
		type: "function",
		input: Array.isArray(params?.input) ? /* @__PURE__ */ tuple(params?.input) : params?.input ?? /* @__PURE__ */ array(/* @__PURE__ */ unknown()),
		output: params?.output ?? /* @__PURE__ */ unknown()
	});
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/mini/iso.js
var iso_exports = /* @__PURE__ */ __exportAll({
	ZodMiniISODate: () => ZodMiniISODate,
	ZodMiniISODateTime: () => ZodMiniISODateTime,
	ZodMiniISODuration: () => ZodMiniISODuration,
	ZodMiniISOTime: () => ZodMiniISOTime,
	date: () => date$1,
	datetime: () => datetime,
	duration: () => duration,
	time: () => time
});
const ZodMiniISODateTime = /* @__PURE__ */ $constructor("ZodMiniISODateTime", (inst, def) => {
	$ZodISODateTime.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function datetime(params) {
	return _isoDateTime(ZodMiniISODateTime, params);
}
const ZodMiniISODate = /* @__PURE__ */ $constructor("ZodMiniISODate", (inst, def) => {
	$ZodISODate.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function date$1(params) {
	return _isoDate(ZodMiniISODate, params);
}
const ZodMiniISOTime = /* @__PURE__ */ $constructor("ZodMiniISOTime", (inst, def) => {
	$ZodISOTime.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function time(params) {
	return _isoTime(ZodMiniISOTime, params);
}
const ZodMiniISODuration = /* @__PURE__ */ $constructor("ZodMiniISODuration", (inst, def) => {
	$ZodISODuration.init(inst, def);
	ZodMiniStringFormat.init(inst, def);
});
/* @__NO_SIDE_EFFECTS__ */
function duration(params) {
	return _isoDuration(ZodMiniISODuration, params);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/mini/coerce.js
var coerce_exports = /* @__PURE__ */ __exportAll({
	bigint: () => bigint,
	boolean: () => boolean,
	date: () => date,
	number: () => number,
	string: () => string
});
/* @__NO_SIDE_EFFECTS__ */
function string(params) {
	return _coercedString(ZodMiniString, params);
}
/* @__NO_SIDE_EFFECTS__ */
function number(params) {
	return _coercedNumber(ZodMiniNumber, params);
}
/* @__NO_SIDE_EFFECTS__ */
function boolean(params) {
	return _coercedBoolean(ZodMiniBoolean, params);
}
/* @__NO_SIDE_EFFECTS__ */
function bigint(params) {
	return _coercedBigint(ZodMiniBigInt, params);
}
/* @__NO_SIDE_EFFECTS__ */
function date(params) {
	return _coercedDate(ZodMiniDate, params);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod/v4/mini/external.js
var external_exports = /* @__PURE__ */ __exportAll({
	$brand: () => $brand,
	$input: () => $input,
	$output: () => $output,
	NEVER: () => NEVER$1,
	TimePrecision: () => TimePrecision,
	ZodMiniAny: () => ZodMiniAny,
	ZodMiniArray: () => ZodMiniArray,
	ZodMiniBase64: () => ZodMiniBase64,
	ZodMiniBase64URL: () => ZodMiniBase64URL,
	ZodMiniBigInt: () => ZodMiniBigInt,
	ZodMiniBigIntFormat: () => ZodMiniBigIntFormat,
	ZodMiniBoolean: () => ZodMiniBoolean,
	ZodMiniCIDRv4: () => ZodMiniCIDRv4,
	ZodMiniCIDRv6: () => ZodMiniCIDRv6,
	ZodMiniCUID: () => ZodMiniCUID,
	ZodMiniCUID2: () => ZodMiniCUID2,
	ZodMiniCatch: () => ZodMiniCatch,
	ZodMiniCodec: () => ZodMiniCodec,
	ZodMiniCustom: () => ZodMiniCustom,
	ZodMiniCustomStringFormat: () => ZodMiniCustomStringFormat,
	ZodMiniDate: () => ZodMiniDate,
	ZodMiniDefault: () => ZodMiniDefault,
	ZodMiniDiscriminatedUnion: () => ZodMiniDiscriminatedUnion,
	ZodMiniE164: () => ZodMiniE164,
	ZodMiniEmail: () => ZodMiniEmail,
	ZodMiniEmoji: () => ZodMiniEmoji,
	ZodMiniEnum: () => ZodMiniEnum,
	ZodMiniExactOptional: () => ZodMiniExactOptional,
	ZodMiniFile: () => ZodMiniFile,
	ZodMiniFunction: () => ZodMiniFunction,
	ZodMiniGUID: () => ZodMiniGUID,
	ZodMiniIPv4: () => ZodMiniIPv4,
	ZodMiniIPv6: () => ZodMiniIPv6,
	ZodMiniISODate: () => ZodMiniISODate,
	ZodMiniISODateTime: () => ZodMiniISODateTime,
	ZodMiniISODuration: () => ZodMiniISODuration,
	ZodMiniISOTime: () => ZodMiniISOTime,
	ZodMiniIntersection: () => ZodMiniIntersection,
	ZodMiniJWT: () => ZodMiniJWT,
	ZodMiniKSUID: () => ZodMiniKSUID,
	ZodMiniLazy: () => ZodMiniLazy,
	ZodMiniLiteral: () => ZodMiniLiteral,
	ZodMiniMAC: () => ZodMiniMAC,
	ZodMiniMap: () => ZodMiniMap,
	ZodMiniNaN: () => ZodMiniNaN,
	ZodMiniNanoID: () => ZodMiniNanoID,
	ZodMiniNever: () => ZodMiniNever,
	ZodMiniNonOptional: () => ZodMiniNonOptional,
	ZodMiniNull: () => ZodMiniNull,
	ZodMiniNullable: () => ZodMiniNullable,
	ZodMiniNumber: () => ZodMiniNumber,
	ZodMiniNumberFormat: () => ZodMiniNumberFormat,
	ZodMiniObject: () => ZodMiniObject,
	ZodMiniOptional: () => ZodMiniOptional,
	ZodMiniPipe: () => ZodMiniPipe,
	ZodMiniPrefault: () => ZodMiniPrefault,
	ZodMiniPromise: () => ZodMiniPromise,
	ZodMiniReadonly: () => ZodMiniReadonly,
	ZodMiniRecord: () => ZodMiniRecord,
	ZodMiniSet: () => ZodMiniSet,
	ZodMiniString: () => ZodMiniString,
	ZodMiniStringFormat: () => ZodMiniStringFormat,
	ZodMiniSuccess: () => ZodMiniSuccess,
	ZodMiniSymbol: () => ZodMiniSymbol,
	ZodMiniTemplateLiteral: () => ZodMiniTemplateLiteral,
	ZodMiniTransform: () => ZodMiniTransform,
	ZodMiniTuple: () => ZodMiniTuple,
	ZodMiniType: () => ZodMiniType,
	ZodMiniULID: () => ZodMiniULID,
	ZodMiniURL: () => ZodMiniURL,
	ZodMiniUUID: () => ZodMiniUUID,
	ZodMiniUndefined: () => ZodMiniUndefined,
	ZodMiniUnion: () => ZodMiniUnion,
	ZodMiniUnknown: () => ZodMiniUnknown,
	ZodMiniVoid: () => ZodMiniVoid,
	ZodMiniXID: () => ZodMiniXID,
	ZodMiniXor: () => ZodMiniXor,
	_default: () => _default,
	_function: () => _function,
	any: () => any,
	array: () => array,
	base64: () => base64,
	base64url: () => base64url,
	bigint: () => bigint$1,
	boolean: () => boolean$1,
	catch: () => _catch,
	catchall: () => catchall,
	check: () => check,
	cidrv4: () => cidrv4,
	cidrv6: () => cidrv6,
	clone: () => clone,
	codec: () => codec,
	coerce: () => coerce_exports,
	config: () => config,
	core: () => core_exports,
	cuid: () => cuid,
	cuid2: () => cuid2,
	custom: () => custom,
	date: () => date$2,
	decode: () => decode$1,
	decodeAsync: () => decodeAsync$1,
	describe: () => describe,
	discriminatedUnion: () => discriminatedUnion,
	e164: () => e164,
	email: () => email,
	emoji: () => emoji,
	encode: () => encode$1,
	encodeAsync: () => encodeAsync$1,
	endsWith: () => _endsWith,
	enum: () => _enum,
	exactOptional: () => exactOptional,
	extend: () => extend,
	file: () => file,
	flattenError: () => flattenError$1,
	float32: () => float32,
	float64: () => float64,
	formatError: () => formatError,
	function: () => _function,
	globalRegistry: () => globalRegistry,
	gt: () => _gt,
	gte: () => _gte,
	guid: () => guid,
	hash: () => hash,
	hex: () => hex,
	hostname: () => hostname,
	httpUrl: () => httpUrl,
	includes: () => _includes,
	instanceof: () => _instanceof,
	int: () => int,
	int32: () => int32,
	int64: () => int64,
	intersection: () => intersection,
	ipv4: () => ipv4,
	ipv6: () => ipv6,
	iso: () => iso_exports,
	json: () => json,
	jwt: () => jwt,
	keyof: () => keyof,
	ksuid: () => ksuid,
	lazy: () => _lazy,
	length: () => _length,
	literal: () => literal,
	locales: () => locales_exports,
	looseObject: () => looseObject,
	looseRecord: () => looseRecord,
	lowercase: () => _lowercase,
	lt: () => _lt,
	lte: () => _lte,
	mac: () => mac,
	map: () => map,
	maxLength: () => _maxLength,
	maxSize: () => _maxSize,
	maximum: () => _lte,
	merge: () => merge,
	meta: () => meta,
	mime: () => _mime,
	minLength: () => _minLength,
	minSize: () => _minSize,
	minimum: () => _gte,
	multipleOf: () => _multipleOf,
	nan: () => nan,
	nanoid: () => nanoid,
	nativeEnum: () => nativeEnum,
	negative: () => _negative,
	never: () => never,
	nonnegative: () => _nonnegative,
	nonoptional: () => nonoptional,
	nonpositive: () => _nonpositive,
	normalize: () => _normalize,
	null: () => _null,
	nullable: () => nullable,
	nullish: () => nullish,
	number: () => number$1,
	object: () => object,
	omit: () => omit,
	optional: () => optional,
	overwrite: () => _overwrite,
	parse: () => parse$3,
	parseAsync: () => parseAsync$1,
	partial: () => partial,
	partialRecord: () => partialRecord,
	pick: () => pick,
	pipe: () => pipe,
	positive: () => _positive,
	prefault: () => prefault,
	prettifyError: () => prettifyError,
	promise: () => promise,
	property: () => _property,
	readonly: () => readonly,
	record: () => record,
	refine: () => refine,
	regex: () => _regex,
	regexes: () => regexes_exports,
	registry: () => registry,
	required: () => required,
	safeDecode: () => safeDecode$1,
	safeDecodeAsync: () => safeDecodeAsync$1,
	safeEncode: () => safeEncode$1,
	safeEncodeAsync: () => safeEncodeAsync$1,
	safeExtend: () => safeExtend,
	safeParse: () => safeParse$2,
	safeParseAsync: () => safeParseAsync$2,
	set: () => set,
	size: () => _size,
	startsWith: () => _startsWith,
	strictObject: () => strictObject,
	string: () => string$1,
	stringFormat: () => stringFormat,
	stringbool: () => stringbool,
	success: () => success,
	superRefine: () => superRefine,
	symbol: () => symbol,
	templateLiteral: () => templateLiteral,
	toJSONSchema: () => toJSONSchema,
	toLowerCase: () => _toLowerCase,
	toUpperCase: () => _toUpperCase,
	transform: () => transform,
	treeifyError: () => treeifyError,
	trim: () => _trim,
	tuple: () => tuple,
	uint32: () => uint32,
	uint64: () => uint64,
	ulid: () => ulid,
	undefined: () => _undefined,
	union: () => union,
	unknown: () => unknown,
	uppercase: () => _uppercase,
	url: () => url,
	util: () => util_exports,
	uuid: () => uuid,
	uuidv4: () => uuidv4,
	uuidv6: () => uuidv6,
	uuidv7: () => uuidv7,
	void: () => _void,
	xid: () => xid,
	xor: () => xor
});

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
	const schema = s;
	return !!schema._zod;
}
function objectFromShape(shape) {
	const values = Object.values(shape);
	if (values.length === 0) return object({});
	const allV4 = values.every(isZ4Schema);
	const allV3 = values.every((s) => !isZ4Schema(s));
	if (allV4) return object(shape);
	if (allV3) return objectType(shape);
	throw new Error("Mixed Zod versions detected in object shape.");
}
function safeParse(schema, data) {
	if (isZ4Schema(schema)) {
		const result$1 = safeParse$2(schema, data);
		return result$1;
	}
	const v3Schema = schema;
	const result = v3Schema.safeParse(data);
	return result;
}
async function safeParseAsync(schema, data) {
	if (isZ4Schema(schema)) {
		const result$1 = await safeParseAsync$2(schema, data);
		return result$1;
	}
	const v3Schema = schema;
	const result = await v3Schema.safeParseAsync(data);
	return result;
}
function getObjectShape(schema) {
	if (!schema) return undefined;
	let rawShape;
	if (isZ4Schema(schema)) {
		const v4Schema = schema;
		rawShape = v4Schema._zod?.def?.shape;
	} else {
		const v3Schema = schema;
		rawShape = v3Schema.shape;
	}
	if (!rawShape) return undefined;
	if (typeof rawShape === "function") {
		try {
			return rawShape();
		} catch {
			return undefined;
		}
	}
	return rawShape;
}
/**
* Normalizes a schema to an object schema. Handles both:
* - Already-constructed object schemas (v3 or v4)
* - Raw shapes that need to be wrapped into object schemas
*/
function normalizeObjectSchema(schema) {
	if (!schema) return undefined;
	if (typeof schema === "object") {
		const asV3 = schema;
		const asV4 = schema;
		if (!asV3._def && !asV4._zod) {
			const values = Object.values(schema);
			if (values.length > 0 && values.every((v) => typeof v === "object" && v !== null && (v._def !== undefined || v._zod !== undefined || typeof v.parse === "function"))) {
				return objectFromShape(schema);
			}
		}
	}
	if (isZ4Schema(schema)) {
		const v4Schema = schema;
		const def = v4Schema._zod?.def;
		if (def && (def.type === "object" || def.shape !== undefined)) {
			return schema;
		}
	} else {
		const v3Schema = schema;
		if (v3Schema.shape !== undefined) {
			return schema;
		}
	}
	return undefined;
}
/**
* Safely extracts an error message from a parse result error.
* Zod errors can have different structures, so we handle various cases.
*/
function getParseErrorMessage(error$47) {
	if (error$47 && typeof error$47 === "object") {
		if ("message" in error$47 && typeof error$47.message === "string") {
			return error$47.message;
		}
		if ("issues" in error$47 && Array.isArray(error$47.issues) && error$47.issues.length > 0) {
			const firstIssue = error$47.issues[0];
			if (firstIssue && typeof firstIssue === "object" && "message" in firstIssue) {
				return String(firstIssue.message);
			}
		}
		try {
			return JSON.stringify(error$47);
		} catch {
			return String(error$47);
		}
	}
	return String(error$47);
}
/**
* Gets the description from a schema, if available.
* Works with both Zod v3 and v4.
*
* Both versions expose a `.description` getter that returns the description
* from their respective internal storage (v3: _def, v4: globalRegistry).
*/
function getSchemaDescription(schema) {
	return schema.description;
}
/**
* Checks if a schema is optional.
* Works with both Zod v3 and v4.
*/
function isSchemaOptional(schema) {
	if (isZ4Schema(schema)) {
		const v4Schema = schema;
		return v4Schema._zod?.def?.type === "optional";
	}
	const v3Schema = schema;
	if (typeof schema.isOptional === "function") {
		return schema.isOptional();
	}
	return v3Schema._def?.typeName === "ZodOptional";
}
/**
* Gets the literal value from a schema, if it's a literal schema.
* Works with both Zod v3 and v4.
* Returns undefined if the schema is not a literal or the value cannot be determined.
*/
function getLiteralValue(schema) {
	if (isZ4Schema(schema)) {
		const v4Schema = schema;
		const def$1 = v4Schema._zod?.def;
		if (def$1) {
			if (def$1.value !== undefined) return def$1.value;
			if (Array.isArray(def$1.values) && def$1.values.length > 0) {
				return def$1.values[0];
			}
		}
	}
	const v3Schema = schema;
	const def = v3Schema._def;
	if (def) {
		if (def.value !== undefined) return def.value;
		if (Array.isArray(def.values) && def.values.length > 0) {
			return def.values[0];
		}
	}
	const directValue = schema.value;
	if (directValue !== undefined) return directValue;
	return undefined;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
/**
* Experimental task interfaces for MCP SDK.
* WARNING: These APIs are experimental and may change without notice.
*/
/**
* Checks if a task status represents a terminal state.
* Terminal states are those where the task has finished and will not change.
*
* @param status - The task status to check
* @returns True if the status is terminal (completed, failed, or cancelled)
* @experimental
*/
function isTerminal(status) {
	return status === "completed" || status === "failed" || status === "cancelled";
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/Options.js
const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const jsonDescription = (jsonSchema, def) => {
	if (def.description) {
		try {
			return {
				...jsonSchema,
				...JSON.parse(def.description)
			};
		} catch {}
	}
	return jsonSchema;
};
const defaultOptions = {
	name: undefined,
	$refStrategy: "root",
	basePath: ["#"],
	effectStrategy: "input",
	pipeStrategy: "all",
	dateStrategy: "format:date-time",
	mapStrategy: "entries",
	removeAdditionalStrategy: "passthrough",
	allowedAdditionalProperties: true,
	rejectedAdditionalProperties: false,
	definitionPath: "definitions",
	target: "jsonSchema7",
	strictUnions: false,
	definitions: {},
	errorMessages: false,
	markdownDescription: false,
	patternStrategy: "escape",
	applyRegexFlags: false,
	emailStrategy: "format:email",
	base64Strategy: "contentEncoding:base64",
	nameStrategy: "ref",
	openAiAnyTypeName: "OpenAiAnyType"
};
const getDefaultOptions = (options) => typeof options === "string" ? {
	...defaultOptions,
	name: options
} : {
	...defaultOptions,
	...options
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/Refs.js
const getRefs = (options) => {
	const _options = getDefaultOptions(options);
	const currentPath = _options.name !== undefined ? [
		..._options.basePath,
		_options.definitionPath,
		_options.name
	] : _options.basePath;
	return {
		..._options,
		flags: { hasReferencedOpenAiAnyType: false },
		currentPath,
		propertyPath: undefined,
		seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [def._def, {
			def: def._def,
			path: [
				..._options.basePath,
				_options.definitionPath,
				name
			],
			jsonSchema: undefined
		}]))
	};
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
	if (!refs?.errorMessages) return;
	if (errorMessage) {
		res.errorMessage = {
			...res.errorMessage,
			[key]: errorMessage
		};
	}
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
	res[key] = value;
	addErrorMessage(res, key, errorMessage, refs);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
const getRelativePath = (pathA, pathB) => {
	let i = 0;
	for (; i < pathA.length && i < pathB.length; i++) {
		if (pathA[i] !== pathB[i]) break;
	}
	return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
	if (refs.target !== "openAi") {
		return {};
	}
	const anyDefinitionPath = [
		...refs.basePath,
		refs.definitionPath,
		refs.openAiAnyTypeName
	];
	refs.flags.hasReferencedOpenAiAnyType = true;
	return { $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/") };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
	const res = { type: "array" };
	if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
		res.items = parseDef(def.type._def, {
			...refs,
			currentPath: [...refs.currentPath, "items"]
		});
	}
	if (def.minLength) {
		setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
	}
	if (def.maxLength) {
		setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
	}
	if (def.exactLength) {
		setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
		setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
	}
	return res;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
	const res = {
		type: "integer",
		format: "int64"
	};
	if (!def.checks) return res;
	for (const check$2 of def.checks) {
		switch (check$2.kind) {
			case "min":
				if (refs.target === "jsonSchema7") {
					if (check$2.inclusive) {
						setResponseValueAndErrors(res, "minimum", check$2.value, check$2.message, refs);
					} else {
						setResponseValueAndErrors(res, "exclusiveMinimum", check$2.value, check$2.message, refs);
					}
				} else {
					if (!check$2.inclusive) {
						res.exclusiveMinimum = true;
					}
					setResponseValueAndErrors(res, "minimum", check$2.value, check$2.message, refs);
				}
				break;
			case "max":
				if (refs.target === "jsonSchema7") {
					if (check$2.inclusive) {
						setResponseValueAndErrors(res, "maximum", check$2.value, check$2.message, refs);
					} else {
						setResponseValueAndErrors(res, "exclusiveMaximum", check$2.value, check$2.message, refs);
					}
				} else {
					if (!check$2.inclusive) {
						res.exclusiveMaximum = true;
					}
					setResponseValueAndErrors(res, "maximum", check$2.value, check$2.message, refs);
				}
				break;
			case "multipleOf":
				setResponseValueAndErrors(res, "multipleOf", check$2.value, check$2.message, refs);
				break;
		}
	}
	return res;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
	return { type: "boolean" };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
	return parseDef(_def.type._def, refs);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
const parseCatchDef = (def, refs) => {
	return parseDef(def.innerType._def, refs);
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
	const strategy = overrideDateStrategy ?? refs.dateStrategy;
	if (Array.isArray(strategy)) {
		return { anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)) };
	}
	switch (strategy) {
		case "string":
		case "format:date-time": return {
			type: "string",
			format: "date-time"
		};
		case "format:date": return {
			type: "string",
			format: "date"
		};
		case "integer": return integerDateParser(def, refs);
	}
}
const integerDateParser = (def, refs) => {
	const res = {
		type: "integer",
		format: "unix-time"
	};
	if (refs.target === "openApi3") {
		return res;
	}
	for (const check$2 of def.checks) {
		switch (check$2.kind) {
			case "min":
				setResponseValueAndErrors(res, "minimum", check$2.value, check$2.message, refs);
				break;
			case "max":
				setResponseValueAndErrors(res, "maximum", check$2.value, check$2.message, refs);
				break;
		}
	}
	return res;
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
	return {
		...parseDef(_def.innerType._def, refs),
		default: _def.defaultValue()
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
	return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
	return {
		type: "string",
		enum: Array.from(def.values)
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
const isJsonSchema7AllOfType = (type) => {
	if ("type" in type && type.type === "string") return false;
	return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
	const allOf = [parseDef(def.left._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			"0"
		]
	}), parseDef(def.right._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			"1"
		]
	})].filter((x) => !!x);
	let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : undefined;
	const mergedAllOf = [];
	allOf.forEach((schema) => {
		if (isJsonSchema7AllOfType(schema)) {
			mergedAllOf.push(...schema.allOf);
			if (schema.unevaluatedProperties === undefined) {
				unevaluatedProperties = undefined;
			}
		} else {
			let nestedSchema = schema;
			if ("additionalProperties" in schema && schema.additionalProperties === false) {
				const { additionalProperties, ...rest } = schema;
				nestedSchema = rest;
			} else {
				unevaluatedProperties = undefined;
			}
			mergedAllOf.push(nestedSchema);
		}
	});
	return mergedAllOf.length ? {
		allOf: mergedAllOf,
		...unevaluatedProperties
	} : undefined;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
	const parsedType$1 = typeof def.value;
	if (parsedType$1 !== "bigint" && parsedType$1 !== "number" && parsedType$1 !== "boolean" && parsedType$1 !== "string") {
		return { type: Array.isArray(def.value) ? "array" : "object" };
	}
	if (refs.target === "openApi3") {
		return {
			type: parsedType$1 === "bigint" ? "integer" : parsedType$1,
			enum: [def.value]
		};
	}
	return {
		type: parsedType$1 === "bigint" ? "integer" : parsedType$1,
		const: def.value
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
let emojiRegex = undefined;
/**
* Generated from the regular expressions found here as of 2024-05-22:
* https://github.com/colinhacks/zod/blob/master/src/types.ts.
*
* Expressions with /i flag have been changed accordingly.
*/
const zodPatterns = {
	cuid: /^[cC][^\s-]{8,}$/,
	cuid2: /^[0-9a-z]+$/,
	ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
	email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
	emoji: () => {
		if (emojiRegex === undefined) {
			emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
		}
		return emojiRegex;
	},
	uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
	ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
	ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
	ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
	ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
	base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
	base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
	nanoid: /^[a-zA-Z0-9_-]{21}$/,
	jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
	const res = { type: "string" };
	if (def.checks) {
		for (const check$2 of def.checks) {
			switch (check$2.kind) {
				case "min":
					setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check$2.value) : check$2.value, check$2.message, refs);
					break;
				case "max":
					setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check$2.value) : check$2.value, check$2.message, refs);
					break;
				case "email":
					switch (refs.emailStrategy) {
						case "format:email":
							addFormat(res, "email", check$2.message, refs);
							break;
						case "format:idn-email":
							addFormat(res, "idn-email", check$2.message, refs);
							break;
						case "pattern:zod":
							addPattern(res, zodPatterns.email, check$2.message, refs);
							break;
					}
					break;
				case "url":
					addFormat(res, "uri", check$2.message, refs);
					break;
				case "uuid":
					addFormat(res, "uuid", check$2.message, refs);
					break;
				case "regex":
					addPattern(res, check$2.regex, check$2.message, refs);
					break;
				case "cuid":
					addPattern(res, zodPatterns.cuid, check$2.message, refs);
					break;
				case "cuid2":
					addPattern(res, zodPatterns.cuid2, check$2.message, refs);
					break;
				case "startsWith":
					addPattern(res, RegExp(`^${escapeLiteralCheckValue(check$2.value, refs)}`), check$2.message, refs);
					break;
				case "endsWith":
					addPattern(res, RegExp(`${escapeLiteralCheckValue(check$2.value, refs)}$`), check$2.message, refs);
					break;
				case "datetime":
					addFormat(res, "date-time", check$2.message, refs);
					break;
				case "date":
					addFormat(res, "date", check$2.message, refs);
					break;
				case "time":
					addFormat(res, "time", check$2.message, refs);
					break;
				case "duration":
					addFormat(res, "duration", check$2.message, refs);
					break;
				case "length":
					setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check$2.value) : check$2.value, check$2.message, refs);
					setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check$2.value) : check$2.value, check$2.message, refs);
					break;
				case "includes": {
					addPattern(res, RegExp(escapeLiteralCheckValue(check$2.value, refs)), check$2.message, refs);
					break;
				}
				case "ip": {
					if (check$2.version !== "v6") {
						addFormat(res, "ipv4", check$2.message, refs);
					}
					if (check$2.version !== "v4") {
						addFormat(res, "ipv6", check$2.message, refs);
					}
					break;
				}
				case "base64url":
					addPattern(res, zodPatterns.base64url, check$2.message, refs);
					break;
				case "jwt":
					addPattern(res, zodPatterns.jwt, check$2.message, refs);
					break;
				case "cidr": {
					if (check$2.version !== "v6") {
						addPattern(res, zodPatterns.ipv4Cidr, check$2.message, refs);
					}
					if (check$2.version !== "v4") {
						addPattern(res, zodPatterns.ipv6Cidr, check$2.message, refs);
					}
					break;
				}
				case "emoji":
					addPattern(res, zodPatterns.emoji(), check$2.message, refs);
					break;
				case "ulid": {
					addPattern(res, zodPatterns.ulid, check$2.message, refs);
					break;
				}
				case "base64": {
					switch (refs.base64Strategy) {
						case "format:binary": {
							addFormat(res, "binary", check$2.message, refs);
							break;
						}
						case "contentEncoding:base64": {
							setResponseValueAndErrors(res, "contentEncoding", "base64", check$2.message, refs);
							break;
						}
						case "pattern:zod": {
							addPattern(res, zodPatterns.base64, check$2.message, refs);
							break;
						}
					}
					break;
				}
				case "nanoid": {
					addPattern(res, zodPatterns.nanoid, check$2.message, refs);
				}
				case "toLowerCase":
				case "toUpperCase":
				case "trim": break;
				default: ((_) => {})(check$2);
			}
		}
	}
	return res;
}
function escapeLiteralCheckValue(literal$2, refs) {
	return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal$2) : literal$2;
}
const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
	let result = "";
	for (let i = 0; i < source.length; i++) {
		if (!ALPHA_NUMERIC.has(source[i])) {
			result += "\\";
		}
		result += source[i];
	}
	return result;
}
function addFormat(schema, value, message, refs) {
	if (schema.format || schema.anyOf?.some((x) => x.format)) {
		if (!schema.anyOf) {
			schema.anyOf = [];
		}
		if (schema.format) {
			schema.anyOf.push({
				format: schema.format,
				...schema.errorMessage && refs.errorMessages && { errorMessage: { format: schema.errorMessage.format } }
			});
			delete schema.format;
			if (schema.errorMessage) {
				delete schema.errorMessage.format;
				if (Object.keys(schema.errorMessage).length === 0) {
					delete schema.errorMessage;
				}
			}
		}
		schema.anyOf.push({
			format: value,
			...message && refs.errorMessages && { errorMessage: { format: message } }
		});
	} else {
		setResponseValueAndErrors(schema, "format", value, message, refs);
	}
}
function addPattern(schema, regex, message, refs) {
	if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
		if (!schema.allOf) {
			schema.allOf = [];
		}
		if (schema.pattern) {
			schema.allOf.push({
				pattern: schema.pattern,
				...schema.errorMessage && refs.errorMessages && { errorMessage: { pattern: schema.errorMessage.pattern } }
			});
			delete schema.pattern;
			if (schema.errorMessage) {
				delete schema.errorMessage.pattern;
				if (Object.keys(schema.errorMessage).length === 0) {
					delete schema.errorMessage;
				}
			}
		}
		schema.allOf.push({
			pattern: stringifyRegExpWithFlags(regex, refs),
			...message && refs.errorMessages && { errorMessage: { pattern: message } }
		});
	} else {
		setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
	}
}
function stringifyRegExpWithFlags(regex, refs) {
	if (!refs.applyRegexFlags || !regex.flags) {
		return regex.source;
	}
	const flags = {
		i: regex.flags.includes("i"),
		m: regex.flags.includes("m"),
		s: regex.flags.includes("s")
	};
	const source = flags.i ? regex.source.toLowerCase() : regex.source;
	let pattern = "";
	let isEscaped = false;
	let inCharGroup = false;
	let inCharRange = false;
	for (let i = 0; i < source.length; i++) {
		if (isEscaped) {
			pattern += source[i];
			isEscaped = false;
			continue;
		}
		if (flags.i) {
			if (inCharGroup) {
				if (source[i].match(/[a-z]/)) {
					if (inCharRange) {
						pattern += source[i];
						pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
						inCharRange = false;
					} else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
						pattern += source[i];
						inCharRange = true;
					} else {
						pattern += `${source[i]}${source[i].toUpperCase()}`;
					}
					continue;
				}
			} else if (source[i].match(/[a-z]/)) {
				pattern += `[${source[i]}${source[i].toUpperCase()}]`;
				continue;
			}
		}
		if (flags.m) {
			if (source[i] === "^") {
				pattern += `(^|(?<=[\r\n]))`;
				continue;
			} else if (source[i] === "$") {
				pattern += `($|(?=[\r\n]))`;
				continue;
			}
		}
		if (flags.s && source[i] === ".") {
			pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
			continue;
		}
		pattern += source[i];
		if (source[i] === "\\") {
			isEscaped = true;
		} else if (inCharGroup && source[i] === "]") {
			inCharGroup = false;
		} else if (!inCharGroup && source[i] === "[") {
			inCharGroup = true;
		}
	}
	try {
		new RegExp(pattern);
	} catch {
		console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
		return regex.source;
	}
	return pattern;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
	if (refs.target === "openAi") {
		console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
	}
	if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
		return {
			type: "object",
			required: def.keyType._def.values,
			properties: def.keyType._def.values.reduce((acc, key) => ({
				...acc,
				[key]: parseDef(def.valueType._def, {
					...refs,
					currentPath: [
						...refs.currentPath,
						"properties",
						key
					]
				}) ?? parseAnyDef(refs)
			}), {}),
			additionalProperties: refs.rejectedAdditionalProperties
		};
	}
	const schema = {
		type: "object",
		additionalProperties: parseDef(def.valueType._def, {
			...refs,
			currentPath: [...refs.currentPath, "additionalProperties"]
		}) ?? refs.allowedAdditionalProperties
	};
	if (refs.target === "openApi3") {
		return schema;
	}
	if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
		const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
		return {
			...schema,
			propertyNames: keyType
		};
	} else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
		return {
			...schema,
			propertyNames: { enum: def.keyType._def.values }
		};
	} else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
		const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
		return {
			...schema,
			propertyNames: keyType
		};
	}
	return schema;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
	if (refs.mapStrategy === "record") {
		return parseRecordDef(def, refs);
	}
	const keys = parseDef(def.keyType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"items",
			"items",
			"0"
		]
	}) || parseAnyDef(refs);
	const values = parseDef(def.valueType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"items",
			"items",
			"1"
		]
	}) || parseAnyDef(refs);
	return {
		type: "array",
		maxItems: 125,
		items: {
			type: "array",
			items: [keys, values],
			minItems: 2,
			maxItems: 2
		}
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
	const object$2 = def.values;
	const actualKeys = Object.keys(def.values).filter((key) => {
		return typeof object$2[object$2[key]] !== "number";
	});
	const actualValues = actualKeys.map((key) => object$2[key]);
	const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
	return {
		type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
		enum: actualValues
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
	return refs.target === "openAi" ? undefined : { not: parseAnyDef({
		...refs,
		currentPath: [...refs.currentPath, "not"]
	}) };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
	return refs.target === "openApi3" ? {
		enum: ["null"],
		nullable: true
	} : { type: "null" };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/union.js
const primitiveMappings = {
	ZodString: "string",
	ZodNumber: "number",
	ZodBigInt: "integer",
	ZodBoolean: "boolean",
	ZodNull: "null"
};
function parseUnionDef(def, refs) {
	if (refs.target === "openApi3") return asAnyOf(def, refs);
	const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
	if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
		const types = options.reduce((types$1, x) => {
			const type = primitiveMappings[x._def.typeName];
			return type && !types$1.includes(type) ? [...types$1, type] : types$1;
		}, []);
		return { type: types.length > 1 ? types : types[0] };
	} else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
		const types = options.reduce((acc, x) => {
			const type = typeof x._def.value;
			switch (type) {
				case "string":
				case "number":
				case "boolean": return [...acc, type];
				case "bigint": return [...acc, "integer"];
				case "object": if (x._def.value === null) return [...acc, "null"];
				case "symbol":
				case "undefined":
				case "function":
				default: return acc;
			}
		}, []);
		if (types.length === options.length) {
			const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
			return {
				type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
				enum: options.reduce((acc, x) => {
					return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
				}, [])
			};
		}
	} else if (options.every((x) => x._def.typeName === "ZodEnum")) {
		return {
			type: "string",
			enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x$1) => !acc.includes(x$1))], [])
		};
	}
	return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
	const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"anyOf",
			`${i}`
		]
	})).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
	return anyOf.length ? { anyOf } : undefined;
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
	if ([
		"ZodString",
		"ZodNumber",
		"ZodBigInt",
		"ZodBoolean",
		"ZodNull"
	].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
		if (refs.target === "openApi3") {
			return {
				type: primitiveMappings[def.innerType._def.typeName],
				nullable: true
			};
		}
		return { type: [primitiveMappings[def.innerType._def.typeName], "null"] };
	}
	if (refs.target === "openApi3") {
		const base$1 = parseDef(def.innerType._def, {
			...refs,
			currentPath: [...refs.currentPath]
		});
		if (base$1 && "$ref" in base$1) return {
			allOf: [base$1],
			nullable: true
		};
		return base$1 && {
			...base$1,
			nullable: true
		};
	}
	const base = parseDef(def.innerType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"anyOf",
			"0"
		]
	});
	return base && { anyOf: [base, { type: "null" }] };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
	const res = { type: "number" };
	if (!def.checks) return res;
	for (const check$2 of def.checks) {
		switch (check$2.kind) {
			case "int":
				res.type = "integer";
				addErrorMessage(res, "type", check$2.message, refs);
				break;
			case "min":
				if (refs.target === "jsonSchema7") {
					if (check$2.inclusive) {
						setResponseValueAndErrors(res, "minimum", check$2.value, check$2.message, refs);
					} else {
						setResponseValueAndErrors(res, "exclusiveMinimum", check$2.value, check$2.message, refs);
					}
				} else {
					if (!check$2.inclusive) {
						res.exclusiveMinimum = true;
					}
					setResponseValueAndErrors(res, "minimum", check$2.value, check$2.message, refs);
				}
				break;
			case "max":
				if (refs.target === "jsonSchema7") {
					if (check$2.inclusive) {
						setResponseValueAndErrors(res, "maximum", check$2.value, check$2.message, refs);
					} else {
						setResponseValueAndErrors(res, "exclusiveMaximum", check$2.value, check$2.message, refs);
					}
				} else {
					if (!check$2.inclusive) {
						res.exclusiveMaximum = true;
					}
					setResponseValueAndErrors(res, "maximum", check$2.value, check$2.message, refs);
				}
				break;
			case "multipleOf":
				setResponseValueAndErrors(res, "multipleOf", check$2.value, check$2.message, refs);
				break;
		}
	}
	return res;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
	const forceOptionalIntoNullable = refs.target === "openAi";
	const result = {
		type: "object",
		properties: {}
	};
	const required$2 = [];
	const shape = def.shape();
	for (const propName in shape) {
		let propDef = shape[propName];
		if (propDef === undefined || propDef._def === undefined) {
			continue;
		}
		let propOptional = safeIsOptional(propDef);
		if (propOptional && forceOptionalIntoNullable) {
			if (propDef._def.typeName === "ZodOptional") {
				propDef = propDef._def.innerType;
			}
			if (!propDef.isNullable()) {
				propDef = propDef.nullable();
			}
			propOptional = false;
		}
		const parsedDef = parseDef(propDef._def, {
			...refs,
			currentPath: [
				...refs.currentPath,
				"properties",
				propName
			],
			propertyPath: [
				...refs.currentPath,
				"properties",
				propName
			]
		});
		if (parsedDef === undefined) {
			continue;
		}
		result.properties[propName] = parsedDef;
		if (!propOptional) {
			required$2.push(propName);
		}
	}
	if (required$2.length) {
		result.required = required$2;
	}
	const additionalProperties = decideAdditionalProperties(def, refs);
	if (additionalProperties !== undefined) {
		result.additionalProperties = additionalProperties;
	}
	return result;
}
function decideAdditionalProperties(def, refs) {
	if (def.catchall._def.typeName !== "ZodNever") {
		return parseDef(def.catchall._def, {
			...refs,
			currentPath: [...refs.currentPath, "additionalProperties"]
		});
	}
	switch (def.unknownKeys) {
		case "passthrough": return refs.allowedAdditionalProperties;
		case "strict": return refs.rejectedAdditionalProperties;
		case "strip": return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
	}
}
function safeIsOptional(schema) {
	try {
		return schema.isOptional();
	} catch {
		return true;
	}
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
const parseOptionalDef = (def, refs) => {
	if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
		return parseDef(def.innerType._def, refs);
	}
	const innerSchema = parseDef(def.innerType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"anyOf",
			"1"
		]
	});
	return innerSchema ? { anyOf: [{ not: parseAnyDef(refs) }, innerSchema] } : parseAnyDef(refs);
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
const parsePipelineDef = (def, refs) => {
	if (refs.pipeStrategy === "input") {
		return parseDef(def.in._def, refs);
	} else if (refs.pipeStrategy === "output") {
		return parseDef(def.out._def, refs);
	}
	const a = parseDef(def.in._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			"0"
		]
	});
	const b = parseDef(def.out._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			a ? "1" : "0"
		]
	});
	return { allOf: [a, b].filter((x) => x !== undefined) };
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
	return parseDef(def.type._def, refs);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
	const items = parseDef(def.valueType._def, {
		...refs,
		currentPath: [...refs.currentPath, "items"]
	});
	const schema = {
		type: "array",
		uniqueItems: true,
		items
	};
	if (def.minSize) {
		setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
	}
	if (def.maxSize) {
		setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
	}
	return schema;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
	if (def.rest) {
		return {
			type: "array",
			minItems: def.items.length,
			items: def.items.map((x, i) => parseDef(x._def, {
				...refs,
				currentPath: [
					...refs.currentPath,
					"items",
					`${i}`
				]
			})).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),
			additionalItems: parseDef(def.rest._def, {
				...refs,
				currentPath: [...refs.currentPath, "additionalItems"]
			})
		};
	} else {
		return {
			type: "array",
			minItems: def.items.length,
			maxItems: def.items.length,
			items: def.items.map((x, i) => parseDef(x._def, {
				...refs,
				currentPath: [
					...refs.currentPath,
					"items",
					`${i}`
				]
			})).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])
		};
	}
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
	return { not: parseAnyDef(refs) };
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
	return parseAnyDef(refs);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
const parseReadonlyDef = (def, refs) => {
	return parseDef(def.innerType._def, refs);
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/selectParser.js
const selectParser = (def, typeName, refs) => {
	switch (typeName) {
		case ZodFirstPartyTypeKind.ZodString: return parseStringDef(def, refs);
		case ZodFirstPartyTypeKind.ZodNumber: return parseNumberDef(def, refs);
		case ZodFirstPartyTypeKind.ZodObject: return parseObjectDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBigInt: return parseBigintDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBoolean: return parseBooleanDef();
		case ZodFirstPartyTypeKind.ZodDate: return parseDateDef(def, refs);
		case ZodFirstPartyTypeKind.ZodUndefined: return parseUndefinedDef(refs);
		case ZodFirstPartyTypeKind.ZodNull: return parseNullDef(refs);
		case ZodFirstPartyTypeKind.ZodArray: return parseArrayDef(def, refs);
		case ZodFirstPartyTypeKind.ZodUnion:
		case ZodFirstPartyTypeKind.ZodDiscriminatedUnion: return parseUnionDef(def, refs);
		case ZodFirstPartyTypeKind.ZodIntersection: return parseIntersectionDef(def, refs);
		case ZodFirstPartyTypeKind.ZodTuple: return parseTupleDef(def, refs);
		case ZodFirstPartyTypeKind.ZodRecord: return parseRecordDef(def, refs);
		case ZodFirstPartyTypeKind.ZodLiteral: return parseLiteralDef(def, refs);
		case ZodFirstPartyTypeKind.ZodEnum: return parseEnumDef(def);
		case ZodFirstPartyTypeKind.ZodNativeEnum: return parseNativeEnumDef(def);
		case ZodFirstPartyTypeKind.ZodNullable: return parseNullableDef(def, refs);
		case ZodFirstPartyTypeKind.ZodOptional: return parseOptionalDef(def, refs);
		case ZodFirstPartyTypeKind.ZodMap: return parseMapDef(def, refs);
		case ZodFirstPartyTypeKind.ZodSet: return parseSetDef(def, refs);
		case ZodFirstPartyTypeKind.ZodLazy: return () => def.getter()._def;
		case ZodFirstPartyTypeKind.ZodPromise: return parsePromiseDef(def, refs);
		case ZodFirstPartyTypeKind.ZodNaN:
		case ZodFirstPartyTypeKind.ZodNever: return parseNeverDef(refs);
		case ZodFirstPartyTypeKind.ZodEffects: return parseEffectsDef(def, refs);
		case ZodFirstPartyTypeKind.ZodAny: return parseAnyDef(refs);
		case ZodFirstPartyTypeKind.ZodUnknown: return parseUnknownDef(refs);
		case ZodFirstPartyTypeKind.ZodDefault: return parseDefaultDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBranded: return parseBrandedDef(def, refs);
		case ZodFirstPartyTypeKind.ZodReadonly: return parseReadonlyDef(def, refs);
		case ZodFirstPartyTypeKind.ZodCatch: return parseCatchDef(def, refs);
		case ZodFirstPartyTypeKind.ZodPipeline: return parsePipelineDef(def, refs);
		case ZodFirstPartyTypeKind.ZodFunction:
		case ZodFirstPartyTypeKind.ZodVoid:
		case ZodFirstPartyTypeKind.ZodSymbol: return undefined;
		default: return ((_) => undefined)(typeName);
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
	const seenItem = refs.seen.get(def);
	if (refs.override) {
		const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
		if (overrideResult !== ignoreOverride) {
			return overrideResult;
		}
	}
	if (seenItem && !forceResolution) {
		const seenSchema = get$ref(seenItem, refs);
		if (seenSchema !== undefined) {
			return seenSchema;
		}
	}
	const newItem = {
		def,
		path: refs.currentPath,
		jsonSchema: undefined
	};
	refs.seen.set(def, newItem);
	const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
	const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
	if (jsonSchema) {
		addMeta(def, refs, jsonSchema);
	}
	if (refs.postProcess) {
		const postProcessResult = refs.postProcess(jsonSchema, def, refs);
		newItem.jsonSchema = jsonSchema;
		return postProcessResult;
	}
	newItem.jsonSchema = jsonSchema;
	return jsonSchema;
}
const get$ref = (item, refs) => {
	switch (refs.$refStrategy) {
		case "root": return { $ref: item.path.join("/") };
		case "relative": return { $ref: getRelativePath(refs.currentPath, item.path) };
		case "none":
		case "seen": {
			if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
				console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
				return parseAnyDef(refs);
			}
			return refs.$refStrategy === "seen" ? parseAnyDef(refs) : undefined;
		}
	}
};
const addMeta = (def, refs, jsonSchema) => {
	if (def.description) {
		jsonSchema.description = def.description;
		if (refs.markdownDescription) {
			jsonSchema.markdownDescription = def.description;
		}
	}
	return jsonSchema;
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
const zodToJsonSchema = (schema, options) => {
	const refs = getRefs(options);
	let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name$1, schema$1]) => ({
		...acc,
		[name$1]: parseDef(schema$1._def, {
			...refs,
			currentPath: [
				...refs.basePath,
				refs.definitionPath,
				name$1
			]
		}, true) ?? parseAnyDef(refs)
	}), {}) : undefined;
	const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? undefined : options?.name;
	const main = parseDef(schema._def, name === undefined ? refs : {
		...refs,
		currentPath: [
			...refs.basePath,
			refs.definitionPath,
			name
		]
	}, false) ?? parseAnyDef(refs);
	const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;
	if (title !== undefined) {
		main.title = title;
	}
	if (refs.flags.hasReferencedOpenAiAnyType) {
		if (!definitions) {
			definitions = {};
		}
		if (!definitions[refs.openAiAnyTypeName]) {
			definitions[refs.openAiAnyTypeName] = {
				type: [
					"string",
					"number",
					"integer",
					"boolean",
					"array",
					"null"
				],
				items: { $ref: refs.$refStrategy === "relative" ? "1" : [
					...refs.basePath,
					refs.definitionPath,
					refs.openAiAnyTypeName
				].join("/") }
			};
		}
	}
	const combined = name === undefined ? definitions ? {
		...main,
		[refs.definitionPath]: definitions
	} : main : {
		$ref: [
			...refs.$refStrategy === "relative" ? [] : refs.basePath,
			refs.definitionPath,
			name
		].join("/"),
		[refs.definitionPath]: {
			...definitions,
			[name]: main
		}
	};
	if (refs.target === "jsonSchema7") {
		combined.$schema = "http://json-schema.org/draft-07/schema#";
	} else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
		combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
	}
	if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
		console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
	}
	return combined;
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/zod-to-json-schema/dist/esm/index.js
var esm_default = zodToJsonSchema;

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function mapMiniTarget(t) {
	if (!t) return "draft-7";
	if (t === "jsonSchema7" || t === "draft-7") return "draft-7";
	if (t === "jsonSchema2019-09" || t === "draft-2020-12") return "draft-2020-12";
	return "draft-7";
}
function toJsonSchemaCompat(schema, opts) {
	if (isZ4Schema(schema)) {
		return toJSONSchema(schema, {
			target: mapMiniTarget(opts?.target),
			io: opts?.pipeStrategy ?? "input"
		});
	}
	return zodToJsonSchema(schema, {
		strictUnions: opts?.strictUnions ?? true,
		pipeStrategy: opts?.pipeStrategy ?? "input"
	});
}
function getMethodLiteral(schema) {
	const shape = getObjectShape(schema);
	const methodSchema = shape?.method;
	if (!methodSchema) {
		throw new Error("Schema is missing a method literal");
	}
	const value = getLiteralValue(methodSchema);
	if (typeof value !== "string") {
		throw new Error("Schema method literal must be a string");
	}
	return value;
}
function parseWithCompat(schema, data) {
	const result = safeParse(schema, data);
	if (!result.success) {
		throw result.error;
	}
	return result.data;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
/**
* The default request timeout, in miliseconds.
*/
const DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
/**
* Implements MCP protocol framing on top of a pluggable transport, including
* features like request/response linking, notifications, and progress.
*/
var Protocol = class {
	constructor(_options) {
		this._options = _options;
		this._requestMessageId = 0;
		this._requestHandlers = new Map();
		this._requestHandlerAbortControllers = new Map();
		this._notificationHandlers = new Map();
		this._responseHandlers = new Map();
		this._progressHandlers = new Map();
		this._timeoutInfo = new Map();
		this._pendingDebouncedNotifications = new Set();
		this._taskProgressTokens = new Map();
		this._requestResolvers = new Map();
		this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
			this._oncancel(notification);
		});
		this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
			this._onprogress(notification);
		});
		this.setRequestHandler(PingRequestSchema, (_request) => ({}));
		this._taskStore = _options?.taskStore;
		this._taskMessageQueue = _options?.taskMessageQueue;
		if (this._taskStore) {
			this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
				const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
				if (!task) {
					throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
				}
				return { ...task };
			});
			this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
				const handleTaskResult = async () => {
					const taskId = request.params.taskId;
					if (this._taskMessageQueue) {
						let queuedMessage;
						while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
							if (queuedMessage.type === "response" || queuedMessage.type === "error") {
								const message = queuedMessage.message;
								const requestId = message.id;
								const resolver = this._requestResolvers.get(requestId);
								if (resolver) {
									this._requestResolvers.delete(requestId);
									if (queuedMessage.type === "response") {
										resolver(message);
									} else {
										const errorMessage = message;
										const error$47 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
										resolver(error$47);
									}
								} else {
									const messageType = queuedMessage.type === "response" ? "Response" : "Error";
									this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
								}
								continue;
							}
							await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
						}
					}
					const task = await this._taskStore.getTask(taskId, extra.sessionId);
					if (!task) {
						throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
					}
					if (!isTerminal(task.status)) {
						await this._waitForTaskUpdate(taskId, extra.signal);
						return await handleTaskResult();
					}
					if (isTerminal(task.status)) {
						const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
						this._clearTaskQueue(taskId);
						return {
							...result,
							_meta: {
								...result._meta,
								[RELATED_TASK_META_KEY]: { taskId }
							}
						};
					}
					return await handleTaskResult();
				};
				return await handleTaskResult();
			});
			this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
				try {
					const { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
					return {
						tasks,
						nextCursor,
						_meta: {}
					};
				} catch (error$47) {
					throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error$47 instanceof Error ? error$47.message : String(error$47)}`);
				}
			});
			this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
				try {
					const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
					if (!task) {
						throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
					}
					if (isTerminal(task.status)) {
						throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
					}
					await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
					this._clearTaskQueue(request.params.taskId);
					const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
					if (!cancelledTask) {
						throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
					}
					return {
						_meta: {},
						...cancelledTask
					};
				} catch (error$47) {
					if (error$47 instanceof McpError) {
						throw error$47;
					}
					throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error$47 instanceof Error ? error$47.message : String(error$47)}`);
				}
			});
		}
	}
	async _oncancel(notification) {
		if (!notification.params.requestId) {
			return;
		}
		const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
		controller?.abort(notification.params.reason);
	}
	_setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
		this._timeoutInfo.set(messageId, {
			timeoutId: setTimeout(onTimeout, timeout),
			startTime: Date.now(),
			timeout,
			maxTotalTimeout,
			resetTimeoutOnProgress,
			onTimeout
		});
	}
	_resetTimeout(messageId) {
		const info = this._timeoutInfo.get(messageId);
		if (!info) return false;
		const totalElapsed = Date.now() - info.startTime;
		if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
			this._timeoutInfo.delete(messageId);
			throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
				maxTotalTimeout: info.maxTotalTimeout,
				totalElapsed
			});
		}
		clearTimeout(info.timeoutId);
		info.timeoutId = setTimeout(info.onTimeout, info.timeout);
		return true;
	}
	_cleanupTimeout(messageId) {
		const info = this._timeoutInfo.get(messageId);
		if (info) {
			clearTimeout(info.timeoutId);
			this._timeoutInfo.delete(messageId);
		}
	}
	/**
	* Attaches to the given transport, starts it, and starts listening for messages.
	*
	* The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
	*/
	async connect(transport) {
		this._transport = transport;
		const _onclose = this.transport?.onclose;
		this._transport.onclose = () => {
			_onclose?.();
			this._onclose();
		};
		const _onerror = this.transport?.onerror;
		this._transport.onerror = (error$47) => {
			_onerror?.(error$47);
			this._onerror(error$47);
		};
		const _onmessage = this._transport?.onmessage;
		this._transport.onmessage = (message, extra) => {
			_onmessage?.(message, extra);
			if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
				this._onresponse(message);
			} else if (isJSONRPCRequest(message)) {
				this._onrequest(message, extra);
			} else if (isJSONRPCNotification(message)) {
				this._onnotification(message);
			} else {
				this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
			}
		};
		await this._transport.start();
	}
	_onclose() {
		const responseHandlers = this._responseHandlers;
		this._responseHandlers = new Map();
		this._progressHandlers.clear();
		this._taskProgressTokens.clear();
		this._pendingDebouncedNotifications.clear();
		const error$47 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
		this._transport = undefined;
		this.onclose?.();
		for (const handler of responseHandlers.values()) {
			handler(error$47);
		}
	}
	_onerror(error$47) {
		this.onerror?.(error$47);
	}
	_onnotification(notification) {
		const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
		if (handler === undefined) {
			return;
		}
		Promise.resolve().then(() => handler(notification)).catch((error$47) => this._onerror(new Error(`Uncaught error in notification handler: ${error$47}`)));
	}
	_onrequest(request, extra) {
		const handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;
		const capturedTransport = this._transport;
		const relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
		if (handler === undefined) {
			const errorResponse = {
				jsonrpc: "2.0",
				id: request.id,
				error: {
					code: ErrorCode.MethodNotFound,
					message: "Method not found"
				}
			};
			if (relatedTaskId && this._taskMessageQueue) {
				this._enqueueTaskMessage(relatedTaskId, {
					type: "error",
					message: errorResponse,
					timestamp: Date.now()
				}, capturedTransport?.sessionId).catch((error$47) => this._onerror(new Error(`Failed to enqueue error response: ${error$47}`)));
			} else {
				capturedTransport?.send(errorResponse).catch((error$47) => this._onerror(new Error(`Failed to send an error response: ${error$47}`)));
			}
			return;
		}
		const abortController = new AbortController();
		this._requestHandlerAbortControllers.set(request.id, abortController);
		const taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : undefined;
		const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : undefined;
		const fullExtra = {
			signal: abortController.signal,
			sessionId: capturedTransport?.sessionId,
			_meta: request.params?._meta,
			sendNotification: async (notification) => {
				const notificationOptions = { relatedRequestId: request.id };
				if (relatedTaskId) {
					notificationOptions.relatedTask = { taskId: relatedTaskId };
				}
				await this.notification(notification, notificationOptions);
			},
			sendRequest: async (r, resultSchema, options) => {
				const requestOptions = {
					...options,
					relatedRequestId: request.id
				};
				if (relatedTaskId && !requestOptions.relatedTask) {
					requestOptions.relatedTask = { taskId: relatedTaskId };
				}
				const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
				if (effectiveTaskId && taskStore) {
					await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
				}
				return await this.request(r, resultSchema, requestOptions);
			},
			authInfo: extra?.authInfo,
			requestId: request.id,
			requestInfo: extra?.requestInfo,
			taskId: relatedTaskId,
			taskStore,
			taskRequestedTtl: taskCreationParams?.ttl,
			closeSSEStream: extra?.closeSSEStream,
			closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
		};
		Promise.resolve().then(() => {
			if (taskCreationParams) {
				this.assertTaskHandlerCapability(request.method);
			}
		}).then(() => handler(request, fullExtra)).then(async (result) => {
			if (abortController.signal.aborted) {
				return;
			}
			const response = {
				result,
				jsonrpc: "2.0",
				id: request.id
			};
			if (relatedTaskId && this._taskMessageQueue) {
				await this._enqueueTaskMessage(relatedTaskId, {
					type: "response",
					message: response,
					timestamp: Date.now()
				}, capturedTransport?.sessionId);
			} else {
				await capturedTransport?.send(response);
			}
		}, async (error$47) => {
			if (abortController.signal.aborted) {
				return;
			}
			const errorResponse = {
				jsonrpc: "2.0",
				id: request.id,
				error: {
					code: Number.isSafeInteger(error$47["code"]) ? error$47["code"] : ErrorCode.InternalError,
					message: error$47.message ?? "Internal error",
					...error$47["data"] !== undefined && { data: error$47["data"] }
				}
			};
			if (relatedTaskId && this._taskMessageQueue) {
				await this._enqueueTaskMessage(relatedTaskId, {
					type: "error",
					message: errorResponse,
					timestamp: Date.now()
				}, capturedTransport?.sessionId);
			} else {
				await capturedTransport?.send(errorResponse);
			}
		}).catch((error$47) => this._onerror(new Error(`Failed to send response: ${error$47}`))).finally(() => {
			this._requestHandlerAbortControllers.delete(request.id);
		});
	}
	_onprogress(notification) {
		const { progressToken, ...params } = notification.params;
		const messageId = Number(progressToken);
		const handler = this._progressHandlers.get(messageId);
		if (!handler) {
			this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
			return;
		}
		const responseHandler = this._responseHandlers.get(messageId);
		const timeoutInfo = this._timeoutInfo.get(messageId);
		if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
			try {
				this._resetTimeout(messageId);
			} catch (error$47) {
				this._responseHandlers.delete(messageId);
				this._progressHandlers.delete(messageId);
				this._cleanupTimeout(messageId);
				responseHandler(error$47);
				return;
			}
		}
		handler(params);
	}
	_onresponse(response) {
		const messageId = Number(response.id);
		const resolver = this._requestResolvers.get(messageId);
		if (resolver) {
			this._requestResolvers.delete(messageId);
			if (isJSONRPCResultResponse(response)) {
				resolver(response);
			} else {
				const error$47 = new McpError(response.error.code, response.error.message, response.error.data);
				resolver(error$47);
			}
			return;
		}
		const handler = this._responseHandlers.get(messageId);
		if (handler === undefined) {
			this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
			return;
		}
		this._responseHandlers.delete(messageId);
		this._cleanupTimeout(messageId);
		let isTaskResponse = false;
		if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
			const result = response.result;
			if (result.task && typeof result.task === "object") {
				const task = result.task;
				if (typeof task.taskId === "string") {
					isTaskResponse = true;
					this._taskProgressTokens.set(task.taskId, messageId);
				}
			}
		}
		if (!isTaskResponse) {
			this._progressHandlers.delete(messageId);
		}
		if (isJSONRPCResultResponse(response)) {
			handler(response);
		} else {
			const error$47 = McpError.fromError(response.error.code, response.error.message, response.error.data);
			handler(error$47);
		}
	}
	get transport() {
		return this._transport;
	}
	/**
	* Closes the connection.
	*/
	async close() {
		await this._transport?.close();
	}
	/**
	* Sends a request and returns an AsyncGenerator that yields response messages.
	* The generator is guaranteed to end with either a 'result' or 'error' message.
	*
	* @example
	* ```typescript
	* const stream = protocol.requestStream(request, resultSchema, options);
	* for await (const message of stream) {
	*   switch (message.type) {
	*     case 'taskCreated':
	*       console.log('Task created:', message.task.taskId);
	*       break;
	*     case 'taskStatus':
	*       console.log('Task status:', message.task.status);
	*       break;
	*     case 'result':
	*       console.log('Final result:', message.result);
	*       break;
	*     case 'error':
	*       console.error('Error:', message.error);
	*       break;
	*   }
	* }
	* ```
	*
	* @experimental Use `client.experimental.tasks.requestStream()` to access this method.
	*/
	async *requestStream(request, resultSchema, options) {
		const { task } = options ?? {};
		if (!task) {
			try {
				const result = await this.request(request, resultSchema, options);
				yield {
					type: "result",
					result
				};
			} catch (error$47) {
				yield {
					type: "error",
					error: error$47 instanceof McpError ? error$47 : new McpError(ErrorCode.InternalError, String(error$47))
				};
			}
			return;
		}
		let taskId;
		try {
			const createResult = await this.request(request, CreateTaskResultSchema, options);
			if (createResult.task) {
				taskId = createResult.task.taskId;
				yield {
					type: "taskCreated",
					task: createResult.task
				};
			} else {
				throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
			}
			while (true) {
				const task$1 = await this.getTask({ taskId }, options);
				yield {
					type: "taskStatus",
					task: task$1
				};
				if (isTerminal(task$1.status)) {
					if (task$1.status === "completed") {
						const result = await this.getTaskResult({ taskId }, resultSchema, options);
						yield {
							type: "result",
							result
						};
					} else if (task$1.status === "failed") {
						yield {
							type: "error",
							error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
						};
					} else if (task$1.status === "cancelled") {
						yield {
							type: "error",
							error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
						};
					}
					return;
				}
				if (task$1.status === "input_required") {
					const result = await this.getTaskResult({ taskId }, resultSchema, options);
					yield {
						type: "result",
						result
					};
					return;
				}
				const pollInterval = task$1.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
				await new Promise((resolve) => setTimeout(resolve, pollInterval));
				options?.signal?.throwIfAborted();
			}
		} catch (error$47) {
			yield {
				type: "error",
				error: error$47 instanceof McpError ? error$47 : new McpError(ErrorCode.InternalError, String(error$47))
			};
		}
	}
	/**
	* Sends a request and waits for a response.
	*
	* Do not use this method to emit notifications! Use notification() instead.
	*/
	request(request, resultSchema, options) {
		const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
		return new Promise((resolve, reject) => {
			const earlyReject = (error$47) => {
				reject(error$47);
			};
			if (!this._transport) {
				earlyReject(new Error("Not connected"));
				return;
			}
			if (this._options?.enforceStrictCapabilities === true) {
				try {
					this.assertCapabilityForMethod(request.method);
					if (task) {
						this.assertTaskCapability(request.method);
					}
				} catch (e) {
					earlyReject(e);
					return;
				}
			}
			options?.signal?.throwIfAborted();
			const messageId = this._requestMessageId++;
			const jsonrpcRequest = {
				...request,
				jsonrpc: "2.0",
				id: messageId
			};
			if (options?.onprogress) {
				this._progressHandlers.set(messageId, options.onprogress);
				jsonrpcRequest.params = {
					...request.params,
					_meta: {
						...request.params?._meta || {},
						progressToken: messageId
					}
				};
			}
			if (task) {
				jsonrpcRequest.params = {
					...jsonrpcRequest.params,
					task
				};
			}
			if (relatedTask) {
				jsonrpcRequest.params = {
					...jsonrpcRequest.params,
					_meta: {
						...jsonrpcRequest.params?._meta || {},
						[RELATED_TASK_META_KEY]: relatedTask
					}
				};
			}
			const cancel = (reason) => {
				this._responseHandlers.delete(messageId);
				this._progressHandlers.delete(messageId);
				this._cleanupTimeout(messageId);
				this._transport?.send({
					jsonrpc: "2.0",
					method: "notifications/cancelled",
					params: {
						requestId: messageId,
						reason: String(reason)
					}
				}, {
					relatedRequestId,
					resumptionToken,
					onresumptiontoken
				}).catch((error$48) => this._onerror(new Error(`Failed to send cancellation: ${error$48}`)));
				const error$47 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
				reject(error$47);
			};
			this._responseHandlers.set(messageId, (response) => {
				if (options?.signal?.aborted) {
					return;
				}
				if (response instanceof Error) {
					return reject(response);
				}
				try {
					const parseResult = safeParse(resultSchema, response.result);
					if (!parseResult.success) {
						reject(parseResult.error);
					} else {
						resolve(parseResult.data);
					}
				} catch (error$47) {
					reject(error$47);
				}
			});
			options?.signal?.addEventListener("abort", () => {
				cancel(options?.signal?.reason);
			});
			const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
			const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
			this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);
			const relatedTaskId = relatedTask?.taskId;
			if (relatedTaskId) {
				const responseResolver = (response) => {
					const handler = this._responseHandlers.get(messageId);
					if (handler) {
						handler(response);
					} else {
						this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
					}
				};
				this._requestResolvers.set(messageId, responseResolver);
				this._enqueueTaskMessage(relatedTaskId, {
					type: "request",
					message: jsonrpcRequest,
					timestamp: Date.now()
				}).catch((error$47) => {
					this._cleanupTimeout(messageId);
					reject(error$47);
				});
			} else {
				this._transport.send(jsonrpcRequest, {
					relatedRequestId,
					resumptionToken,
					onresumptiontoken
				}).catch((error$47) => {
					this._cleanupTimeout(messageId);
					reject(error$47);
				});
			}
		});
	}
	/**
	* Gets the current status of a task.
	*
	* @experimental Use `client.experimental.tasks.getTask()` to access this method.
	*/
	async getTask(params, options) {
		return this.request({
			method: "tasks/get",
			params
		}, GetTaskResultSchema, options);
	}
	/**
	* Retrieves the result of a completed task.
	*
	* @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
	*/
	async getTaskResult(params, resultSchema, options) {
		return this.request({
			method: "tasks/result",
			params
		}, resultSchema, options);
	}
	/**
	* Lists tasks, optionally starting from a pagination cursor.
	*
	* @experimental Use `client.experimental.tasks.listTasks()` to access this method.
	*/
	async listTasks(params, options) {
		return this.request({
			method: "tasks/list",
			params
		}, ListTasksResultSchema, options);
	}
	/**
	* Cancels a specific task.
	*
	* @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
	*/
	async cancelTask(params, options) {
		return this.request({
			method: "tasks/cancel",
			params
		}, CancelTaskResultSchema, options);
	}
	/**
	* Emits a notification, which is a one-way message that does not expect a response.
	*/
	async notification(notification, options) {
		if (!this._transport) {
			throw new Error("Not connected");
		}
		this.assertNotificationCapability(notification.method);
		const relatedTaskId = options?.relatedTask?.taskId;
		if (relatedTaskId) {
			const jsonrpcNotification$1 = {
				...notification,
				jsonrpc: "2.0",
				params: {
					...notification.params,
					_meta: {
						...notification.params?._meta || {},
						[RELATED_TASK_META_KEY]: options.relatedTask
					}
				}
			};
			await this._enqueueTaskMessage(relatedTaskId, {
				type: "notification",
				message: jsonrpcNotification$1,
				timestamp: Date.now()
			});
			return;
		}
		const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];
		const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask;
		if (canDebounce) {
			if (this._pendingDebouncedNotifications.has(notification.method)) {
				return;
			}
			this._pendingDebouncedNotifications.add(notification.method);
			Promise.resolve().then(() => {
				this._pendingDebouncedNotifications.delete(notification.method);
				if (!this._transport) {
					return;
				}
				let jsonrpcNotification$1 = {
					...notification,
					jsonrpc: "2.0"
				};
				if (options?.relatedTask) {
					jsonrpcNotification$1 = {
						...jsonrpcNotification$1,
						params: {
							...jsonrpcNotification$1.params,
							_meta: {
								...jsonrpcNotification$1.params?._meta || {},
								[RELATED_TASK_META_KEY]: options.relatedTask
							}
						}
					};
				}
				this._transport?.send(jsonrpcNotification$1, options).catch((error$47) => this._onerror(error$47));
			});
			return;
		}
		let jsonrpcNotification = {
			...notification,
			jsonrpc: "2.0"
		};
		if (options?.relatedTask) {
			jsonrpcNotification = {
				...jsonrpcNotification,
				params: {
					...jsonrpcNotification.params,
					_meta: {
						...jsonrpcNotification.params?._meta || {},
						[RELATED_TASK_META_KEY]: options.relatedTask
					}
				}
			};
		}
		await this._transport.send(jsonrpcNotification, options);
	}
	/**
	* Registers a handler to invoke when this protocol object receives a request with the given method.
	*
	* Note that this will replace any previous request handler for the same method.
	*/
	setRequestHandler(requestSchema, handler) {
		const method = getMethodLiteral(requestSchema);
		this.assertRequestHandlerCapability(method);
		this._requestHandlers.set(method, (request, extra) => {
			const parsed = parseWithCompat(requestSchema, request);
			return Promise.resolve(handler(parsed, extra));
		});
	}
	/**
	* Removes the request handler for the given method.
	*/
	removeRequestHandler(method) {
		this._requestHandlers.delete(method);
	}
	/**
	* Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
	*/
	assertCanSetRequestHandler(method) {
		if (this._requestHandlers.has(method)) {
			throw new Error(`A request handler for ${method} already exists, which would be overridden`);
		}
	}
	/**
	* Registers a handler to invoke when this protocol object receives a notification with the given method.
	*
	* Note that this will replace any previous notification handler for the same method.
	*/
	setNotificationHandler(notificationSchema, handler) {
		const method = getMethodLiteral(notificationSchema);
		this._notificationHandlers.set(method, (notification) => {
			const parsed = parseWithCompat(notificationSchema, notification);
			return Promise.resolve(handler(parsed));
		});
	}
	/**
	* Removes the notification handler for the given method.
	*/
	removeNotificationHandler(method) {
		this._notificationHandlers.delete(method);
	}
	/**
	* Cleans up the progress handler associated with a task.
	* This should be called when a task reaches a terminal status.
	*/
	_cleanupTaskProgressHandler(taskId) {
		const progressToken = this._taskProgressTokens.get(taskId);
		if (progressToken !== undefined) {
			this._progressHandlers.delete(progressToken);
			this._taskProgressTokens.delete(taskId);
		}
	}
	/**
	* Enqueues a task-related message for side-channel delivery via tasks/result.
	* @param taskId The task ID to associate the message with
	* @param message The message to enqueue
	* @param sessionId Optional session ID for binding the operation to a specific session
	* @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
	*
	* Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
	* the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
	* simply propagates the error.
	*/
	async _enqueueTaskMessage(taskId, message, sessionId) {
		if (!this._taskStore || !this._taskMessageQueue) {
			throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
		}
		const maxQueueSize = this._options?.maxTaskQueueSize;
		await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
	}
	/**
	* Clears the message queue for a task and rejects any pending request resolvers.
	* @param taskId The task ID whose queue should be cleared
	* @param sessionId Optional session ID for binding the operation to a specific session
	*/
	async _clearTaskQueue(taskId, sessionId) {
		if (this._taskMessageQueue) {
			const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
			for (const message of messages) {
				if (message.type === "request" && isJSONRPCRequest(message.message)) {
					const requestId = message.message.id;
					const resolver = this._requestResolvers.get(requestId);
					if (resolver) {
						resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
						this._requestResolvers.delete(requestId);
					} else {
						this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
					}
				}
			}
		}
	}
	/**
	* Waits for a task update (new messages or status change) with abort signal support.
	* Uses polling to check for updates at the task's configured poll interval.
	* @param taskId The task ID to wait for
	* @param signal Abort signal to cancel the wait
	* @returns Promise that resolves when an update occurs or rejects if aborted
	*/
	async _waitForTaskUpdate(taskId, signal) {
		let interval = this._options?.defaultTaskPollInterval ?? 1e3;
		try {
			const task = await this._taskStore?.getTask(taskId);
			if (task?.pollInterval) {
				interval = task.pollInterval;
			}
		} catch {}
		return new Promise((resolve, reject) => {
			if (signal.aborted) {
				reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
				return;
			}
			const timeoutId = setTimeout(resolve, interval);
			signal.addEventListener("abort", () => {
				clearTimeout(timeoutId);
				reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
			}, { once: true });
		});
	}
	requestTaskStore(request, sessionId) {
		const taskStore = this._taskStore;
		if (!taskStore) {
			throw new Error("No task store configured");
		}
		return {
			createTask: async (taskParams) => {
				if (!request) {
					throw new Error("No request provided");
				}
				return await taskStore.createTask(taskParams, request.id, {
					method: request.method,
					params: request.params
				}, sessionId);
			},
			getTask: async (taskId) => {
				const task = await taskStore.getTask(taskId, sessionId);
				if (!task) {
					throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
				}
				return task;
			},
			storeTaskResult: async (taskId, status, result) => {
				await taskStore.storeTaskResult(taskId, status, result, sessionId);
				const task = await taskStore.getTask(taskId, sessionId);
				if (task) {
					const notification = TaskStatusNotificationSchema.parse({
						method: "notifications/tasks/status",
						params: task
					});
					await this.notification(notification);
					if (isTerminal(task.status)) {
						this._cleanupTaskProgressHandler(taskId);
					}
				}
			},
			getTaskResult: (taskId) => {
				return taskStore.getTaskResult(taskId, sessionId);
			},
			updateTaskStatus: async (taskId, status, statusMessage) => {
				const task = await taskStore.getTask(taskId, sessionId);
				if (!task) {
					throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
				}
				if (isTerminal(task.status)) {
					throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
				}
				await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
				const updatedTask = await taskStore.getTask(taskId, sessionId);
				if (updatedTask) {
					const notification = TaskStatusNotificationSchema.parse({
						method: "notifications/tasks/status",
						params: updatedTask
					});
					await this.notification(notification);
					if (isTerminal(updatedTask.status)) {
						this._cleanupTaskProgressHandler(taskId);
					}
				}
			},
			listTasks: (cursor) => {
				return taskStore.listTasks(cursor, sessionId);
			}
		};
	}
};
function isPlainObject$1(value) {
	return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
	const result = { ...base };
	for (const key in additional) {
		const k = key;
		const addValue = additional[k];
		if (addValue === undefined) continue;
		const baseValue = result[k];
		if (isPlainObject$1(baseValue) && isPlainObject$1(addValue)) {
			result[k] = {
				...baseValue,
				...addValue
			};
		} else {
			result[k] = addValue;
		}
	}
	return result;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/codegen/code.js
var require_code$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	var _CodeOrName = class {};
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var Name = class extends _CodeOrName {
		constructor(s) {
			super();
			if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
			this.str = s;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			return false;
		}
		get names() {
			return { [this.str]: 1 };
		}
	};
	exports.Name = Name;
	var _Code = class extends _CodeOrName {
		constructor(code) {
			super();
			this._items = typeof code === "string" ? [code] : code;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			if (this._items.length > 1) return false;
			const item = this._items[0];
			return item === "" || item === "\"\"";
		}
		get str() {
			var _a$1;
			return (_a$1 = this._str) !== null && _a$1 !== void 0 ? _a$1 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
		}
		get names() {
			var _a$1;
			return (_a$1 = this._names) !== null && _a$1 !== void 0 ? _a$1 : this._names = this._items.reduce((names, c) => {
				if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1;
				return names;
			}, {});
		}
	};
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
		const code = [strs[0]];
		let i = 0;
		while (i < args.length) {
			addCodeArg(code, args[i]);
			code.push(strs[++i]);
		}
		return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
		const expr = [safeStringify(strs[0])];
		let i = 0;
		while (i < args.length) {
			expr.push(plus);
			addCodeArg(expr, args[i]);
			expr.push(plus, safeStringify(strs[++i]));
		}
		optimize(expr);
		return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
		if (arg instanceof _Code) code.push(...arg._items);
		else if (arg instanceof Name) code.push(arg);
		else code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
		let i = 1;
		while (i < expr.length - 1) {
			if (expr[i] === plus) {
				const res = mergeExprItems(expr[i - 1], expr[i + 1]);
				if (res !== undefined) {
					expr.splice(i - 1, 3, res);
					continue;
				}
				expr[i++] = "+";
			}
			i++;
		}
	}
	function mergeExprItems(a, b) {
		if (b === "\"\"") return a;
		if (a === "\"\"") return b;
		if (typeof a == "string") {
			if (b instanceof Name || a[a.length - 1] !== "\"") return;
			if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
			if (b[0] === "\"") return a.slice(0, -1) + b.slice(1);
			return;
		}
		if (typeof b == "string" && b[0] === "\"" && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
		return;
	}
	function strConcat(c1, c2) {
		return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	function interpolate(x) {
		return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
		return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
		return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
		return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
	}
	exports.getProperty = getProperty;
	function getEsmExportName(key) {
		if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
			return new _Code(`${key}`);
		}
		throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
		return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
	const code_1 = require_code$1();
	var ValueError = class extends Error {
		constructor(name) {
			super(`CodeGen: "code" for ${name} not defined`);
			this.value = name.value;
		}
	};
	var UsedValueState;
	(function(UsedValueState) {
		UsedValueState[UsedValueState["Started"] = 0] = "Started";
		UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
	})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
	exports.varKinds = {
		const: new code_1.Name("const"),
		let: new code_1.Name("let"),
		var: new code_1.Name("var")
	};
	var Scope = class {
		constructor({ prefixes, parent } = {}) {
			this._names = {};
			this._prefixes = prefixes;
			this._parent = parent;
		}
		toName(nameOrPrefix) {
			return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		}
		name(prefix) {
			return new code_1.Name(this._newName(prefix));
		}
		_newName(prefix) {
			const ng = this._names[prefix] || this._nameGroup(prefix);
			return `${prefix}${ng.index++}`;
		}
		_nameGroup(prefix) {
			var _a$1, _b;
			if (((_b = (_a$1 = this._parent) === null || _a$1 === void 0 ? void 0 : _a$1._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
				throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
			}
			return this._names[prefix] = {
				prefix,
				index: 0
			};
		}
	};
	exports.Scope = Scope;
	var ValueScopeName = class extends code_1.Name {
		constructor(prefix, nameStr) {
			super(nameStr);
			this.prefix = prefix;
		}
		setValue(value, { property, itemIndex }) {
			this.value = value;
			this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
		}
	};
	exports.ValueScopeName = ValueScopeName;
	const line = (0, code_1._)`\n`;
	var ValueScope = class extends Scope {
		constructor(opts) {
			super(opts);
			this._values = {};
			this._scope = opts.scope;
			this.opts = {
				...opts,
				_n: opts.lines ? line : code_1.nil
			};
		}
		get() {
			return this._scope;
		}
		name(prefix) {
			return new ValueScopeName(prefix, this._newName(prefix));
		}
		value(nameOrPrefix, value) {
			var _a$1;
			if (value.ref === undefined) throw new Error("CodeGen: ref must be passed in value");
			const name = this.toName(nameOrPrefix);
			const { prefix } = name;
			const valueKey = (_a$1 = value.key) !== null && _a$1 !== void 0 ? _a$1 : value.ref;
			let vs = this._values[prefix];
			if (vs) {
				const _name = vs.get(valueKey);
				if (_name) return _name;
			} else {
				vs = this._values[prefix] = new Map();
			}
			vs.set(valueKey, name);
			const s = this._scope[prefix] || (this._scope[prefix] = []);
			const itemIndex = s.length;
			s[itemIndex] = value.ref;
			name.setValue(value, {
				property: prefix,
				itemIndex
			});
			return name;
		}
		getValue(prefix, keyOrRef) {
			const vs = this._values[prefix];
			if (!vs) return;
			return vs.get(keyOrRef);
		}
		scopeRefs(scopeName, values = this._values) {
			return this._reduceValues(values, (name) => {
				if (name.scopePath === undefined) throw new Error(`CodeGen: name "${name}" has no value`);
				return (0, code_1._)`${scopeName}${name.scopePath}`;
			});
		}
		scopeCode(values = this._values, usedValues, getCode) {
			return this._reduceValues(values, (name) => {
				if (name.value === undefined) throw new Error(`CodeGen: name "${name}" has no value`);
				return name.value.code;
			}, usedValues, getCode);
		}
		_reduceValues(values, valueCode, usedValues = {}, getCode) {
			let code = code_1.nil;
			for (const prefix in values) {
				const vs = values[prefix];
				if (!vs) continue;
				const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();
				vs.forEach((name) => {
					if (nameSet.has(name)) return;
					nameSet.set(name, UsedValueState.Started);
					let c = valueCode(name);
					if (c) {
						const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
						code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
					} else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
						code = (0, code_1._)`${code}${c}${this.opts._n}`;
					} else {
						throw new ValueError(name);
					}
					nameSet.set(name, UsedValueState.Completed);
				});
			}
			return code;
		}
	};
	exports.ValueScope = ValueScope;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
	const code_1 = require_code$1();
	const scope_1 = require_scope();
	var code_2 = require_code$1();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return code_2._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return code_2.str;
		}
	});
	Object.defineProperty(exports, "strConcat", {
		enumerable: true,
		get: function() {
			return code_2.strConcat;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return code_2.nil;
		}
	});
	Object.defineProperty(exports, "getProperty", {
		enumerable: true,
		get: function() {
			return code_2.getProperty;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return code_2.stringify;
		}
	});
	Object.defineProperty(exports, "regexpCode", {
		enumerable: true,
		get: function() {
			return code_2.regexpCode;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return code_2.Name;
		}
	});
	var scope_2 = require_scope();
	Object.defineProperty(exports, "Scope", {
		enumerable: true,
		get: function() {
			return scope_2.Scope;
		}
	});
	Object.defineProperty(exports, "ValueScope", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScope;
		}
	});
	Object.defineProperty(exports, "ValueScopeName", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScopeName;
		}
	});
	Object.defineProperty(exports, "varKinds", {
		enumerable: true,
		get: function() {
			return scope_2.varKinds;
		}
	});
	exports.operators = {
		GT: new code_1._Code(">"),
		GTE: new code_1._Code(">="),
		LT: new code_1._Code("<"),
		LTE: new code_1._Code("<="),
		EQ: new code_1._Code("==="),
		NEQ: new code_1._Code("!=="),
		NOT: new code_1._Code("!"),
		OR: new code_1._Code("||"),
		AND: new code_1._Code("&&"),
		ADD: new code_1._Code("+")
	};
	var Node = class {
		optimizeNodes() {
			return this;
		}
		optimizeNames(_names, _constants) {
			return this;
		}
	};
	var Def = class extends Node {
		constructor(varKind, name, rhs) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.rhs = rhs;
		}
		render({ es5, _n }) {
			const varKind = es5 ? scope_1.varKinds.var : this.varKind;
			const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
			return `${varKind} ${this.name}${rhs};` + _n;
		}
		optimizeNames(names, constants) {
			if (!names[this.name.str]) return;
			if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);
			return this;
		}
		get names() {
			return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		}
	};
	var Assign = class extends Node {
		constructor(lhs, rhs, sideEffects) {
			super();
			this.lhs = lhs;
			this.rhs = rhs;
			this.sideEffects = sideEffects;
		}
		render({ _n }) {
			return `${this.lhs} = ${this.rhs};` + _n;
		}
		optimizeNames(names, constants) {
			if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;
			this.rhs = optimizeExpr(this.rhs, names, constants);
			return this;
		}
		get names() {
			const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
			return addExprNames(names, this.rhs);
		}
	};
	var AssignOp = class extends Assign {
		constructor(lhs, op, rhs, sideEffects) {
			super(lhs, rhs, sideEffects);
			this.op = op;
		}
		render({ _n }) {
			return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		}
	};
	var Label = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `${this.label}:` + _n;
		}
	};
	var Break = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			const label = this.label ? ` ${this.label}` : "";
			return `break${label};` + _n;
		}
	};
	var Throw = class extends Node {
		constructor(error$47) {
			super();
			this.error = error$47;
		}
		render({ _n }) {
			return `throw ${this.error};` + _n;
		}
		get names() {
			return this.error.names;
		}
	};
	var AnyCode = class extends Node {
		constructor(code) {
			super();
			this.code = code;
		}
		render({ _n }) {
			return `${this.code};` + _n;
		}
		optimizeNodes() {
			return `${this.code}` ? this : undefined;
		}
		optimizeNames(names, constants) {
			this.code = optimizeExpr(this.code, names, constants);
			return this;
		}
		get names() {
			return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		}
	};
	var ParentNode = class extends Node {
		constructor(nodes = []) {
			super();
			this.nodes = nodes;
		}
		render(opts) {
			return this.nodes.reduce((code, n) => code + n.render(opts), "");
		}
		optimizeNodes() {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i].optimizeNodes();
				if (Array.isArray(n)) nodes.splice(i, 1, ...n);
				else if (n) nodes[i] = n;
				else nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : undefined;
		}
		optimizeNames(names, constants) {
			const { nodes } = this;
			let i = nodes.length;
			while (i--) {
				const n = nodes[i];
				if (n.optimizeNames(names, constants)) continue;
				subtractNames(names, n.names);
				nodes.splice(i, 1);
			}
			return nodes.length > 0 ? this : undefined;
		}
		get names() {
			return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		}
	};
	var BlockNode = class extends ParentNode {
		render(opts) {
			return "{" + opts._n + super.render(opts) + "}" + opts._n;
		}
	};
	var Root = class extends ParentNode {};
	var Else = class extends BlockNode {};
	Else.kind = "else";
	var If = class If extends BlockNode {
		constructor(condition, nodes) {
			super(nodes);
			this.condition = condition;
		}
		render(opts) {
			let code = `if(${this.condition})` + super.render(opts);
			if (this.else) code += "else " + this.else.render(opts);
			return code;
		}
		optimizeNodes() {
			super.optimizeNodes();
			const cond = this.condition;
			if (cond === true) return this.nodes;
			let e = this.else;
			if (e) {
				const ns = e.optimizeNodes();
				e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
			}
			if (e) {
				if (cond === false) return e instanceof If ? e : e.nodes;
				if (this.nodes.length) return this;
				return new If(not(cond), e instanceof If ? [e] : e.nodes);
			}
			if (cond === false || !this.nodes.length) return undefined;
			return this;
		}
		optimizeNames(names, constants) {
			var _a$1;
			this.else = (_a$1 = this.else) === null || _a$1 === void 0 ? void 0 : _a$1.optimizeNames(names, constants);
			if (!(super.optimizeNames(names, constants) || this.else)) return;
			this.condition = optimizeExpr(this.condition, names, constants);
			return this;
		}
		get names() {
			const names = super.names;
			addExprNames(names, this.condition);
			if (this.else) addNames(names, this.else.names);
			return names;
		}
	};
	If.kind = "if";
	var For = class extends BlockNode {};
	For.kind = "for";
	var ForLoop = class extends For {
		constructor(iteration) {
			super();
			this.iteration = iteration;
		}
		render(opts) {
			return `for(${this.iteration})` + super.render(opts);
		}
		optimizeNames(names, constants) {
			if (!super.optimizeNames(names, constants)) return;
			this.iteration = optimizeExpr(this.iteration, names, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iteration.names);
		}
	};
	var ForRange = class extends For {
		constructor(varKind, name, from, to) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.from = from;
			this.to = to;
		}
		render(opts) {
			const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
			const { name, from, to } = this;
			return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		}
		get names() {
			const names = addExprNames(super.names, this.from);
			return addExprNames(names, this.to);
		}
	};
	var ForIter = class extends For {
		constructor(loop, varKind, name, iterable) {
			super();
			this.loop = loop;
			this.varKind = varKind;
			this.name = name;
			this.iterable = iterable;
		}
		render(opts) {
			return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		}
		optimizeNames(names, constants) {
			if (!super.optimizeNames(names, constants)) return;
			this.iterable = optimizeExpr(this.iterable, names, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iterable.names);
		}
	};
	var Func = class extends BlockNode {
		constructor(name, args, async) {
			super();
			this.name = name;
			this.args = args;
			this.async = async;
		}
		render(opts) {
			const _async = this.async ? "async " : "";
			return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		}
	};
	Func.kind = "func";
	var Return = class extends ParentNode {
		render(opts) {
			return "return " + super.render(opts);
		}
	};
	Return.kind = "return";
	var Try = class extends BlockNode {
		render(opts) {
			let code = "try" + super.render(opts);
			if (this.catch) code += this.catch.render(opts);
			if (this.finally) code += this.finally.render(opts);
			return code;
		}
		optimizeNodes() {
			var _a$1, _b;
			super.optimizeNodes();
			(_a$1 = this.catch) === null || _a$1 === void 0 ? void 0 : _a$1.optimizeNodes();
			(_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
			return this;
		}
		optimizeNames(names, constants) {
			var _a$1, _b;
			super.optimizeNames(names, constants);
			(_a$1 = this.catch) === null || _a$1 === void 0 ? void 0 : _a$1.optimizeNames(names, constants);
			(_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
			return this;
		}
		get names() {
			const names = super.names;
			if (this.catch) addNames(names, this.catch.names);
			if (this.finally) addNames(names, this.finally.names);
			return names;
		}
	};
	var Catch = class extends BlockNode {
		constructor(error$47) {
			super();
			this.error = error$47;
		}
		render(opts) {
			return `catch(${this.error})` + super.render(opts);
		}
	};
	Catch.kind = "catch";
	var Finally = class extends BlockNode {
		render(opts) {
			return "finally" + super.render(opts);
		}
	};
	Finally.kind = "finally";
	var CodeGen = class {
		constructor(extScope, opts = {}) {
			this._values = {};
			this._blockStarts = [];
			this._constants = {};
			this.opts = {
				...opts,
				_n: opts.lines ? "\n" : ""
			};
			this._extScope = extScope;
			this._scope = new scope_1.Scope({ parent: extScope });
			this._nodes = [new Root()];
		}
		toString() {
			return this._root.render(this.opts);
		}
		name(prefix) {
			return this._scope.name(prefix);
		}
		scopeName(prefix) {
			return this._extScope.name(prefix);
		}
		scopeValue(prefixOrName, value) {
			const name = this._extScope.value(prefixOrName, value);
			const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
			vs.add(name);
			return name;
		}
		getScopeValue(prefix, keyOrRef) {
			return this._extScope.getValue(prefix, keyOrRef);
		}
		scopeRefs(scopeName) {
			return this._extScope.scopeRefs(scopeName, this._values);
		}
		scopeCode() {
			return this._extScope.scopeCode(this._values);
		}
		_def(varKind, nameOrPrefix, rhs, constant) {
			const name = this._scope.toName(nameOrPrefix);
			if (rhs !== undefined && constant) this._constants[name.str] = rhs;
			this._leafNode(new Def(varKind, name, rhs));
			return name;
		}
		const(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		}
		let(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		}
		var(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		}
		assign(lhs, rhs, sideEffects) {
			return this._leafNode(new Assign(lhs, rhs, sideEffects));
		}
		add(lhs, rhs) {
			return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		}
		code(c) {
			if (typeof c == "function") c();
			else if (c !== code_1.nil) this._leafNode(new AnyCode(c));
			return this;
		}
		object(...keyValues) {
			const code = ["{"];
			for (const [key, value] of keyValues) {
				if (code.length > 1) code.push(",");
				code.push(key);
				if (key !== value || this.opts.es5) {
					code.push(":");
					(0, code_1.addCodeArg)(code, value);
				}
			}
			code.push("}");
			return new code_1._Code(code);
		}
		if(condition, thenBody, elseBody) {
			this._blockNode(new If(condition));
			if (thenBody && elseBody) {
				this.code(thenBody).else().code(elseBody).endIf();
			} else if (thenBody) {
				this.code(thenBody).endIf();
			} else if (elseBody) {
				throw new Error("CodeGen: \"else\" body without \"then\" body");
			}
			return this;
		}
		elseIf(condition) {
			return this._elseNode(new If(condition));
		}
		else() {
			return this._elseNode(new Else());
		}
		endIf() {
			return this._endBlockNode(If, Else);
		}
		_for(node, forBody) {
			this._blockNode(node);
			if (forBody) this.code(forBody).endFor();
			return this;
		}
		for(iteration, forBody) {
			return this._for(new ForLoop(iteration), forBody);
		}
		forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		}
		forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
			const name = this._scope.toName(nameOrPrefix);
			if (this.opts.es5) {
				const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
				return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
					this.var(name, (0, code_1._)`${arr}[${i}]`);
					forBody(name);
				});
			}
			return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		}
		forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
			if (this.opts.ownProperties) {
				return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
			}
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		}
		endFor() {
			return this._endBlockNode(For);
		}
		label(label) {
			return this._leafNode(new Label(label));
		}
		break(label) {
			return this._leafNode(new Break(label));
		}
		return(value) {
			const node = new Return();
			this._blockNode(node);
			this.code(value);
			if (node.nodes.length !== 1) throw new Error("CodeGen: \"return\" should have one node");
			return this._endBlockNode(Return);
		}
		try(tryBody, catchCode, finallyCode) {
			if (!catchCode && !finallyCode) throw new Error("CodeGen: \"try\" without \"catch\" and \"finally\"");
			const node = new Try();
			this._blockNode(node);
			this.code(tryBody);
			if (catchCode) {
				const error$47 = this.name("e");
				this._currNode = node.catch = new Catch(error$47);
				catchCode(error$47);
			}
			if (finallyCode) {
				this._currNode = node.finally = new Finally();
				this.code(finallyCode);
			}
			return this._endBlockNode(Catch, Finally);
		}
		throw(error$47) {
			return this._leafNode(new Throw(error$47));
		}
		block(body, nodeCount) {
			this._blockStarts.push(this._nodes.length);
			if (body) this.code(body).endBlock(nodeCount);
			return this;
		}
		endBlock(nodeCount) {
			const len = this._blockStarts.pop();
			if (len === undefined) throw new Error("CodeGen: not in self-balancing block");
			const toClose = this._nodes.length - len;
			if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {
				throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
			}
			this._nodes.length = len;
			return this;
		}
		func(name, args = code_1.nil, async, funcBody) {
			this._blockNode(new Func(name, args, async));
			if (funcBody) this.code(funcBody).endFunc();
			return this;
		}
		endFunc() {
			return this._endBlockNode(Func);
		}
		optimize(n = 1) {
			while (n-- > 0) {
				this._root.optimizeNodes();
				this._root.optimizeNames(this._root.names, this._constants);
			}
		}
		_leafNode(node) {
			this._currNode.nodes.push(node);
			return this;
		}
		_blockNode(node) {
			this._currNode.nodes.push(node);
			this._nodes.push(node);
		}
		_endBlockNode(N1, N2) {
			const n = this._currNode;
			if (n instanceof N1 || N2 && n instanceof N2) {
				this._nodes.pop();
				return this;
			}
			throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		}
		_elseNode(node) {
			const n = this._currNode;
			if (!(n instanceof If)) {
				throw new Error("CodeGen: \"else\" without \"if\"");
			}
			this._currNode = n.else = node;
			return this;
		}
		get _root() {
			return this._nodes[0];
		}
		get _currNode() {
			const ns = this._nodes;
			return ns[ns.length - 1];
		}
		set _currNode(node) {
			const ns = this._nodes;
			ns[ns.length - 1] = node;
		}
	};
	exports.CodeGen = CodeGen;
	function addNames(names, from) {
		for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);
		return names;
	}
	function addExprNames(names, from) {
		return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
	}
	function optimizeExpr(expr, names, constants) {
		if (expr instanceof code_1.Name) return replaceName(expr);
		if (!canOptimize(expr)) return expr;
		return new code_1._Code(expr._items.reduce((items, c) => {
			if (c instanceof code_1.Name) c = replaceName(c);
			if (c instanceof code_1._Code) items.push(...c._items);
			else items.push(c);
			return items;
		}, []));
		function replaceName(n) {
			const c = constants[n.str];
			if (c === undefined || names[n.str] !== 1) return n;
			delete names[n.str];
			return c;
		}
		function canOptimize(e) {
			return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);
		}
	}
	function subtractNames(names, from) {
		for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);
	}
	function not(x) {
		return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
	}
	exports.not = not;
	const andCode = mappend(exports.operators.AND);
	function and(...args) {
		return args.reduce(andCode);
	}
	exports.and = and;
	const orCode = mappend(exports.operators.OR);
	function or(...args) {
		return args.reduce(orCode);
	}
	exports.or = or;
	function mappend(op) {
		return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
	}
	function par(x) {
		return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/util.js
var require_util = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
	const codegen_1 = require_codegen();
	const code_1 = require_code$1();
	function toHash(arr) {
		const hash$2 = {};
		for (const item of arr) hash$2[item] = true;
		return hash$2;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema) {
		if (typeof schema == "boolean") return schema;
		if (Object.keys(schema).length === 0) return true;
		checkUnknownRules(it, schema);
		return !schemaHasRules(schema, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
		const { opts, self } = it;
		if (!opts.strictSchema) return;
		if (typeof schema === "boolean") return;
		const rules = self.RULES.keywords;
		for (const key in schema) {
			if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
		}
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
		if (typeof schema == "boolean") return !schema;
		for (const key in schema) if (rules[key]) return true;
		return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
		if (typeof schema == "boolean") return !schema;
		for (const key in schema) if (key !== "$ref" && RULES.all[key]) return true;
		return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
		if (!$data) {
			if (typeof schema == "number" || typeof schema == "boolean") return schema;
			if (typeof schema == "string") return (0, codegen_1._)`${schema}`;
		}
		return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
		return unescapeJsonPointer(decodeURIComponent(str));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
		return encodeURIComponent(escapeJsonPointer(str));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
		if (typeof str == "number") return `${str}`;
		return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
		return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
		if (Array.isArray(xs)) {
			for (const x of xs) f(x);
		} else {
			f(xs);
		}
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues$2, resultToName }) {
		return (gen, from, to, toName) => {
			const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues$2(from, to);
			return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
		};
	}
	exports.mergeEvaluated = {
		props: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
				gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
			}),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
				if (from === true) {
					gen.assign(to, true);
				} else {
					gen.assign(to, (0, codegen_1._)`${to} || {}`);
					setEvaluated(gen, to, from);
				}
			}),
			mergeValues: (from, to) => from === true ? true : {
				...from,
				...to
			},
			resultToName: evaluatedPropsToName
		}),
		items: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
			mergeValues: (from, to) => from === true ? true : Math.max(from, to),
			resultToName: (gen, items) => gen.var("items", items)
		})
	};
	function evaluatedPropsToName(gen, ps) {
		if (ps === true) return gen.var("props", true);
		const props = gen.var("props", (0, codegen_1._)`{}`);
		if (ps !== undefined) setEvaluated(gen, props, ps);
		return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
		Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
		return gen.scopeValue("func", {
			ref: f,
			code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
		});
	}
	exports.useFunc = useFunc;
	var Type;
	(function(Type) {
		Type[Type["Num"] = 0] = "Num";
		Type[Type["Str"] = 1] = "Str";
	})(Type || (exports.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
		if (dataProp instanceof codegen_1.Name) {
			const isNumber = dataPropType === Type.Num;
			return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
		}
		return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
		if (!mode) return;
		msg = `strict mode: ${msg}`;
		if (mode === true) throw new Error(msg);
		it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/names.js
var require_names = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const names = {
		data: new codegen_1.Name("data"),
		valCxt: new codegen_1.Name("valCxt"),
		instancePath: new codegen_1.Name("instancePath"),
		parentData: new codegen_1.Name("parentData"),
		parentDataProperty: new codegen_1.Name("parentDataProperty"),
		rootData: new codegen_1.Name("rootData"),
		dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
		vErrors: new codegen_1.Name("vErrors"),
		errors: new codegen_1.Name("errors"),
		this: new codegen_1.Name("this"),
		self: new codegen_1.Name("self"),
		scope: new codegen_1.Name("scope"),
		json: new codegen_1.Name("json"),
		jsonPos: new codegen_1.Name("jsonPos"),
		jsonLen: new codegen_1.Name("jsonLen"),
		jsonPart: new codegen_1.Name("jsonPart")
	};
	exports.default = names;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/errors.js
var require_errors = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const names_1 = require_names();
	exports.keywordError = { message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation` };
	exports.keyword$DataError = { message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)` };
	function reportError(cxt, error$47 = exports.keywordError, errorPaths, overrideAllErrors) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		const errObj = errorObjectCode(cxt, error$47, errorPaths);
		if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
			addError(gen, errObj);
		} else {
			returnErrors(it, (0, codegen_1._)`[${errObj}]`);
		}
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error$47 = exports.keywordError, errorPaths) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		const errObj = errorObjectCode(cxt, error$47, errorPaths);
		addError(gen, errObj);
		if (!(compositeRule || allErrors)) {
			returnErrors(it, names_1.default.vErrors);
		}
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
		gen.assign(names_1.default.errors, errsCount);
		gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
		/* istanbul ignore if */
		if (errsCount === undefined) throw new Error("ajv implementation error");
		const err = gen.name("err");
		gen.forRange("i", errsCount, names_1.default.errors, (i) => {
			gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
			gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
			gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
			if (it.opts.verbose) {
				gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
				gen.assign((0, codegen_1._)`${err}.data`, data);
			}
		});
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
		const err = gen.const("err", errObj);
		gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
		gen.code((0, codegen_1._)`${names_1.default.errors}++`);
	}
	function returnErrors(it, errs) {
		const { gen, validateName, schemaEnv } = it;
		if (schemaEnv.$async) {
			gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
		} else {
			gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
			gen.return(false);
		}
	}
	const E = {
		keyword: new codegen_1.Name("keyword"),
		schemaPath: new codegen_1.Name("schemaPath"),
		params: new codegen_1.Name("params"),
		propertyName: new codegen_1.Name("propertyName"),
		message: new codegen_1.Name("message"),
		schema: new codegen_1.Name("schema"),
		parentSchema: new codegen_1.Name("parentSchema")
	};
	function errorObjectCode(cxt, error$47, errorPaths) {
		const { createErrors } = cxt.it;
		if (createErrors === false) return (0, codegen_1._)`{}`;
		return errorObject(cxt, error$47, errorPaths);
	}
	function errorObject(cxt, error$47, errorPaths = {}) {
		const { gen, it } = cxt;
		const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];
		extraErrorProps(cxt, error$47, keyValues);
		return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
		const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
		return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
		if (schemaPath) {
			schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		}
		return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
		const { keyword, data, schemaValue, it } = cxt;
		const { opts, propertyName, topSchemaRef, schemaPath } = it;
		keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
		if (opts.messages) {
			keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		}
		if (opts.verbose) {
			keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		}
		if (propertyName) keyValues.push([E.propertyName, propertyName]);
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
	const errors_1 = require_errors();
	const codegen_1 = require_codegen();
	const names_1 = require_names();
	const boolError = { message: "boolean schema is false" };
	function topBoolOrEmptySchema(it) {
		const { gen, schema, validateName } = it;
		if (schema === false) {
			falseSchemaError(it, false);
		} else if (typeof schema == "object" && schema.$async === true) {
			gen.return(names_1.default.data);
		} else {
			gen.assign((0, codegen_1._)`${validateName}.errors`, null);
			gen.return(true);
		}
	}
	exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
		const { gen, schema } = it;
		if (schema === false) {
			gen.var(valid, false);
			falseSchemaError(it);
		} else {
			gen.var(valid, true);
		}
	}
	exports.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
		const { gen, data } = it;
		const cxt = {
			gen,
			keyword: "false schema",
			data,
			schema: false,
			schemaCode: false,
			schemaValue: false,
			params: {},
			it
		};
		(0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/rules.js
var require_rules = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRules = exports.isJSONType = void 0;
	const _jsonTypes = [
		"string",
		"number",
		"integer",
		"boolean",
		"null",
		"object",
		"array"
	];
	const jsonTypes = new Set(_jsonTypes);
	function isJSONType(x) {
		return typeof x == "string" && jsonTypes.has(x);
	}
	exports.isJSONType = isJSONType;
	function getRules() {
		const groups = {
			number: {
				type: "number",
				rules: []
			},
			string: {
				type: "string",
				rules: []
			},
			array: {
				type: "array",
				rules: []
			},
			object: {
				type: "object",
				rules: []
			}
		};
		return {
			types: {
				...groups,
				integer: true,
				boolean: true,
				null: true
			},
			rules: [
				{ rules: [] },
				groups.number,
				groups.string,
				groups.array,
				groups.object
			],
			post: { rules: [] },
			all: {},
			keywords: {}
		};
	}
	exports.getRules = getRules;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
		const group = self.RULES.types[type];
		return group && group !== true && shouldUseGroup(schema, group);
	}
	exports.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
		return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	exports.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
		var _a$1;
		return schema[rule.keyword] !== undefined || ((_a$1 = rule.definition.implements) === null || _a$1 === void 0 ? void 0 : _a$1.some((kwd) => schema[kwd] !== undefined));
	}
	exports.shouldUseRule = shouldUseRule;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
	const rules_1 = require_rules();
	const applicability_1 = require_applicability();
	const errors_1 = require_errors();
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	var DataType;
	(function(DataType) {
		DataType[DataType["Correct"] = 0] = "Correct";
		DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType || (exports.DataType = DataType = {}));
	function getSchemaTypes(schema) {
		const types = getJSONTypes(schema.type);
		const hasNull = types.includes("null");
		if (hasNull) {
			if (schema.nullable === false) throw new Error("type: null contradicts nullable: false");
		} else {
			if (!types.length && schema.nullable !== undefined) {
				throw new Error("\"nullable\" cannot be used without \"type\"");
			}
			if (schema.nullable === true) types.push("null");
		}
		return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
		const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
		if (types.every(rules_1.isJSONType)) return types;
		throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
		const { gen, data, opts } = it;
		const coerceTo = coerceToTypes(types, opts.coerceTypes);
		const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
		if (checkTypes) {
			const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
			gen.if(wrongType, () => {
				if (coerceTo.length) coerceData(it, types, coerceTo);
				else reportTypeError(it);
			});
		}
		return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(types, coerceTypes) {
		return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
	}
	function coerceData(it, types, coerceTo) {
		const { gen, data, opts } = it;
		const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
		const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
		if (opts.coerceTypes === "array") {
			gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
		}
		gen.if((0, codegen_1._)`${coerced} !== undefined`);
		for (const t of coerceTo) {
			if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
				coerceSpecificType(t);
			}
		}
		gen.else();
		reportTypeError(it);
		gen.endIf();
		gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
			gen.assign(data, coerced);
			assignParentData(it, coerced);
		});
		function coerceSpecificType(t) {
			switch (t) {
				case "string":
					gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
					return;
				case "number":
					gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
					return;
				case "integer":
					gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
					return;
				case "boolean":
					gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
					return;
				case "null":
					gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
					gen.assign(coerced, null);
					return;
				case "array": gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
			}
		}
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
		gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
		const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
		let cond;
		switch (dataType) {
			case "null": return (0, codegen_1._)`${data} ${EQ} null`;
			case "array":
				cond = (0, codegen_1._)`Array.isArray(${data})`;
				break;
			case "object":
				cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
				break;
			case "integer":
				cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
				break;
			case "number":
				cond = numCond();
				break;
			default: return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
		}
		return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
		function numCond(_cond = codegen_1.nil) {
			return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
		}
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
		if (dataTypes.length === 1) {
			return checkDataType(dataTypes[0], data, strictNums, correct);
		}
		let cond;
		const types = (0, util_1.toHash)(dataTypes);
		if (types.array && types.object) {
			const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
			cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
			delete types.null;
			delete types.array;
			delete types.object;
		} else {
			cond = codegen_1.nil;
		}
		if (types.number) delete types.integer;
		for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
		return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
		message: ({ schema }) => `must be ${schema}`,
		params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
	};
	function reportTypeError(it) {
		const cxt = getTypeErrorContext(it);
		(0, errors_1.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
		const { gen, data, schema } = it;
		const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
		return {
			gen,
			keyword: "type",
			data,
			schema: schema.type,
			schemaCode,
			schemaValue: schemaCode,
			parentSchema: schema,
			params: {},
			it
		};
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.assignDefaults = void 0;
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	function assignDefaults(it, ty) {
		const { properties, items } = it.schema;
		if (ty === "object" && properties) {
			for (const key in properties) {
				assignDefault(it, key, properties[key].default);
			}
		} else if (ty === "array" && Array.isArray(items)) {
			items.forEach((sch, i) => assignDefault(it, i, sch.default));
		}
	}
	exports.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
		const { gen, compositeRule, data, opts } = it;
		if (defaultValue === undefined) return;
		const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
		if (compositeRule) {
			(0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
			return;
		}
		let condition = (0, codegen_1._)`${childData} === undefined`;
		if (opts.useDefaults === "empty") {
			condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
		}
		gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/code.js
var require_code = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const names_1 = require_names();
	const util_2 = require_util();
	function checkReportMissingProp(cxt, prop) {
		const { gen, data, it } = cxt;
		gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
			cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
			cxt.error();
		});
	}
	exports.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
		return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
	}
	exports.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
		cxt.setParams({ missingProperty: missing }, true);
		cxt.error();
	}
	exports.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
		return gen.scopeValue("func", {
			ref: Object.prototype.hasOwnProperty,
			code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
		});
	}
	exports.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
		return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	exports.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
		return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	exports.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
		return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	exports.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
		return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	exports.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
		return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	exports.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
		const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
		const valCxt = [
			[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
			[names_1.default.parentData, it.parentData],
			[names_1.default.parentDataProperty, it.parentDataProperty],
			[names_1.default.rootData, names_1.default.rootData]
		];
		if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
		const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
		return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
	}
	exports.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._)`new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
		const u = opts.unicodeRegExp ? "u" : "";
		const { regExp } = opts.code;
		const rx = regExp(pattern, u);
		return gen.scopeValue("pattern", {
			key: rx.toString(),
			ref: rx,
			code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
		});
	}
	exports.usePattern = usePattern;
	function validateArray(cxt) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		if (it.allErrors) {
			const validArr = gen.let("valid", true);
			validateItems(() => gen.assign(validArr, false));
			return validArr;
		}
		gen.var(valid, true);
		validateItems(() => gen.break());
		return valid;
		function validateItems(notValid) {
			const len = gen.const("len", (0, codegen_1._)`${data}.length`);
			gen.forRange("i", 0, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1.Type.Num
				}, valid);
				gen.if((0, codegen_1.not)(valid), notValid);
			});
		}
	}
	exports.validateArray = validateArray;
	function validateUnion(cxt) {
		const { gen, schema, keyword, it } = cxt;
		/* istanbul ignore if */
		if (!Array.isArray(schema)) throw new Error("ajv implementation error");
		const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
		if (alwaysValid && !it.opts.unevaluated) return;
		const valid = gen.let("valid", false);
		const schValid = gen.name("_valid");
		gen.block(() => schema.forEach((_sch, i) => {
			const schCxt = cxt.subschema({
				keyword,
				schemaProp: i,
				compositeRule: true
			}, schValid);
			gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
			const merged = cxt.mergeValidEvaluated(schCxt, schValid);
			if (!merged) gen.if((0, codegen_1.not)(valid));
		}));
		cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	exports.validateUnion = validateUnion;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
	const codegen_1 = require_codegen();
	const names_1 = require_names();
	const code_1 = require_code();
	const errors_1 = require_errors();
	function macroKeywordCode(cxt, def) {
		const { gen, keyword, schema, parentSchema, it } = cxt;
		const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
		const schemaRef = useKeyword(gen, keyword, macroSchema);
		if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
		const valid = gen.name("valid");
		cxt.subschema({
			schema: macroSchema,
			schemaPath: codegen_1.nil,
			errSchemaPath: `${it.errSchemaPath}/${keyword}`,
			topSchemaRef: schemaRef,
			compositeRule: true
		}, valid);
		cxt.pass(valid, () => cxt.error(true));
	}
	exports.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
		var _a$1;
		const { gen, keyword, schema, parentSchema, $data, it } = cxt;
		checkAsyncKeyword(it, def);
		const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
		const validateRef = useKeyword(gen, keyword, validate);
		const valid = gen.let("valid");
		cxt.block$data(valid, validateKeyword);
		cxt.ok((_a$1 = def.valid) !== null && _a$1 !== void 0 ? _a$1 : valid);
		function validateKeyword() {
			if (def.errors === false) {
				assignValid();
				if (def.modifying) modifyData(cxt);
				reportErrs(() => cxt.error());
			} else {
				const ruleErrs = def.async ? validateAsync() : validateSync();
				if (def.modifying) modifyData(cxt);
				reportErrs(() => addErrs(cxt, ruleErrs));
			}
		}
		function validateAsync() {
			const ruleErrs = gen.let("ruleErrs", null);
			gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
			return ruleErrs;
		}
		function validateSync() {
			const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
			gen.assign(validateErrs, null);
			assignValid(codegen_1.nil);
			return validateErrs;
		}
		function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
			const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
			const passSchema = !("compile" in def && !$data || def.schema === false);
			gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
		}
		function reportErrs(errors) {
			var _a$2;
			gen.if((0, codegen_1.not)((_a$2 = def.valid) !== null && _a$2 !== void 0 ? _a$2 : valid), errors);
		}
	}
	exports.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
		const { gen, data, it } = cxt;
		gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
		const { gen } = cxt;
		gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
			gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
			(0, errors_1.extendErrors)(cxt);
		}, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
		if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
		if (result === undefined) throw new Error(`keyword "${keyword}" failed to compile`);
		return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : {
			ref: result,
			code: (0, codegen_1.stringify)(result)
		});
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
		return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
	}
	exports.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
		/* istanbul ignore if */
		if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
			throw new Error("ajv implementation error");
		}
		const deps = def.dependencies;
		if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
			throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
		}
		if (def.validateSchema) {
			const valid = def.validateSchema(schema[keyword]);
			if (!valid) {
				const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
				if (opts.validateSchema === "log") self.logger.error(msg);
				else throw new Error(msg);
			}
		}
	}
	exports.validateKeywordUsage = validateKeywordUsage;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
		if (keyword !== undefined && schema !== undefined) {
			throw new Error("both \"keyword\" and \"schema\" passed, only one allowed");
		}
		if (keyword !== undefined) {
			const sch = it.schema[keyword];
			return schemaProp === undefined ? {
				schema: sch,
				schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}`
			} : {
				schema: sch[schemaProp],
				schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
			};
		}
		if (schema !== undefined) {
			if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
				throw new Error("\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"");
			}
			return {
				schema,
				schemaPath,
				topSchemaRef,
				errSchemaPath
			};
		}
		throw new Error("either \"keyword\" or \"schema\" must be passed");
	}
	exports.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
		if (data !== undefined && dataProp !== undefined) {
			throw new Error("both \"data\" and \"dataProp\" passed, only one allowed");
		}
		const { gen } = it;
		if (dataProp !== undefined) {
			const { errorPath, dataPathArr, opts } = it;
			const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
			dataContextProps(nextData);
			subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
			subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
			subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
		}
		if (data !== undefined) {
			const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
			dataContextProps(nextData);
			if (propertyName !== undefined) subschema.propertyName = propertyName;
		}
		if (dataTypes) subschema.dataTypes = dataTypes;
		function dataContextProps(_nextData) {
			subschema.data = _nextData;
			subschema.dataLevel = it.dataLevel + 1;
			subschema.dataTypes = [];
			it.definedProperties = new Set();
			subschema.parentData = it.data;
			subschema.dataNames = [...it.dataNames, _nextData];
		}
	}
	exports.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
		if (compositeRule !== undefined) subschema.compositeRule = compositeRule;
		if (createErrors !== undefined) subschema.createErrors = createErrors;
		if (allErrors !== undefined) subschema.allErrors = allErrors;
		subschema.jtdDiscriminator = jtdDiscriminator;
		subschema.jtdMetadata = jtdMetadata;
	}
	exports.extendSubschemaMode = extendSubschemaMode;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function equal(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
			for (i = length; i-- !== 0;) {
				var key = keys[i];
				if (!equal(a[key], b[key])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var traverse = module.exports = function(schema, opts, cb) {
		if (typeof opts == "function") {
			cb = opts;
			opts = {};
		}
		cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {};
		var post = cb.post || function() {};
		_traverse(opts, pre, post, schema, "", schema);
	};
	traverse.keywords = {
		additionalItems: true,
		items: true,
		contains: true,
		additionalProperties: true,
		propertyNames: true,
		not: true,
		if: true,
		then: true,
		else: true
	};
	traverse.arrayKeywords = {
		items: true,
		allOf: true,
		anyOf: true,
		oneOf: true
	};
	traverse.propsKeywords = {
		$defs: true,
		definitions: true,
		properties: true,
		patternProperties: true,
		dependencies: true
	};
	traverse.skipKeywords = {
		default: true,
		enum: true,
		const: true,
		required: true,
		maximum: true,
		minimum: true,
		exclusiveMaximum: true,
		exclusiveMinimum: true,
		multipleOf: true,
		maxLength: true,
		minLength: true,
		pattern: true,
		format: true,
		maxItems: true,
		minItems: true,
		uniqueItems: true,
		maxProperties: true,
		minProperties: true
	};
	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema && typeof schema == "object" && !Array.isArray(schema)) {
			pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
			for (var key in schema) {
				var sch = schema[key];
				if (Array.isArray(sch)) {
					if (key in traverse.arrayKeywords) {
						for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
					}
				} else if (key in traverse.propsKeywords) {
					if (sch && typeof sch == "object") {
						for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
					}
				} else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
					_traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
				}
			}
			post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str) {
		return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/resolve.js
var require_resolve = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
	const util_1 = require_util();
	const equal = require_fast_deep_equal();
	const traverse = require_json_schema_traverse();
	const SIMPLE_INLINED = new Set([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum",
		"const"
	]);
	function inlineRef(schema, limit = true) {
		if (typeof schema == "boolean") return true;
		if (limit === true) return !hasRef(schema);
		if (!limit) return false;
		return countKeys(schema) <= limit;
	}
	exports.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
		"$ref",
		"$recursiveRef",
		"$recursiveAnchor",
		"$dynamicRef",
		"$dynamicAnchor"
	]);
	function hasRef(schema) {
		for (const key in schema) {
			if (REF_KEYWORDS.has(key)) return true;
			const sch = schema[key];
			if (Array.isArray(sch) && sch.some(hasRef)) return true;
			if (typeof sch == "object" && hasRef(sch)) return true;
		}
		return false;
	}
	function countKeys(schema) {
		let count = 0;
		for (const key in schema) {
			if (key === "$ref") return Infinity;
			count++;
			if (SIMPLE_INLINED.has(key)) continue;
			if (typeof schema[key] == "object") {
				(0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
			}
			if (count === Infinity) return Infinity;
		}
		return count;
	}
	function getFullPath(resolver, id = "", normalize) {
		if (normalize !== false) id = normalizeId(id);
		const p = resolver.parse(id);
		return _getFullPath(resolver, p);
	}
	exports.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
		const serialized = resolver.serialize(p);
		return serialized.split("#")[0] + "#";
	}
	exports._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	exports.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
		id = normalizeId(id);
		return resolver.resolve(baseId, id);
	}
	exports.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
		if (typeof schema == "boolean") return {};
		const { schemaId, uriResolver } = this.opts;
		const schId = normalizeId(schema[schemaId] || baseId);
		const baseIds = { "": schId };
		const pathPrefix = getFullPath(uriResolver, schId, false);
		const localRefs = {};
		const schemaRefs = new Set();
		traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
			if (parentJsonPtr === undefined) return;
			const fullPath = pathPrefix + jsonPtr;
			let innerBaseId = baseIds[parentJsonPtr];
			if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId]);
			addAnchor.call(this, sch.$anchor);
			addAnchor.call(this, sch.$dynamicAnchor);
			baseIds[jsonPtr] = innerBaseId;
			function addRef(ref) {
				const _resolve = this.opts.uriResolver.resolve;
				ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
				if (schemaRefs.has(ref)) throw ambiguos(ref);
				schemaRefs.add(ref);
				let schOrRef = this.refs[ref];
				if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
				if (typeof schOrRef == "object") {
					checkAmbiguosRef(sch, schOrRef.schema, ref);
				} else if (ref !== normalizeId(fullPath)) {
					if (ref[0] === "#") {
						checkAmbiguosRef(sch, localRefs[ref], ref);
						localRefs[ref] = sch;
					} else {
						this.refs[ref] = fullPath;
					}
				}
				return ref;
			}
			function addAnchor(anchor) {
				if (typeof anchor == "string") {
					if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
					addRef.call(this, `#${anchor}`);
				}
			}
		});
		return localRefs;
		function checkAmbiguosRef(sch1, sch2, ref) {
			if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);
		}
		function ambiguos(ref) {
			return new Error(`reference "${ref}" resolves to more than one schema`);
		}
	}
	exports.getSchemaRefs = getSchemaRefs;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/validate/index.js
var require_validate = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
	const boolSchema_1 = require_boolSchema();
	const dataType_1 = require_dataType();
	const applicability_1 = require_applicability();
	const dataType_2 = require_dataType();
	const defaults_1 = require_defaults();
	const keyword_1 = require_keyword();
	const subschema_1 = require_subschema();
	const codegen_1 = require_codegen();
	const names_1 = require_names();
	const resolve_1 = require_resolve();
	const util_1 = require_util();
	const errors_1 = require_errors();
	function validateFunctionCode(it) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				topSchemaObjCode(it);
				return;
			}
		}
		validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	exports.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
		if (opts.code.es5) {
			gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
				gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
				destructureValCxtES5(gen, opts);
				gen.code(body);
			});
		} else {
			gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
		}
	}
	function destructureValCxt(opts) {
		return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
		gen.if(names_1.default.valCxt, () => {
			gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
			gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
			gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
			gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
			if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
		}, () => {
			gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
			gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
			gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
			gen.var(names_1.default.rootData, names_1.default.data);
			if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
		});
	}
	function topSchemaObjCode(it) {
		const { schema, opts, gen } = it;
		validateFunction(it, () => {
			if (opts.$comment && schema.$comment) commentKeyword(it);
			checkNoDefault(it);
			gen.let(names_1.default.vErrors, null);
			gen.let(names_1.default.errors, 0);
			if (opts.unevaluated) resetEvaluated(it);
			typeAndKeywords(it);
			returnResults(it);
		});
		return;
	}
	function resetEvaluated(it) {
		const { gen, validateName } = it;
		it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
		gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
		gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
	}
	function funcSourceUrl(schema, opts) {
		const schId = typeof schema == "object" && schema[opts.schemaId];
		return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	function subschemaCode(it, valid) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				subSchemaObjCode(it, valid);
				return;
			}
		}
		(0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
		if (typeof schema == "boolean") return !schema;
		for (const key in schema) if (self.RULES.all[key]) return true;
		return false;
	}
	function isSchemaObj(it) {
		return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
		const { schema, gen, opts } = it;
		if (opts.$comment && schema.$comment) commentKeyword(it);
		updateContext(it);
		checkAsyncSchema(it);
		const errsCount = gen.const("_errs", names_1.default.errors);
		typeAndKeywords(it, errsCount);
		gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
		(0, util_1.checkUnknownRules)(it);
		checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
		if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
		const types = (0, dataType_1.getSchemaTypes)(it.schema);
		const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
		schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
		const { schema, errSchemaPath, opts, self } = it;
		if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
			self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
		}
	}
	function checkNoDefault(it) {
		const { schema, opts } = it;
		if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
			(0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
		}
	}
	function updateContext(it) {
		const schId = it.schema[it.opts.schemaId];
		if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
		if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
		const msg = schema.$comment;
		if (opts.$comment === true) {
			gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
		} else if (typeof opts.$comment == "function") {
			const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
			const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
			gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
		}
	}
	function returnResults(it) {
		const { gen, schemaEnv, validateName, ValidationError, opts } = it;
		if (schemaEnv.$async) {
			gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
		} else {
			gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
			if (opts.unevaluated) assignEvaluated(it);
			gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
		}
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
		if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);
		if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
		const { gen, schema, data, allErrors, opts, self } = it;
		const { RULES } = self;
		if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
			gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
			return;
		}
		if (!opts.jtd) checkStrictTypes(it, types);
		gen.block(() => {
			for (const group of RULES.rules) groupKeywords(group);
			groupKeywords(RULES.post);
		});
		function groupKeywords(group) {
			if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;
			if (group.type) {
				gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
				iterateKeywords(it, group);
				if (types.length === 1 && types[0] === group.type && typeErrors) {
					gen.else();
					(0, dataType_2.reportTypeError)(it);
				}
				gen.endIf();
			} else {
				iterateKeywords(it, group);
			}
			if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
		}
	}
	function iterateKeywords(it, group) {
		const { gen, schema, opts: { useDefaults } } = it;
		if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
		gen.block(() => {
			for (const rule of group.rules) {
				if ((0, applicability_1.shouldUseRule)(schema, rule)) {
					keywordCode(it, rule.keyword, rule.definition, group.type);
				}
			}
		});
	}
	function checkStrictTypes(it, types) {
		if (it.schemaEnv.meta || !it.opts.strictTypes) return;
		checkContextTypes(it, types);
		if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
		checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
		if (!types.length) return;
		if (!it.dataTypes.length) {
			it.dataTypes = types;
			return;
		}
		types.forEach((t) => {
			if (!includesType(it.dataTypes, t)) {
				strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
			}
		});
		narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
		if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
			strictTypesError(it, "use allowUnionTypes to allow union type keyword");
		}
	}
	function checkKeywordTypes(it, ts) {
		const rules = it.self.RULES.all;
		for (const keyword in rules) {
			const rule = rules[keyword];
			if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
				const { type } = rule.definition;
				if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
					strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
				}
			}
		}
	}
	function hasApplicableType(schTs, kwdT) {
		return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
	}
	function includesType(ts, t) {
		return ts.includes(t) || t === "integer" && ts.includes("number");
	}
	function narrowSchemaTypes(it, withTypes) {
		const ts = [];
		for (const t of it.dataTypes) {
			if (includesType(withTypes, t)) ts.push(t);
			else if (withTypes.includes("integer") && t === "number") ts.push("integer");
		}
		it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
		const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
		msg += ` at "${schemaPath}" (strictTypes)`;
		(0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	var KeywordCxt = class {
		constructor(it, def, keyword) {
			(0, keyword_1.validateKeywordUsage)(it, def, keyword);
			this.gen = it.gen;
			this.allErrors = it.allErrors;
			this.keyword = keyword;
			this.data = it.data;
			this.schema = it.schema[keyword];
			this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
			this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
			this.schemaType = def.schemaType;
			this.parentSchema = it.schema;
			this.params = {};
			this.it = it;
			this.def = def;
			if (this.$data) {
				this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
			} else {
				this.schemaCode = this.schemaValue;
				if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
					throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
				}
			}
			if ("code" in def ? def.trackErrors : def.errors !== false) {
				this.errsCount = it.gen.const("_errs", names_1.default.errors);
			}
		}
		result(condition, successAction, failAction) {
			this.failResult((0, codegen_1.not)(condition), successAction, failAction);
		}
		failResult(condition, successAction, failAction) {
			this.gen.if(condition);
			if (failAction) failAction();
			else this.error();
			if (successAction) {
				this.gen.else();
				successAction();
				if (this.allErrors) this.gen.endIf();
			} else {
				if (this.allErrors) this.gen.endIf();
				else this.gen.else();
			}
		}
		pass(condition, failAction) {
			this.failResult((0, codegen_1.not)(condition), undefined, failAction);
		}
		fail(condition) {
			if (condition === undefined) {
				this.error();
				if (!this.allErrors) this.gen.if(false);
				return;
			}
			this.gen.if(condition);
			this.error();
			if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		fail$data(condition) {
			if (!this.$data) return this.fail(condition);
			const { schemaCode } = this;
			this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
		}
		error(append, errorParams, errorPaths) {
			if (errorParams) {
				this.setParams(errorParams);
				this._error(append, errorPaths);
				this.setParams({});
				return;
			}
			this._error(append, errorPaths);
		}
		_error(append, errorPaths) {
			;
			(append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
		}
		$dataError() {
			(0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
		}
		reset() {
			if (this.errsCount === undefined) throw new Error("add \"trackErrors\" to keyword definition");
			(0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
		}
		ok(cond) {
			if (!this.allErrors) this.gen.if(cond);
		}
		setParams(obj, assign) {
			if (assign) Object.assign(this.params, obj);
			else this.params = obj;
		}
		block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
			this.gen.block(() => {
				this.check$data(valid, $dataValid);
				codeBlock();
			});
		}
		check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
			if (!this.$data) return;
			const { gen, schemaCode, schemaType, def } = this;
			gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
			if (valid !== codegen_1.nil) gen.assign(valid, true);
			if (schemaType.length || def.validateSchema) {
				gen.elseIf(this.invalid$data());
				this.$dataError();
				if (valid !== codegen_1.nil) gen.assign(valid, false);
			}
			gen.else();
		}
		invalid$data() {
			const { gen, schemaCode, schemaType, def, it } = this;
			return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
			function wrong$DataType() {
				if (schemaType.length) {
					/* istanbul ignore if */
					if (!(schemaCode instanceof codegen_1.Name)) throw new Error("ajv implementation error");
					const st = Array.isArray(schemaType) ? schemaType : [schemaType];
					return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
				}
				return codegen_1.nil;
			}
			function invalid$DataSchema() {
				if (def.validateSchema) {
					const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
					return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
				}
				return codegen_1.nil;
			}
		}
		subschema(appl, valid) {
			const subschema = (0, subschema_1.getSubschema)(this.it, appl);
			(0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
			(0, subschema_1.extendSubschemaMode)(subschema, appl);
			const nextContext = {
				...this.it,
				...subschema,
				items: undefined,
				props: undefined
			};
			subschemaCode(nextContext, valid);
			return nextContext;
		}
		mergeEvaluated(schemaCxt, toName) {
			const { it, gen } = this;
			if (!it.opts.unevaluated) return;
			if (it.props !== true && schemaCxt.props !== undefined) {
				it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
			}
			if (it.items !== true && schemaCxt.items !== undefined) {
				it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
			}
		}
		mergeValidEvaluated(schemaCxt, valid) {
			const { it, gen } = this;
			if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
				gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
				return true;
			}
		}
	};
	exports.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
		const cxt = new KeywordCxt(it, def, keyword);
		if ("code" in def) {
			def.code(cxt, ruleType);
		} else if (cxt.$data && def.validate) {
			(0, keyword_1.funcKeywordCode)(cxt, def);
		} else if ("macro" in def) {
			(0, keyword_1.macroKeywordCode)(cxt, def);
		} else if (def.compile || def.validate) {
			(0, keyword_1.funcKeywordCode)(cxt, def);
		}
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
		let jsonPointer;
		let data;
		if ($data === "") return names_1.default.rootData;
		if ($data[0] === "/") {
			if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
			jsonPointer = $data;
			data = names_1.default.rootData;
		} else {
			const matches = RELATIVE_JSON_POINTER.exec($data);
			if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
			const up = +matches[1];
			jsonPointer = matches[2];
			if (jsonPointer === "#") {
				if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
				return dataPathArr[dataLevel - up];
			}
			if (up > dataLevel) throw new Error(errorMsg("data", up));
			data = dataNames[dataLevel - up];
			if (!jsonPointer) return data;
		}
		let expr = data;
		const segments = jsonPointer.split("/");
		for (const segment of segments) {
			if (segment) {
				data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
				expr = (0, codegen_1._)`${expr} && ${data}`;
			}
		}
		return expr;
		function errorMsg(pointerType, up) {
			return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
		}
	}
	exports.getData = getData;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ValidationError = class extends Error {
		constructor(errors) {
			super("validation failed");
			this.errors = errors;
			this.ajv = this.validation = true;
		}
	};
	exports.default = ValidationError;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const resolve_1 = require_resolve();
	var MissingRefError = class extends Error {
		constructor(resolver, baseId, ref, msg) {
			super(msg || `can't resolve reference ${ref} from id ${baseId}`);
			this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
			this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
		}
	};
	exports.default = MissingRefError;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/compile/index.js
var require_compile = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
	const codegen_1 = require_codegen();
	const validation_error_1 = require_validation_error();
	const names_1 = require_names();
	const resolve_1 = require_resolve();
	const util_1 = require_util();
	const validate_1 = require_validate();
	var SchemaEnv = class {
		constructor(env) {
			var _a$1;
			this.refs = {};
			this.dynamicAnchors = {};
			let schema;
			if (typeof env.schema == "object") schema = env.schema;
			this.schema = env.schema;
			this.schemaId = env.schemaId;
			this.root = env.root || this;
			this.baseId = (_a$1 = env.baseId) !== null && _a$1 !== void 0 ? _a$1 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
			this.schemaPath = env.schemaPath;
			this.localRefs = env.localRefs;
			this.meta = env.meta;
			this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
			this.refs = {};
		}
	};
	exports.SchemaEnv = SchemaEnv;
	function compileSchema(sch) {
		const _sch = getCompilingSchema.call(this, sch);
		if (_sch) return _sch;
		const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
		const { es5, lines } = this.opts.code;
		const { ownProperties } = this.opts;
		const gen = new codegen_1.CodeGen(this.scope, {
			es5,
			lines,
			ownProperties
		});
		let _ValidationError;
		if (sch.$async) {
			_ValidationError = gen.scopeValue("Error", {
				ref: validation_error_1.default,
				code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
			});
		}
		const validateName = gen.scopeName("validate");
		sch.validateName = validateName;
		const schemaCxt = {
			gen,
			allErrors: this.opts.allErrors,
			data: names_1.default.data,
			parentData: names_1.default.parentData,
			parentDataProperty: names_1.default.parentDataProperty,
			dataNames: [names_1.default.data],
			dataPathArr: [codegen_1.nil],
			dataLevel: 0,
			dataTypes: [],
			definedProperties: new Set(),
			topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
				ref: sch.schema,
				code: (0, codegen_1.stringify)(sch.schema)
			} : { ref: sch.schema }),
			validateName,
			ValidationError: _ValidationError,
			schema: sch.schema,
			schemaEnv: sch,
			rootId,
			baseId: sch.baseId || rootId,
			schemaPath: codegen_1.nil,
			errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
			errorPath: (0, codegen_1._)`""`,
			opts: this.opts,
			self: this
		};
		let sourceCode;
		try {
			this._compilations.add(sch);
			(0, validate_1.validateFunctionCode)(schemaCxt);
			gen.optimize(this.opts.code.optimize);
			const validateCode = gen.toString();
			sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
			if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
			const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
			const validate = makeValidate(this, this.scope.get());
			this.scope.value(validateName, { ref: validate });
			validate.errors = null;
			validate.schema = sch.schema;
			validate.schemaEnv = sch;
			if (sch.$async) validate.$async = true;
			if (this.opts.code.source === true) {
				validate.source = {
					validateName,
					validateCode,
					scopeValues: gen._values
				};
			}
			if (this.opts.unevaluated) {
				const { props, items } = schemaCxt;
				validate.evaluated = {
					props: props instanceof codegen_1.Name ? undefined : props,
					items: items instanceof codegen_1.Name ? undefined : items,
					dynamicProps: props instanceof codegen_1.Name,
					dynamicItems: items instanceof codegen_1.Name
				};
				if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
			}
			sch.validate = validate;
			return sch;
		} catch (e) {
			delete sch.validate;
			delete sch.validateName;
			if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
			throw e;
		} finally {
			this._compilations.delete(sch);
		}
	}
	exports.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
		var _a$1;
		ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
		const schOrFunc = root.refs[ref];
		if (schOrFunc) return schOrFunc;
		let _sch = resolve.call(this, root, ref);
		if (_sch === undefined) {
			const schema = (_a$1 = root.localRefs) === null || _a$1 === void 0 ? void 0 : _a$1[ref];
			const { schemaId } = this.opts;
			if (schema) _sch = new SchemaEnv({
				schema,
				schemaId,
				root,
				baseId
			});
		}
		if (_sch === undefined) return;
		return root.refs[ref] = inlineOrCompile.call(this, _sch);
	}
	exports.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
		if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
		return sch.validate ? sch : compileSchema.call(this, sch);
	}
	function getCompilingSchema(schEnv) {
		for (const sch of this._compilations) {
			if (sameSchemaEnv(sch, schEnv)) return sch;
		}
	}
	exports.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
		return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	function resolve(root, ref) {
		let sch;
		while (typeof (sch = this.refs[ref]) == "string") ref = sch;
		return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	function resolveSchema(root, ref) {
		const p = this.opts.uriResolver.parse(ref);
		const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
		let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
		if (Object.keys(root.schema).length > 0 && refPath === baseId) {
			return getJsonPointer.call(this, p, root);
		}
		const id = (0, resolve_1.normalizeId)(refPath);
		const schOrRef = this.refs[id] || this.schemas[id];
		if (typeof schOrRef == "string") {
			const sch = resolveSchema.call(this, root, schOrRef);
			if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
			return getJsonPointer.call(this, p, sch);
		}
		if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
		if (!schOrRef.validate) compileSchema.call(this, schOrRef);
		if (id === (0, resolve_1.normalizeId)(ref)) {
			const { schema } = schOrRef;
			const { schemaId } = this.opts;
			const schId = schema[schemaId];
			if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
			return new SchemaEnv({
				schema,
				schemaId,
				root,
				baseId
			});
		}
		return getJsonPointer.call(this, p, schOrRef);
	}
	exports.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
		var _a$1;
		if (((_a$1 = parsedRef.fragment) === null || _a$1 === void 0 ? void 0 : _a$1[0]) !== "/") return;
		for (const part of parsedRef.fragment.slice(1).split("/")) {
			if (typeof schema === "boolean") return;
			const partSchema = schema[(0, util_1.unescapeFragment)(part)];
			if (partSchema === undefined) return;
			schema = partSchema;
			const schId = typeof schema === "object" && schema[this.opts.schemaId];
			if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
				baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
			}
		}
		let env;
		if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
			const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
			env = resolveSchema.call(this, root, $ref);
		}
		const { schemaId } = this.opts;
		env = env || new SchemaEnv({
			schema,
			schemaId,
			root,
			baseId
		});
		if (env.schema !== env.root.schema) return env;
		return undefined;
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/refs/data.json
var require_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		"description": "Meta-schema for $data reference (JSON AnySchema extension proposal)",
		"type": "object",
		"required": ["$data"],
		"properties": { "$data": {
			"type": "string",
			"anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
		} },
		"additionalProperties": false
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/fast-uri/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {(value: string) => boolean} */
	const isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
	/** @type {(value: string) => boolean} */
	const isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
	/**
	* @param {Array<string>} input
	* @returns {string}
	*/
	function stringArrayToHexStripped(input) {
		let acc = "";
		let code = 0;
		let i = 0;
		for (i = 0; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (code === 48) {
				continue;
			}
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
				return "";
			}
			acc += input[i];
			break;
		}
		for (i += 1; i < input.length; i++) {
			code = input[i].charCodeAt(0);
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
				return "";
			}
			acc += input[i];
		}
		return acc;
	}
	/**
	* @typedef {Object} GetIPV6Result
	* @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
	* @property {string} address - The parsed IPv6 address.
	* @property {string} [zone] - The zone identifier, if present.
	*/
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	const nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
	/**
	* @param {Array<string>} buffer
	* @returns {boolean}
	*/
	function consumeIsZone(buffer) {
		buffer.length = 0;
		return true;
	}
	/**
	* @param {Array<string>} buffer
	* @param {Array<string>} address
	* @param {GetIPV6Result} output
	* @returns {boolean}
	*/
	function consumeHextets(buffer, address, output) {
		if (buffer.length) {
			const hex$3 = stringArrayToHexStripped(buffer);
			if (hex$3 !== "") {
				address.push(hex$3);
			} else {
				output.error = true;
				return false;
			}
			buffer.length = 0;
		}
		return true;
	}
	/**
	* @param {string} input
	* @returns {GetIPV6Result}
	*/
	function getIPV6(input) {
		let tokenCount = 0;
		const output = {
			error: false,
			address: "",
			zone: ""
		};
		/** @type {Array<string>} */
		const address = [];
		/** @type {Array<string>} */
		const buffer = [];
		let endipv6Encountered = false;
		let endIpv6 = false;
		let consume = consumeHextets;
		for (let i = 0; i < input.length; i++) {
			const cursor = input[i];
			if (cursor === "[" || cursor === "]") {
				continue;
			}
			if (cursor === ":") {
				if (endipv6Encountered === true) {
					endIpv6 = true;
				}
				if (!consume(buffer, address, output)) {
					break;
				}
				if (++tokenCount > 7) {
					output.error = true;
					break;
				}
				if (i > 0 && input[i - 1] === ":") {
					endipv6Encountered = true;
				}
				address.push(":");
				continue;
			} else if (cursor === "%") {
				if (!consume(buffer, address, output)) {
					break;
				}
				consume = consumeIsZone;
			} else {
				buffer.push(cursor);
				continue;
			}
		}
		if (buffer.length) {
			if (consume === consumeIsZone) {
				output.zone = buffer.join("");
			} else if (endIpv6) {
				address.push(buffer.join(""));
			} else {
				address.push(stringArrayToHexStripped(buffer));
			}
		}
		output.address = address.join("");
		return output;
	}
	/**
	* @typedef {Object} NormalizeIPv6Result
	* @property {string} host - The normalized host.
	* @property {string} [escapedHost] - The escaped host.
	* @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
	*/
	/**
	* @param {string} host
	* @returns {NormalizeIPv6Result}
	*/
	function normalizeIPv6(host) {
		if (findToken(host, ":") < 2) {
			return {
				host,
				isIPV6: false
			};
		}
		const ipv6$3 = getIPV6(host);
		if (!ipv6$3.error) {
			let newHost = ipv6$3.address;
			let escapedHost = ipv6$3.address;
			if (ipv6$3.zone) {
				newHost += "%" + ipv6$3.zone;
				escapedHost += "%25" + ipv6$3.zone;
			}
			return {
				host: newHost,
				isIPV6: true,
				escapedHost
			};
		} else {
			return {
				host,
				isIPV6: false
			};
		}
	}
	/**
	* @param {string} str
	* @param {string} token
	* @returns {number}
	*/
	function findToken(str, token) {
		let ind = 0;
		for (let i = 0; i < str.length; i++) {
			if (str[i] === token) ind++;
		}
		return ind;
	}
	/**
	* @param {string} path
	* @returns {string}
	*
	* @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
	*/
	function removeDotSegments(path$12) {
		let input = path$12;
		const output = [];
		let nextSlash = -1;
		let len = 0;
		while (len = input.length) {
			if (len === 1) {
				if (input === ".") {
					break;
				} else if (input === "/") {
					output.push("/");
					break;
				} else {
					output.push(input);
					break;
				}
			} else if (len === 2) {
				if (input[0] === ".") {
					if (input[1] === ".") {
						break;
					} else if (input[1] === "/") {
						input = input.slice(2);
						continue;
					}
				} else if (input[0] === "/") {
					if (input[1] === "." || input[1] === "/") {
						output.push("/");
						break;
					}
				}
			} else if (len === 3) {
				if (input === "/..") {
					if (output.length !== 0) {
						output.pop();
					}
					output.push("/");
					break;
				}
			}
			if (input[0] === ".") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(3);
						continue;
					}
				} else if (input[1] === "/") {
					input = input.slice(2);
					continue;
				}
			} else if (input[0] === "/") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(2);
						continue;
					} else if (input[2] === ".") {
						if (input[3] === "/") {
							input = input.slice(3);
							if (output.length !== 0) {
								output.pop();
							}
							continue;
						}
					}
				}
			}
			if ((nextSlash = input.indexOf("/", 1)) === -1) {
				output.push(input);
				break;
			} else {
				output.push(input.slice(0, nextSlash));
				input = input.slice(nextSlash);
			}
		}
		return output.join("");
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @param {boolean} esc
	* @returns {import('../types/index').URIComponent}
	*/
	function normalizeComponentEncoding(component, esc$1) {
		const func = esc$1 !== true ? escape : unescape;
		if (component.scheme !== undefined) {
			component.scheme = func(component.scheme);
		}
		if (component.userinfo !== undefined) {
			component.userinfo = func(component.userinfo);
		}
		if (component.host !== undefined) {
			component.host = func(component.host);
		}
		if (component.path !== undefined) {
			component.path = func(component.path);
		}
		if (component.query !== undefined) {
			component.query = func(component.query);
		}
		if (component.fragment !== undefined) {
			component.fragment = func(component.fragment);
		}
		return component;
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @returns {string|undefined}
	*/
	function recomposeAuthority(component) {
		const uriTokens = [];
		if (component.userinfo !== undefined) {
			uriTokens.push(component.userinfo);
			uriTokens.push("@");
		}
		if (component.host !== undefined) {
			let host = unescape(component.host);
			if (!isIPv4(host)) {
				const ipV6res = normalizeIPv6(host);
				if (ipV6res.isIPV6 === true) {
					host = `[${ipV6res.escapedHost}]`;
				} else {
					host = component.host;
				}
			}
			uriTokens.push(host);
		}
		if (typeof component.port === "number" || typeof component.port === "string") {
			uriTokens.push(":");
			uriTokens.push(String(component.port));
		}
		return uriTokens.length ? uriTokens.join("") : undefined;
	}
	;
	module.exports = {
		nonSimpleDomain,
		recomposeAuthority,
		normalizeComponentEncoding,
		removeDotSegments,
		isIPv4,
		isUUID,
		normalizeIPv6,
		stringArrayToHexStripped
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/fast-uri/lib/schemes.js
var require_schemes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { isUUID } = require_utils();
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
	const supportedSchemeNames = [
		"http",
		"https",
		"ws",
		"wss",
		"urn",
		"urn:uuid"
	];
	/** @typedef {supportedSchemeNames[number]} SchemeName */
	/**
	* @param {string} name
	* @returns {name is SchemeName}
	*/
	function isValidSchemeName(name) {
		return supportedSchemeNames.indexOf(
			/** @type {*} */
			name
		) !== -1;
	}
	/**
	* @callback SchemeFn
	* @param {import('../types/index').URIComponent} component
	* @param {import('../types/index').Options} options
	* @returns {import('../types/index').URIComponent}
	*/
	/**
	* @typedef {Object} SchemeHandler
	* @property {SchemeName} scheme - The scheme name.
	* @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
	* @property {SchemeFn} parse - Function to parse the URI component for this scheme.
	* @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
	* @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
	* @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
	* @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
	*/
	/**
	* @param {import('../types/index').URIComponent} wsComponent
	* @returns {boolean}
	*/
	function wsIsSecure(wsComponent) {
		if (wsComponent.secure === true) {
			return true;
		} else if (wsComponent.secure === false) {
			return false;
		} else if (wsComponent.scheme) {
			return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
		} else {
			return false;
		}
	}
	/** @type {SchemeFn} */
	function httpParse(component) {
		if (!component.host) {
			component.error = component.error || "HTTP URIs must have a host.";
		}
		return component;
	}
	/** @type {SchemeFn} */
	function httpSerialize(component) {
		const secure = String(component.scheme).toLowerCase() === "https";
		if (component.port === (secure ? 443 : 80) || component.port === "") {
			component.port = undefined;
		}
		if (!component.path) {
			component.path = "/";
		}
		return component;
	}
	/** @type {SchemeFn} */
	function wsParse(wsComponent) {
		wsComponent.secure = wsIsSecure(wsComponent);
		wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
		wsComponent.path = undefined;
		wsComponent.query = undefined;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function wsSerialize(wsComponent) {
		if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
			wsComponent.port = undefined;
		}
		if (typeof wsComponent.secure === "boolean") {
			wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
			wsComponent.secure = undefined;
		}
		if (wsComponent.resourceName) {
			const [path$12, query] = wsComponent.resourceName.split("?");
			wsComponent.path = path$12 && path$12 !== "/" ? path$12 : undefined;
			wsComponent.query = query;
			wsComponent.resourceName = undefined;
		}
		wsComponent.fragment = undefined;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function urnParse(urnComponent, options) {
		if (!urnComponent.path) {
			urnComponent.error = "URN can not be parsed";
			return urnComponent;
		}
		const matches = urnComponent.path.match(URN_REG);
		if (matches) {
			const scheme = options.scheme || urnComponent.scheme || "urn";
			urnComponent.nid = matches[1].toLowerCase();
			urnComponent.nss = matches[2];
			const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
			const schemeHandler = getSchemeHandler(urnScheme);
			urnComponent.path = undefined;
			if (schemeHandler) {
				urnComponent = schemeHandler.parse(urnComponent, options);
			}
		} else {
			urnComponent.error = urnComponent.error || "URN can not be parsed.";
		}
		return urnComponent;
	}
	/** @type {SchemeFn} */
	function urnSerialize(urnComponent, options) {
		if (urnComponent.nid === undefined) {
			throw new Error("URN without nid cannot be serialized");
		}
		const scheme = options.scheme || urnComponent.scheme || "urn";
		const nid = urnComponent.nid.toLowerCase();
		const urnScheme = `${scheme}:${options.nid || nid}`;
		const schemeHandler = getSchemeHandler(urnScheme);
		if (schemeHandler) {
			urnComponent = schemeHandler.serialize(urnComponent, options);
		}
		const uriComponent = urnComponent;
		const nss = urnComponent.nss;
		uriComponent.path = `${nid || options.nid}:${nss}`;
		options.skipEscape = true;
		return uriComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidParse(urnComponent, options) {
		const uuidComponent = urnComponent;
		uuidComponent.uuid = uuidComponent.nss;
		uuidComponent.nss = undefined;
		if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
			uuidComponent.error = uuidComponent.error || "UUID is not valid.";
		}
		return uuidComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidSerialize(uuidComponent) {
		const urnComponent = uuidComponent;
		urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
		return urnComponent;
	}
	const http = {
		scheme: "http",
		domainHost: true,
		parse: httpParse,
		serialize: httpSerialize
	};
	const https = {
		scheme: "https",
		domainHost: http.domainHost,
		parse: httpParse,
		serialize: httpSerialize
	};
	const ws = {
		scheme: "ws",
		domainHost: true,
		parse: wsParse,
		serialize: wsSerialize
	};
	const wss = {
		scheme: "wss",
		domainHost: ws.domainHost,
		parse: ws.parse,
		serialize: ws.serialize
	};
	const urn = {
		scheme: "urn",
		parse: urnParse,
		serialize: urnSerialize,
		skipNormalize: true
	};
	const urnuuid = {
		scheme: "urn:uuid",
		parse: urnuuidParse,
		serialize: urnuuidSerialize,
		skipNormalize: true
	};
	const SCHEMES = {
		http,
		https,
		ws,
		wss,
		urn,
		"urn:uuid": urnuuid
	};
	Object.setPrototypeOf(SCHEMES, null);
	/**
	* @param {string|undefined} scheme
	* @returns {SchemeHandler|undefined}
	*/
	function getSchemeHandler(scheme) {
		return scheme && (SCHEMES[scheme] || SCHEMES[scheme.toLowerCase()]) || undefined;
	}
	module.exports = {
		wsIsSecure,
		SCHEMES,
		isValidSchemeName,
		getSchemeHandler
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/fast-uri/index.js
var require_fast_uri = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
	const { SCHEMES, getSchemeHandler } = require_schemes();
	/**
	* @template {import('./types/index').URIComponent|string} T
	* @param {T} uri
	* @param {import('./types/index').Options} [options]
	* @returns {T}
	*/
	function normalize(uri, options) {
		if (typeof uri === "string") {
			uri = serialize(parse(uri, options), options);
		} else if (typeof uri === "object") {
			uri = parse(serialize(uri, options), options);
		}
		return uri;
	}
	/**
	* @param {string} baseURI
	* @param {string} relativeURI
	* @param {import('./types/index').Options} [options]
	* @returns {string}
	*/
	function resolve(baseURI, relativeURI, options) {
		const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
		const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
		schemelessOptions.skipEscape = true;
		return serialize(resolved, schemelessOptions);
	}
	/**
	* @param {import ('./types/index').URIComponent} base
	* @param {import ('./types/index').URIComponent} relative
	* @param {import('./types/index').Options} [options]
	* @param {boolean} [skipNormalization=false]
	* @returns {import ('./types/index').URIComponent}
	*/
	function resolveComponent(base, relative, options, skipNormalization) {
		/** @type {import('./types/index').URIComponent} */
		const target = {};
		if (!skipNormalization) {
			base = parse(serialize(base, options), options);
			relative = parse(serialize(relative, options), options);
		}
		options = options || {};
		if (!options.tolerant && relative.scheme) {
			target.scheme = relative.scheme;
			target.userinfo = relative.userinfo;
			target.host = relative.host;
			target.port = relative.port;
			target.path = removeDotSegments(relative.path || "");
			target.query = relative.query;
		} else {
			if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
				target.userinfo = relative.userinfo;
				target.host = relative.host;
				target.port = relative.port;
				target.path = removeDotSegments(relative.path || "");
				target.query = relative.query;
			} else {
				if (!relative.path) {
					target.path = base.path;
					if (relative.query !== undefined) {
						target.query = relative.query;
					} else {
						target.query = base.query;
					}
				} else {
					if (relative.path[0] === "/") {
						target.path = removeDotSegments(relative.path);
					} else {
						if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
							target.path = "/" + relative.path;
						} else if (!base.path) {
							target.path = relative.path;
						} else {
							target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
						}
						target.path = removeDotSegments(target.path);
					}
					target.query = relative.query;
				}
				target.userinfo = base.userinfo;
				target.host = base.host;
				target.port = base.port;
			}
			target.scheme = base.scheme;
		}
		target.fragment = relative.fragment;
		return target;
	}
	/**
	* @param {import ('./types/index').URIComponent|string} uriA
	* @param {import ('./types/index').URIComponent|string} uriB
	* @param {import ('./types/index').Options} options
	* @returns {boolean}
	*/
	function equal(uriA, uriB, options) {
		if (typeof uriA === "string") {
			uriA = unescape(uriA);
			uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriA === "object") {
			uriA = serialize(normalizeComponentEncoding(uriA, true), {
				...options,
				skipEscape: true
			});
		}
		if (typeof uriB === "string") {
			uriB = unescape(uriB);
			uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriB === "object") {
			uriB = serialize(normalizeComponentEncoding(uriB, true), {
				...options,
				skipEscape: true
			});
		}
		return uriA.toLowerCase() === uriB.toLowerCase();
	}
	/**
	* @param {Readonly<import('./types/index').URIComponent>} cmpts
	* @param {import('./types/index').Options} [opts]
	* @returns {string}
	*/
	function serialize(cmpts, opts) {
		const component = {
			host: cmpts.host,
			scheme: cmpts.scheme,
			userinfo: cmpts.userinfo,
			port: cmpts.port,
			path: cmpts.path,
			query: cmpts.query,
			nid: cmpts.nid,
			nss: cmpts.nss,
			uuid: cmpts.uuid,
			fragment: cmpts.fragment,
			reference: cmpts.reference,
			resourceName: cmpts.resourceName,
			secure: cmpts.secure,
			error: ""
		};
		const options = Object.assign({}, opts);
		const uriTokens = [];
		const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
		if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
		if (component.path !== undefined) {
			if (!options.skipEscape) {
				component.path = escape(component.path);
				if (component.scheme !== undefined) {
					component.path = component.path.split("%3A").join(":");
				}
			} else {
				component.path = unescape(component.path);
			}
		}
		if (options.reference !== "suffix" && component.scheme) {
			uriTokens.push(component.scheme, ":");
		}
		const authority = recomposeAuthority(component);
		if (authority !== undefined) {
			if (options.reference !== "suffix") {
				uriTokens.push("//");
			}
			uriTokens.push(authority);
			if (component.path && component.path[0] !== "/") {
				uriTokens.push("/");
			}
		}
		if (component.path !== undefined) {
			let s = component.path;
			if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
				s = removeDotSegments(s);
			}
			if (authority === undefined && s[0] === "/" && s[1] === "/") {
				s = "/%2F" + s.slice(2);
			}
			uriTokens.push(s);
		}
		if (component.query !== undefined) {
			uriTokens.push("?", component.query);
		}
		if (component.fragment !== undefined) {
			uriTokens.push("#", component.fragment);
		}
		return uriTokens.join("");
	}
	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
	/**
	* @param {string} uri
	* @param {import('./types/index').Options} [opts]
	* @returns
	*/
	function parse(uri, opts) {
		const options = Object.assign({}, opts);
		/** @type {import('./types/index').URIComponent} */
		const parsed = {
			scheme: undefined,
			userinfo: undefined,
			host: "",
			port: undefined,
			path: "",
			query: undefined,
			fragment: undefined
		};
		let isIP = false;
		if (options.reference === "suffix") {
			if (options.scheme) {
				uri = options.scheme + ":" + uri;
			} else {
				uri = "//" + uri;
			}
		}
		const matches = uri.match(URI_PARSE);
		if (matches) {
			parsed.scheme = matches[1];
			parsed.userinfo = matches[3];
			parsed.host = matches[4];
			parsed.port = parseInt(matches[5], 10);
			parsed.path = matches[6] || "";
			parsed.query = matches[7];
			parsed.fragment = matches[8];
			if (isNaN(parsed.port)) {
				parsed.port = matches[5];
			}
			if (parsed.host) {
				const ipv4result = isIPv4(parsed.host);
				if (ipv4result === false) {
					const ipv6result = normalizeIPv6(parsed.host);
					parsed.host = ipv6result.host.toLowerCase();
					isIP = ipv6result.isIPV6;
				} else {
					isIP = true;
				}
			}
			if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
				parsed.reference = "same-document";
			} else if (parsed.scheme === undefined) {
				parsed.reference = "relative";
			} else if (parsed.fragment === undefined) {
				parsed.reference = "absolute";
			} else {
				parsed.reference = "uri";
			}
			if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
				parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
			}
			const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
			if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
				if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
					try {
						parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
					} catch (e) {
						parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
					}
				}
			}
			if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
				if (uri.indexOf("%") !== -1) {
					if (parsed.scheme !== undefined) {
						parsed.scheme = unescape(parsed.scheme);
					}
					if (parsed.host !== undefined) {
						parsed.host = unescape(parsed.host);
					}
				}
				if (parsed.path) {
					parsed.path = escape(unescape(parsed.path));
				}
				if (parsed.fragment) {
					parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
				}
			}
			if (schemeHandler && schemeHandler.parse) {
				schemeHandler.parse(parsed, options);
			}
		} else {
			parsed.error = parsed.error || "URI can not be parsed.";
		}
		return parsed;
	}
	const fastUri = {
		SCHEMES,
		normalize,
		resolve,
		resolveComponent,
		equal,
		serialize,
		parse
	};
	module.exports = fastUri;
	module.exports.default = fastUri;
	module.exports.fastUri = fastUri;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/runtime/uri.js
var require_uri = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const uri = require_fast_uri();
	uri.code = "require(\"ajv/dist/runtime/uri\").default";
	exports.default = uri;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/core.js
var require_core$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1.KeywordCxt;
		}
	});
	var codegen_1 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1.CodeGen;
		}
	});
	const validation_error_1 = require_validation_error();
	const ref_error_1 = require_ref_error();
	const rules_1 = require_rules();
	const compile_1 = require_compile();
	const codegen_2 = require_codegen();
	const resolve_1 = require_resolve();
	const dataType_1 = require_dataType();
	const util_1 = require_util();
	const $dataRefSchema = require_data();
	const uri_1 = require_uri();
	const defaultRegExp = (str, flags) => new RegExp(str, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes"
	];
	const EXT_SCOPE_NAMES = new Set([
		"validate",
		"serialize",
		"parse",
		"wrapper",
		"root",
		"schema",
		"keyword",
		"pattern",
		"formats",
		"validate$data",
		"func",
		"obj",
		"Error"
	]);
	const removedOptions = {
		errorDataPath: "",
		format: "`validateFormats: false` can be used instead.",
		nullable: "\"nullable\" keyword is supported by default.",
		jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		sourceCode: "Use option `code: {source: true}`",
		strictDefaults: "It is default now, see option `strict`.",
		strictKeywords: "It is default now, see option `strict`.",
		uniqueItems: "\"uniqueItems\" keyword is always validated.",
		unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		cache: "Map is used as cache, schema object as key.",
		serialize: "Map is used as cache, schema object as key.",
		ajvErrors: "It is default now."
	};
	const deprecatedOptions = {
		ignoreKeywordsWithRef: "",
		jsPropertySyntax: "",
		unicode: "\"minLength\"/\"maxLength\" account for unicode characters by default."
	};
	const MAX_EXPRESSION = 200;
	function requiredOptions(o) {
		var _a$1, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		const s = o.strict;
		const _optz = (_a$1 = o.code) === null || _a$1 === void 0 ? void 0 : _a$1.optimize;
		const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
		const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		return {
			strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
			strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
			strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
			strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
			strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
			code: o.code ? {
				...o.code,
				optimize,
				regExp
			} : {
				optimize,
				regExp
			},
			loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
			loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
			meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
			messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
			inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
			schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
			addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
			validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
			validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
			unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
			int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
			uriResolver
		};
	}
	var Ajv = class {
		constructor(opts = {}) {
			this.schemas = {};
			this.refs = {};
			this.formats = {};
			this._compilations = new Set();
			this._loading = {};
			this._cache = new Map();
			opts = this.opts = {
				...opts,
				...requiredOptions(opts)
			};
			const { es5, lines } = this.opts.code;
			this.scope = new codegen_2.ValueScope({
				scope: {},
				prefixes: EXT_SCOPE_NAMES,
				es5,
				lines
			});
			this.logger = getLogger(opts.logger);
			const formatOpt = opts.validateFormats;
			opts.validateFormats = false;
			this.RULES = (0, rules_1.getRules)();
			checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
			checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
			this._metaOpts = getMetaSchemaOptions.call(this);
			if (opts.formats) addInitialFormats.call(this);
			this._addVocabularies();
			this._addDefaultMetaSchema();
			if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
			if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
			addInitialSchemas.call(this);
			opts.validateFormats = formatOpt;
		}
		_addVocabularies() {
			this.addKeyword("$async");
		}
		_addDefaultMetaSchema() {
			const { $data, meta: meta$3, schemaId } = this.opts;
			let _dataRefSchema = $dataRefSchema;
			if (schemaId === "id") {
				_dataRefSchema = { ...$dataRefSchema };
				_dataRefSchema.id = _dataRefSchema.$id;
				delete _dataRefSchema.$id;
			}
			if (meta$3 && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		}
		defaultMeta() {
			const { meta: meta$3, schemaId } = this.opts;
			return this.opts.defaultMeta = typeof meta$3 == "object" ? meta$3[schemaId] || meta$3 : undefined;
		}
		validate(schemaKeyRef, data) {
			let v;
			if (typeof schemaKeyRef == "string") {
				v = this.getSchema(schemaKeyRef);
				if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
			} else {
				v = this.compile(schemaKeyRef);
			}
			const valid = v(data);
			if (!("$async" in v)) this.errors = v.errors;
			return valid;
		}
		compile(schema, _meta) {
			const sch = this._addSchema(schema, _meta);
			return sch.validate || this._compileSchemaEnv(sch);
		}
		compileAsync(schema, meta$3) {
			if (typeof this.opts.loadSchema != "function") {
				throw new Error("options.loadSchema should be a function");
			}
			const { loadSchema } = this.opts;
			return runCompileAsync.call(this, schema, meta$3);
			async function runCompileAsync(_schema, _meta) {
				await loadMetaSchema.call(this, _schema.$schema);
				const sch = this._addSchema(_schema, _meta);
				return sch.validate || _compileAsync.call(this, sch);
			}
			async function loadMetaSchema($ref) {
				if ($ref && !this.getSchema($ref)) {
					await runCompileAsync.call(this, { $ref }, true);
				}
			}
			async function _compileAsync(sch) {
				try {
					return this._compileSchemaEnv(sch);
				} catch (e) {
					if (!(e instanceof ref_error_1.default)) throw e;
					checkLoaded.call(this, e);
					await loadMissingSchema.call(this, e.missingSchema);
					return _compileAsync.call(this, sch);
				}
			}
			function checkLoaded({ missingSchema: ref, missingRef }) {
				if (this.refs[ref]) {
					throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
				}
			}
			async function loadMissingSchema(ref) {
				const _schema = await _loadSchema.call(this, ref);
				if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
				if (!this.refs[ref]) this.addSchema(_schema, ref, meta$3);
			}
			async function _loadSchema(ref) {
				const p = this._loading[ref];
				if (p) return p;
				try {
					return await (this._loading[ref] = loadSchema(ref));
				} finally {
					delete this._loading[ref];
				}
			}
		}
		addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
			if (Array.isArray(schema)) {
				for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);
				return this;
			}
			let id;
			if (typeof schema === "object") {
				const { schemaId } = this.opts;
				id = schema[schemaId];
				if (id !== undefined && typeof id != "string") {
					throw new Error(`schema ${schemaId} must be string`);
				}
			}
			key = (0, resolve_1.normalizeId)(key || id);
			this._checkUnique(key);
			this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
			return this;
		}
		addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
			this.addSchema(schema, key, true, _validateSchema);
			return this;
		}
		validateSchema(schema, throwOrLogError) {
			if (typeof schema == "boolean") return true;
			let $schema;
			$schema = schema.$schema;
			if ($schema !== undefined && typeof $schema != "string") {
				throw new Error("$schema must be a string");
			}
			$schema = $schema || this.opts.defaultMeta || this.defaultMeta();
			if (!$schema) {
				this.logger.warn("meta-schema not available");
				this.errors = null;
				return true;
			}
			const valid = this.validate($schema, schema);
			if (!valid && throwOrLogError) {
				const message = "schema is invalid: " + this.errorsText();
				if (this.opts.validateSchema === "log") this.logger.error(message);
				else throw new Error(message);
			}
			return valid;
		}
		getSchema(keyRef) {
			let sch;
			while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
			if (sch === undefined) {
				const { schemaId } = this.opts;
				const root = new compile_1.SchemaEnv({
					schema: {},
					schemaId
				});
				sch = compile_1.resolveSchema.call(this, root, keyRef);
				if (!sch) return;
				this.refs[keyRef] = sch;
			}
			return sch.validate || this._compileSchemaEnv(sch);
		}
		removeSchema(schemaKeyRef) {
			if (schemaKeyRef instanceof RegExp) {
				this._removeAllSchemas(this.schemas, schemaKeyRef);
				this._removeAllSchemas(this.refs, schemaKeyRef);
				return this;
			}
			switch (typeof schemaKeyRef) {
				case "undefined":
					this._removeAllSchemas(this.schemas);
					this._removeAllSchemas(this.refs);
					this._cache.clear();
					return this;
				case "string": {
					const sch = getSchEnv.call(this, schemaKeyRef);
					if (typeof sch == "object") this._cache.delete(sch.schema);
					delete this.schemas[schemaKeyRef];
					delete this.refs[schemaKeyRef];
					return this;
				}
				case "object": {
					const cacheKey = schemaKeyRef;
					this._cache.delete(cacheKey);
					let id = schemaKeyRef[this.opts.schemaId];
					if (id) {
						id = (0, resolve_1.normalizeId)(id);
						delete this.schemas[id];
						delete this.refs[id];
					}
					return this;
				}
				default: throw new Error("ajv.removeSchema: invalid parameter");
			}
		}
		addVocabulary(definitions) {
			for (const def of definitions) this.addKeyword(def);
			return this;
		}
		addKeyword(kwdOrDef, def) {
			let keyword;
			if (typeof kwdOrDef == "string") {
				keyword = kwdOrDef;
				if (typeof def == "object") {
					this.logger.warn("these parameters are deprecated, see docs for addKeyword");
					def.keyword = keyword;
				}
			} else if (typeof kwdOrDef == "object" && def === undefined) {
				def = kwdOrDef;
				keyword = def.keyword;
				if (Array.isArray(keyword) && !keyword.length) {
					throw new Error("addKeywords: keyword must be string or non-empty array");
				}
			} else {
				throw new Error("invalid addKeywords parameters");
			}
			checkKeyword.call(this, keyword, def);
			if (!def) {
				(0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
				return this;
			}
			keywordMetaschema.call(this, def);
			const definition = {
				...def,
				type: (0, dataType_1.getJSONTypes)(def.type),
				schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
			};
			(0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
			return this;
		}
		getKeyword(keyword) {
			const rule = this.RULES.all[keyword];
			return typeof rule == "object" ? rule.definition : !!rule;
		}
		removeKeyword(keyword) {
			const { RULES } = this;
			delete RULES.keywords[keyword];
			delete RULES.all[keyword];
			for (const group of RULES.rules) {
				const i = group.rules.findIndex((rule) => rule.keyword === keyword);
				if (i >= 0) group.rules.splice(i, 1);
			}
			return this;
		}
		addFormat(name, format$2) {
			if (typeof format$2 == "string") format$2 = new RegExp(format$2);
			this.formats[name] = format$2;
			return this;
		}
		errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
			if (!errors || errors.length === 0) return "No errors";
			return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
		}
		$dataMetaSchema(metaSchema, keywordsJsonPointers) {
			const rules = this.RULES.all;
			metaSchema = JSON.parse(JSON.stringify(metaSchema));
			for (const jsonPointer of keywordsJsonPointers) {
				const segments = jsonPointer.split("/").slice(1);
				let keywords = metaSchema;
				for (const seg of segments) keywords = keywords[seg];
				for (const key in rules) {
					const rule = rules[key];
					if (typeof rule != "object") continue;
					const { $data } = rule.definition;
					const schema = keywords[key];
					if ($data && schema) keywords[key] = schemaOrData(schema);
				}
			}
			return metaSchema;
		}
		_removeAllSchemas(schemas, regex) {
			for (const keyRef in schemas) {
				const sch = schemas[keyRef];
				if (!regex || regex.test(keyRef)) {
					if (typeof sch == "string") {
						delete schemas[keyRef];
					} else if (sch && !sch.meta) {
						this._cache.delete(sch.schema);
						delete schemas[keyRef];
					}
				}
			}
		}
		_addSchema(schema, meta$3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
			let id;
			const { schemaId } = this.opts;
			if (typeof schema == "object") {
				id = schema[schemaId];
			} else {
				if (this.opts.jtd) throw new Error("schema must be object");
				else if (typeof schema != "boolean") throw new Error("schema must be object or boolean");
			}
			let sch = this._cache.get(schema);
			if (sch !== undefined) return sch;
			baseId = (0, resolve_1.normalizeId)(id || baseId);
			const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
			sch = new compile_1.SchemaEnv({
				schema,
				schemaId,
				meta: meta$3,
				baseId,
				localRefs
			});
			this._cache.set(sch.schema, sch);
			if (addSchema && !baseId.startsWith("#")) {
				if (baseId) this._checkUnique(baseId);
				this.refs[baseId] = sch;
			}
			if (validateSchema) this.validateSchema(schema, true);
			return sch;
		}
		_checkUnique(id) {
			if (this.schemas[id] || this.refs[id]) {
				throw new Error(`schema with key or id "${id}" already exists`);
			}
		}
		_compileSchemaEnv(sch) {
			if (sch.meta) this._compileMetaSchema(sch);
			else compile_1.compileSchema.call(this, sch);
			/* istanbul ignore if */
			if (!sch.validate) throw new Error("ajv implementation error");
			return sch.validate;
		}
		_compileMetaSchema(sch) {
			const currentOpts = this.opts;
			this.opts = this._metaOpts;
			try {
				compile_1.compileSchema.call(this, sch);
			} finally {
				this.opts = currentOpts;
			}
		}
	};
	Ajv.ValidationError = validation_error_1.default;
	Ajv.MissingRefError = ref_error_1.default;
	exports.default = Ajv;
	function checkOptions(checkOpts, options, msg, log = "error") {
		for (const key in checkOpts) {
			const opt = key;
			if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		}
	}
	function getSchEnv(keyRef) {
		keyRef = (0, resolve_1.normalizeId)(keyRef);
		return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
		const optsSchemas = this.opts.schemas;
		if (!optsSchemas) return;
		if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
		else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
		for (const name in this.opts.formats) {
			const format$2 = this.opts.formats[name];
			if (format$2) this.addFormat(name, format$2);
		}
	}
	function addInitialKeywords(defs) {
		if (Array.isArray(defs)) {
			this.addVocabulary(defs);
			return;
		}
		this.logger.warn("keywords option as map is deprecated, pass array");
		for (const keyword in defs) {
			const def = defs[keyword];
			if (!def.keyword) def.keyword = keyword;
			this.addKeyword(def);
		}
	}
	function getMetaSchemaOptions() {
		const metaOpts = { ...this.opts };
		for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
		return metaOpts;
	}
	const noLogs = {
		log() {},
		warn() {},
		error() {}
	};
	function getLogger(logger) {
		if (logger === false) return noLogs;
		if (logger === undefined) return console;
		if (logger.log && logger.warn && logger.error) return logger;
		throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def) {
		const { RULES } = this;
		(0, util_1.eachItem)(keyword, (kwd) => {
			if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
			if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
		});
		if (!def) return;
		if (def.$data && !("code" in def || "validate" in def)) {
			throw new Error("$data keyword must have \"code\" or \"validate\" function");
		}
	}
	function addRule(keyword, definition, dataType) {
		var _a$1;
		const post = definition === null || definition === void 0 ? void 0 : definition.post;
		if (dataType && post) throw new Error("keyword with \"post\" flag cannot have \"type\"");
		const { RULES } = this;
		let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		if (!ruleGroup) {
			ruleGroup = {
				type: dataType,
				rules: []
			};
			RULES.rules.push(ruleGroup);
		}
		RULES.keywords[keyword] = true;
		if (!definition) return;
		const rule = {
			keyword,
			definition: {
				...definition,
				type: (0, dataType_1.getJSONTypes)(definition.type),
				schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
			}
		};
		if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
		else ruleGroup.rules.push(rule);
		RULES.all[keyword] = rule;
		(_a$1 = definition.implements) === null || _a$1 === void 0 ? void 0 : _a$1.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
		const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		if (i >= 0) {
			ruleGroup.rules.splice(i, 0, rule);
		} else {
			ruleGroup.rules.push(rule);
			this.logger.warn(`rule ${before} is not defined`);
		}
	}
	function keywordMetaschema(def) {
		let { metaSchema } = def;
		if (metaSchema === undefined) return;
		if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
		def.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
	function schemaOrData(schema) {
		return { anyOf: [schema, $dataRef] };
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def = {
		keyword: "id",
		code() {
			throw new Error("NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID");
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.callRef = exports.getValidate = void 0;
	const ref_error_1 = require_ref_error();
	const code_1 = require_code();
	const codegen_1 = require_codegen();
	const names_1 = require_names();
	const compile_1 = require_compile();
	const util_1 = require_util();
	const def = {
		keyword: "$ref",
		schemaType: "string",
		code(cxt) {
			const { gen, schema: $ref, it } = cxt;
			const { baseId, schemaEnv: env, validateName, opts, self } = it;
			const { root } = env;
			if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
			const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
			if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
			if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);
			return inlineRefSchema(schOrEnv);
			function callRootRef() {
				if (env === root) return callRef(cxt, validateName, env, env.$async);
				const rootName = gen.scopeValue("root", { ref: root });
				return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
			}
			function callValidate(sch) {
				const v = getValidate(cxt, sch);
				callRef(cxt, v, sch, sch.$async);
			}
			function inlineRefSchema(sch) {
				const schName = gen.scopeValue("schema", opts.code.source === true ? {
					ref: sch,
					code: (0, codegen_1.stringify)(sch)
				} : { ref: sch });
				const valid = gen.name("valid");
				const schCxt = cxt.subschema({
					schema: sch,
					dataTypes: [],
					schemaPath: codegen_1.nil,
					topSchemaRef: schName,
					errSchemaPath: $ref
				}, valid);
				cxt.mergeEvaluated(schCxt);
				cxt.ok(valid);
			}
		}
	};
	function getValidate(cxt, sch) {
		const { gen } = cxt;
		return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	exports.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
		const { gen, it } = cxt;
		const { allErrors, schemaEnv: env, opts } = it;
		const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
		if ($async) callAsyncRef();
		else callSyncRef();
		function callAsyncRef() {
			if (!env.$async) throw new Error("async schema referenced by sync schema");
			const valid = gen.let("valid");
			gen.try(() => {
				gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
				addEvaluatedFrom(v);
				if (!allErrors) gen.assign(valid, true);
			}, (e) => {
				gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
				addErrorsFrom(e);
				if (!allErrors) gen.assign(valid, false);
			});
			cxt.ok(valid);
		}
		function callSyncRef() {
			cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
		}
		function addErrorsFrom(source) {
			const errs = (0, codegen_1._)`${source}.errors`;
			gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
			gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
		}
		function addEvaluatedFrom(source) {
			var _a$1;
			if (!it.opts.unevaluated) return;
			const schEvaluated = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a$1 === void 0 ? void 0 : _a$1.evaluated;
			if (it.props !== true) {
				if (schEvaluated && !schEvaluated.dynamicProps) {
					if (schEvaluated.props !== undefined) {
						it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
					}
				} else {
					const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
					it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
				}
			}
			if (it.items !== true) {
				if (schEvaluated && !schEvaluated.dynamicItems) {
					if (schEvaluated.items !== undefined) {
						it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
					}
				} else {
					const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
					it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
				}
			}
		}
	}
	exports.callRef = callRef;
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/core/index.js
var require_core = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const id_1 = require_id();
	const ref_1 = require_ref();
	const core = [
		"$schema",
		"$id",
		"$defs",
		"$vocabulary",
		{ keyword: "$comment" },
		"definitions",
		id_1.default,
		ref_1.default
	];
	exports.default = core;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const ops = codegen_1.operators;
	const KWDs = {
		maximum: {
			okStr: "<=",
			ok: ops.LTE,
			fail: ops.GT
		},
		minimum: {
			okStr: ">=",
			ok: ops.GTE,
			fail: ops.LT
		},
		exclusiveMaximum: {
			okStr: "<",
			ok: ops.LT,
			fail: ops.GTE
		},
		exclusiveMinimum: {
			okStr: ">",
			ok: ops.GT,
			fail: ops.LTE
		}
	};
	const error = {
		message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
		params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
	};
	const def = {
		keyword: Object.keys(KWDs),
		type: "number",
		schemaType: "number",
		$data: true,
		error,
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const error = {
		message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
		params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
	};
	const def = {
		keyword: "multipleOf",
		type: "number",
		schemaType: "number",
		$data: true,
		error,
		code(cxt) {
			const { gen, data, schemaCode, it } = cxt;
			const prec = it.opts.multipleOfPrecision;
			const res = gen.let("res");
			const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
			cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function ucs2length(str) {
		const len = str.length;
		let length = 0;
		let pos = 0;
		let value;
		while (pos < len) {
			length++;
			value = str.charCodeAt(pos++);
			if (value >= 55296 && value <= 56319 && pos < len) {
				value = str.charCodeAt(pos);
				if ((value & 64512) === 56320) pos++;
			}
		}
		return length;
	}
	exports.default = ucs2length;
	ucs2length.code = "require(\"ajv/dist/runtime/ucs2length\").default";
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const ucs2length_1 = require_ucs2length();
	const error = {
		message({ keyword, schemaCode }) {
			const comp = keyword === "maxLength" ? "more" : "fewer";
			return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
		},
		params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
	};
	const def = {
		keyword: ["maxLength", "minLength"],
		type: "string",
		schemaType: "number",
		$data: true,
		error,
		code(cxt) {
			const { keyword, data, schemaCode, it } = cxt;
			const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
			const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
			cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1 = require_codegen();
	const error = {
		message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
		params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
	};
	const def = {
		keyword: "pattern",
		type: "string",
		schemaType: "string",
		$data: true,
		error,
		code(cxt) {
			const { data, $data, schema, schemaCode, it } = cxt;
			const u = it.opts.unicodeRegExp ? "u" : "";
			const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
			cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const error = {
		message({ keyword, schemaCode }) {
			const comp = keyword === "maxProperties" ? "more" : "fewer";
			return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
		},
		params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
	};
	const def = {
		keyword: ["maxProperties", "minProperties"],
		type: "object",
		schemaType: "number",
		$data: true,
		error,
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
			cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const error = {
		message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
		params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
	};
	const def = {
		keyword: "required",
		type: "object",
		schemaType: "array",
		$data: true,
		error,
		code(cxt) {
			const { gen, schema, schemaCode, data, $data, it } = cxt;
			const { opts } = it;
			if (!$data && schema.length === 0) return;
			const useLoop = schema.length >= opts.loopRequired;
			if (it.allErrors) allErrorsMode();
			else exitOnErrorMode();
			if (opts.strictRequired) {
				const props = cxt.parentSchema.properties;
				const { definedProperties } = cxt.it;
				for (const requiredKey of schema) {
					if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
						const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
						const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
						(0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
					}
				}
			}
			function allErrorsMode() {
				if (useLoop || $data) {
					cxt.block$data(codegen_1.nil, loopAllRequired);
				} else {
					for (const prop of schema) {
						(0, code_1.checkReportMissingProp)(cxt, prop);
					}
				}
			}
			function exitOnErrorMode() {
				const missing = gen.let("missing");
				if (useLoop || $data) {
					const valid = gen.let("valid", true);
					cxt.block$data(valid, () => loopUntilMissing(missing, valid));
					cxt.ok(valid);
				} else {
					gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
					(0, code_1.reportMissingProp)(cxt, missing);
					gen.else();
				}
			}
			function loopAllRequired() {
				gen.forOf("prop", schemaCode, (prop) => {
					cxt.setParams({ missingProperty: prop });
					gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
				});
			}
			function loopUntilMissing(missing, valid) {
				cxt.setParams({ missingProperty: missing });
				gen.forOf(missing, schemaCode, () => {
					gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
					gen.if((0, codegen_1.not)(valid), () => {
						cxt.error();
						gen.break();
					});
				}, codegen_1.nil);
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const error = {
		message({ keyword, schemaCode }) {
			const comp = keyword === "maxItems" ? "more" : "fewer";
			return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
		},
		params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
	};
	const def = {
		keyword: ["maxItems", "minItems"],
		type: "array",
		schemaType: "number",
		$data: true,
		error,
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
			cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/runtime/equal.js
var require_equal = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const equal = require_fast_deep_equal();
	equal.code = "require(\"ajv/dist/runtime/equal\").default";
	exports.default = equal;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const dataType_1 = require_dataType();
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const equal_1 = require_equal();
	const error = {
		message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
		params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
	};
	const def = {
		keyword: "uniqueItems",
		type: "array",
		schemaType: "boolean",
		$data: true,
		error,
		code(cxt) {
			const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
			if (!$data && !schema) return;
			const valid = gen.let("valid");
			const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
			cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
			cxt.ok(valid);
			function validateUniqueItems() {
				const i = gen.let("i", (0, codegen_1._)`${data}.length`);
				const j = gen.let("j");
				cxt.setParams({
					i,
					j
				});
				gen.assign(valid, true);
				gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
			}
			function canOptimize() {
				return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
			}
			function loopN(i, j) {
				const item = gen.name("item");
				const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
				const indices = gen.const("indices", (0, codegen_1._)`{}`);
				gen.for((0, codegen_1._)`;${i}--;`, () => {
					gen.let(item, (0, codegen_1._)`${data}[${i}]`);
					gen.if(wrongType, (0, codegen_1._)`continue`);
					if (itemTypes.length > 1) gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
					gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
						gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
						cxt.error();
						gen.assign(valid, false).break();
					}).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
				});
			}
			function loopN2(i, j) {
				const eql = (0, util_1.useFunc)(gen, equal_1.default);
				const outer = gen.name("outer");
				gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
					cxt.error();
					gen.assign(valid, false).break(outer);
				})));
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const equal_1 = require_equal();
	const error = {
		message: "must be equal to constant",
		params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
	};
	const def = {
		keyword: "const",
		$data: true,
		error,
		code(cxt) {
			const { gen, data, $data, schemaCode, schema } = cxt;
			if ($data || schema && typeof schema == "object") {
				cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
			} else {
				cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const equal_1 = require_equal();
	const error = {
		message: "must be equal to one of the allowed values",
		params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
	};
	const def = {
		keyword: "enum",
		schemaType: "array",
		$data: true,
		error,
		code(cxt) {
			const { gen, data, $data, schema, schemaCode, it } = cxt;
			if (!$data && schema.length === 0) throw new Error("enum must have non-empty array");
			const useLoop = schema.length >= it.opts.loopEnum;
			let eql;
			const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
			let valid;
			if (useLoop || $data) {
				valid = gen.let("valid");
				cxt.block$data(valid, loopEnum);
			} else {
				/* istanbul ignore if */
				if (!Array.isArray(schema)) throw new Error("ajv implementation error");
				const vSchema = gen.const("vSchema", schemaCode);
				valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
			}
			cxt.pass(valid);
			function loopEnum() {
				gen.assign(valid, false);
				gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
			}
			function equalCode(vSchema, i) {
				const sch = schema[i];
				return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const limitNumber_1 = require_limitNumber();
	const multipleOf_1 = require_multipleOf();
	const limitLength_1 = require_limitLength();
	const pattern_1 = require_pattern();
	const limitProperties_1 = require_limitProperties();
	const required_1 = require_required();
	const limitItems_1 = require_limitItems();
	const uniqueItems_1 = require_uniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation = [
		limitNumber_1.default,
		multipleOf_1.default,
		limitLength_1.default,
		pattern_1.default,
		limitProperties_1.default,
		required_1.default,
		limitItems_1.default,
		uniqueItems_1.default,
		{
			keyword: "type",
			schemaType: ["string", "array"]
		},
		{
			keyword: "nullable",
			schemaType: "boolean"
		},
		const_1.default,
		enum_1.default
	];
	exports.default = validation;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateAdditionalItems = void 0;
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const error = {
		message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
		params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
	};
	const def = {
		keyword: "additionalItems",
		type: "array",
		schemaType: ["boolean", "object"],
		before: "uniqueItems",
		error,
		code(cxt) {
			const { parentSchema, it } = cxt;
			const { items } = parentSchema;
			if (!Array.isArray(items)) {
				(0, util_1.checkStrictMode)(it, "\"additionalItems\" is ignored when \"items\" is not an array of schemas");
				return;
			}
			validateAdditionalItems(cxt, items);
		}
	};
	function validateAdditionalItems(cxt, items) {
		const { gen, schema, data, keyword, it } = cxt;
		it.items = true;
		const len = gen.const("len", (0, codegen_1._)`${data}.length`);
		if (schema === false) {
			cxt.setParams({ len: items.length });
			cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
		} else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
			const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
			gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
			cxt.ok(valid);
		}
		function validateItems(valid) {
			gen.forRange("i", items.length, len, (i) => {
				cxt.subschema({
					keyword,
					dataProp: i,
					dataPropType: util_1.Type.Num
				}, valid);
				if (!it.allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
			});
		}
	}
	exports.validateAdditionalItems = validateAdditionalItems;
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateTuple = void 0;
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const code_1 = require_code();
	const def = {
		keyword: "items",
		type: "array",
		schemaType: [
			"object",
			"array",
			"boolean"
		],
		before: "uniqueItems",
		code(cxt) {
			const { schema, it } = cxt;
			if (Array.isArray(schema)) return validateTuple(cxt, "additionalItems", schema);
			it.items = true;
			if ((0, util_1.alwaysValidSchema)(it, schema)) return;
			cxt.ok((0, code_1.validateArray)(cxt));
		}
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
		const { gen, parentSchema, data, keyword, it } = cxt;
		checkStrictTuple(parentSchema);
		if (it.opts.unevaluated && schArr.length && it.items !== true) {
			it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
		}
		const valid = gen.name("valid");
		const len = gen.const("len", (0, codegen_1._)`${data}.length`);
		schArr.forEach((sch, i) => {
			if ((0, util_1.alwaysValidSchema)(it, sch)) return;
			gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
				keyword,
				schemaProp: i,
				dataProp: i
			}, valid));
			cxt.ok(valid);
		});
		function checkStrictTuple(sch) {
			const { opts, errSchemaPath } = it;
			const l = schArr.length;
			const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
			if (opts.strictTuples && !fullTuple) {
				const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
				(0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
			}
		}
	}
	exports.validateTuple = validateTuple;
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const items_1 = require_items();
	const def = {
		keyword: "prefixItems",
		type: "array",
		schemaType: ["array"],
		before: "uniqueItems",
		code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const code_1 = require_code();
	const additionalItems_1 = require_additionalItems();
	const error = {
		message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
		params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
	};
	const def = {
		keyword: "items",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		error,
		code(cxt) {
			const { schema, parentSchema, it } = cxt;
			const { prefixItems } = parentSchema;
			it.items = true;
			if ((0, util_1.alwaysValidSchema)(it, schema)) return;
			if (prefixItems) (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
			else cxt.ok((0, code_1.validateArray)(cxt));
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const error = {
		message: ({ params: { min, max } }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
		params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
	};
	const def = {
		keyword: "contains",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		trackErrors: true,
		error,
		code(cxt) {
			const { gen, schema, parentSchema, data, it } = cxt;
			let min;
			let max;
			const { minContains, maxContains } = parentSchema;
			if (it.opts.next) {
				min = minContains === undefined ? 1 : minContains;
				max = maxContains;
			} else {
				min = 1;
			}
			const len = gen.const("len", (0, codegen_1._)`${data}.length`);
			cxt.setParams({
				min,
				max
			});
			if (max === undefined && min === 0) {
				(0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
				return;
			}
			if (max !== undefined && min > max) {
				(0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
				cxt.fail();
				return;
			}
			if ((0, util_1.alwaysValidSchema)(it, schema)) {
				let cond = (0, codegen_1._)`${len} >= ${min}`;
				if (max !== undefined) cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
				cxt.pass(cond);
				return;
			}
			it.items = true;
			const valid = gen.name("valid");
			if (max === undefined && min === 1) {
				validateItems(valid, () => gen.if(valid, () => gen.break()));
			} else if (min === 0) {
				gen.let(valid, true);
				if (max !== undefined) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
			} else {
				gen.let(valid, false);
				validateItemsWithCount();
			}
			cxt.result(valid, () => cxt.reset());
			function validateItemsWithCount() {
				const schValid = gen.name("_valid");
				const count = gen.let("count", 0);
				validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
			}
			function validateItems(_valid, block) {
				gen.forRange("i", 0, len, (i) => {
					cxt.subschema({
						keyword: "contains",
						dataProp: i,
						dataPropType: util_1.Type.Num,
						compositeRule: true
					}, _valid);
					block();
				});
			}
			function checkLimits(count) {
				gen.code((0, codegen_1._)`${count}++`);
				if (max === undefined) {
					gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
				} else {
					gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
					if (min === 1) gen.assign(valid, true);
					else gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
				}
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const code_1 = require_code();
	exports.error = {
		message: ({ params: { property, depsCount, deps } }) => {
			const property_ies = depsCount === 1 ? "property" : "properties";
			return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
		},
		params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
	};
	const def = {
		keyword: "dependencies",
		type: "object",
		schemaType: "object",
		error: exports.error,
		code(cxt) {
			const [propDeps, schDeps] = splitDependencies(cxt);
			validatePropertyDeps(cxt, propDeps);
			validateSchemaDeps(cxt, schDeps);
		}
	};
	function splitDependencies({ schema }) {
		const propertyDeps = {};
		const schemaDeps = {};
		for (const key in schema) {
			if (key === "__proto__") continue;
			const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
			deps[key] = schema[key];
		}
		return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		const { gen, data, it } = cxt;
		if (Object.keys(propertyDeps).length === 0) return;
		const missing = gen.let("missing");
		for (const prop in propertyDeps) {
			const deps = propertyDeps[prop];
			if (deps.length === 0) continue;
			const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
			cxt.setParams({
				property: prop,
				depsCount: deps.length,
				deps: deps.join(", ")
			});
			if (it.allErrors) {
				gen.if(hasProperty, () => {
					for (const depProp of deps) {
						(0, code_1.checkReportMissingProp)(cxt, depProp);
					}
				});
			} else {
				gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
				(0, code_1.reportMissingProp)(cxt, missing);
				gen.else();
			}
		}
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		for (const prop in schemaDeps) {
			if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;
			gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
				const schCxt = cxt.subschema({
					keyword,
					schemaProp: prop
				}, valid);
				cxt.mergeValidEvaluated(schCxt, valid);
			}, () => gen.var(valid, true));
			cxt.ok(valid);
		}
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const error = {
		message: "property name must be valid",
		params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
	};
	const def = {
		keyword: "propertyNames",
		type: "object",
		schemaType: ["object", "boolean"],
		error,
		code(cxt) {
			const { gen, schema, data, it } = cxt;
			if ((0, util_1.alwaysValidSchema)(it, schema)) return;
			const valid = gen.name("valid");
			gen.forIn("key", data, (key) => {
				cxt.setParams({ propertyName: key });
				cxt.subschema({
					keyword: "propertyNames",
					data: key,
					dataTypes: ["string"],
					propertyName: key,
					compositeRule: true
				}, valid);
				gen.if((0, codegen_1.not)(valid), () => {
					cxt.error(true);
					if (!it.allErrors) gen.break();
				});
			});
			cxt.ok(valid);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1 = require_codegen();
	const names_1 = require_names();
	const util_1 = require_util();
	const error = {
		message: "must NOT have additional properties",
		params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
	};
	const def = {
		keyword: "additionalProperties",
		type: ["object"],
		schemaType: ["boolean", "object"],
		allowUndefined: true,
		trackErrors: true,
		error,
		code(cxt) {
			const { gen, schema, parentSchema, data, errsCount, it } = cxt;
			/* istanbul ignore if */
			if (!errsCount) throw new Error("ajv implementation error");
			const { allErrors, opts } = it;
			it.props = true;
			if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema)) return;
			const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
			const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
			checkAdditionalProperties();
			cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
			function checkAdditionalProperties() {
				gen.forIn("key", data, (key) => {
					if (!props.length && !patProps.length) additionalPropertyCode(key);
					else gen.if(isAdditional(key), () => additionalPropertyCode(key));
				});
			}
			function isAdditional(key) {
				let definedProp;
				if (props.length > 8) {
					const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
					definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
				} else if (props.length) {
					definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
				} else {
					definedProp = codegen_1.nil;
				}
				if (patProps.length) {
					definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
				}
				return (0, codegen_1.not)(definedProp);
			}
			function deleteAdditional(key) {
				gen.code((0, codegen_1._)`delete ${data}[${key}]`);
			}
			function additionalPropertyCode(key) {
				if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
					deleteAdditional(key);
					return;
				}
				if (schema === false) {
					cxt.setParams({ additionalProperty: key });
					cxt.error();
					if (!allErrors) gen.break();
					return;
				}
				if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
					const valid = gen.name("valid");
					if (opts.removeAdditional === "failing") {
						applyAdditionalSchema(key, valid, false);
						gen.if((0, codegen_1.not)(valid), () => {
							cxt.reset();
							deleteAdditional(key);
						});
					} else {
						applyAdditionalSchema(key, valid);
						if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
					}
				}
			}
			function applyAdditionalSchema(key, valid, errors) {
				const subschema = {
					keyword: "additionalProperties",
					dataProp: key,
					dataPropType: util_1.Type.Str
				};
				if (errors === false) {
					Object.assign(subschema, {
						compositeRule: true,
						createErrors: false,
						allErrors: false
					});
				}
				cxt.subschema(subschema, valid);
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_1 = require_validate();
	const code_1 = require_code();
	const util_1 = require_util();
	const additionalProperties_1 = require_additionalProperties();
	const def = {
		keyword: "properties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema, parentSchema, data, it } = cxt;
			if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
				additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
			}
			const allProps = (0, code_1.allSchemaProperties)(schema);
			for (const prop of allProps) {
				it.definedProperties.add(prop);
			}
			if (it.opts.unevaluated && allProps.length && it.props !== true) {
				it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
			}
			const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
			if (properties.length === 0) return;
			const valid = gen.name("valid");
			for (const prop of properties) {
				if (hasDefault(prop)) {
					applyPropertySchema(prop);
				} else {
					gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
					applyPropertySchema(prop);
					if (!it.allErrors) gen.else().var(valid, true);
					gen.endIf();
				}
				cxt.it.definedProperties.add(prop);
				cxt.ok(valid);
			}
			function hasDefault(prop) {
				return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
			}
			function applyPropertySchema(prop) {
				cxt.subschema({
					keyword: "properties",
					schemaProp: prop,
					dataProp: prop
				}, valid);
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const util_2 = require_util();
	const def = {
		keyword: "patternProperties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema, data, parentSchema, it } = cxt;
			const { opts } = it;
			const patterns = (0, code_1.allSchemaProperties)(schema);
			const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
			if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
				return;
			}
			const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
			const valid = gen.name("valid");
			if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
				it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
			}
			const { props } = it;
			validatePatternProperties();
			function validatePatternProperties() {
				for (const pat of patterns) {
					if (checkProperties) checkMatchingProperties(pat);
					if (it.allErrors) {
						validateProperties(pat);
					} else {
						gen.var(valid, true);
						validateProperties(pat);
						gen.if(valid);
					}
				}
			}
			function checkMatchingProperties(pat) {
				for (const prop in checkProperties) {
					if (new RegExp(pat).test(prop)) {
						(0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
					}
				}
			}
			function validateProperties(pat) {
				gen.forIn("key", data, (key) => {
					gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
						const alwaysValid = alwaysValidPatterns.includes(pat);
						if (!alwaysValid) {
							cxt.subschema({
								keyword: "patternProperties",
								schemaProp: pat,
								dataProp: key,
								dataPropType: util_2.Type.Str
							}, valid);
						}
						if (it.opts.unevaluated && props !== true) {
							gen.assign((0, codegen_1._)`${props}[${key}]`, true);
						} else if (!alwaysValid && !it.allErrors) {
							gen.if((0, codegen_1.not)(valid), () => gen.break());
						}
					});
				});
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1 = require_util();
	const def = {
		keyword: "not",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		code(cxt) {
			const { gen, schema, it } = cxt;
			if ((0, util_1.alwaysValidSchema)(it, schema)) {
				cxt.fail();
				return;
			}
			const valid = gen.name("valid");
			cxt.subschema({
				keyword: "not",
				compositeRule: true,
				createErrors: false,
				allErrors: false
			}, valid);
			cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
		},
		error: { message: "must NOT be valid" }
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const def = {
		keyword: "anyOf",
		schemaType: "array",
		trackErrors: true,
		code: code_1.validateUnion,
		error: { message: "must match a schema in anyOf" }
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const error = {
		message: "must match exactly one schema in oneOf",
		params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
	};
	const def = {
		keyword: "oneOf",
		schemaType: "array",
		trackErrors: true,
		error,
		code(cxt) {
			const { gen, schema, parentSchema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema)) throw new Error("ajv implementation error");
			if (it.opts.discriminator && parentSchema.discriminator) return;
			const schArr = schema;
			const valid = gen.let("valid", false);
			const passing = gen.let("passing", null);
			const schValid = gen.name("_valid");
			cxt.setParams({ passing });
			gen.block(validateOneOf);
			cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
			function validateOneOf() {
				schArr.forEach((sch, i) => {
					let schCxt;
					if ((0, util_1.alwaysValidSchema)(it, sch)) {
						gen.var(schValid, true);
					} else {
						schCxt = cxt.subschema({
							keyword: "oneOf",
							schemaProp: i,
							compositeRule: true
						}, schValid);
					}
					if (i > 0) {
						gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
					}
					gen.if(schValid, () => {
						gen.assign(valid, true);
						gen.assign(passing, i);
						if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);
					});
				});
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1 = require_util();
	const def = {
		keyword: "allOf",
		schemaType: "array",
		code(cxt) {
			const { gen, schema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema)) throw new Error("ajv implementation error");
			const valid = gen.name("valid");
			schema.forEach((sch, i) => {
				if ((0, util_1.alwaysValidSchema)(it, sch)) return;
				const schCxt = cxt.subschema({
					keyword: "allOf",
					schemaProp: i
				}, valid);
				cxt.ok(valid);
				cxt.mergeEvaluated(schCxt);
			});
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const util_1 = require_util();
	const error = {
		message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
		params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
	};
	const def = {
		keyword: "if",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		error,
		code(cxt) {
			const { gen, parentSchema, it } = cxt;
			if (parentSchema.then === undefined && parentSchema.else === undefined) {
				(0, util_1.checkStrictMode)(it, "\"if\" without \"then\" and \"else\" is ignored");
			}
			const hasThen = hasSchema(it, "then");
			const hasElse = hasSchema(it, "else");
			if (!hasThen && !hasElse) return;
			const valid = gen.let("valid", true);
			const schValid = gen.name("_valid");
			validateIf();
			cxt.reset();
			if (hasThen && hasElse) {
				const ifClause = gen.let("ifClause");
				cxt.setParams({ ifClause });
				gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
			} else if (hasThen) {
				gen.if(schValid, validateClause("then"));
			} else {
				gen.if((0, codegen_1.not)(schValid), validateClause("else"));
			}
			cxt.pass(valid, () => cxt.error(true));
			function validateIf() {
				const schCxt = cxt.subschema({
					keyword: "if",
					compositeRule: true,
					createErrors: false,
					allErrors: false
				}, schValid);
				cxt.mergeEvaluated(schCxt);
			}
			function validateClause(keyword, ifClause) {
				return () => {
					const schCxt = cxt.subschema({ keyword }, schValid);
					gen.assign(valid, schValid);
					cxt.mergeValidEvaluated(schCxt, valid);
					if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
					else cxt.setParams({ ifClause: keyword });
				};
			}
		}
	};
	function hasSchema(it, keyword) {
		const schema = it.schema[keyword];
		return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
	}
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1 = require_util();
	const def = {
		keyword: ["then", "else"],
		schemaType: ["object", "boolean"],
		code({ keyword, parentSchema, it }) {
			if (parentSchema.if === undefined) (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const additionalItems_1 = require_additionalItems();
	const prefixItems_1 = require_prefixItems();
	const items_1 = require_items();
	const items2020_1 = require_items2020();
	const contains_1 = require_contains();
	const dependencies_1 = require_dependencies();
	const propertyNames_1 = require_propertyNames();
	const additionalProperties_1 = require_additionalProperties();
	const properties_1 = require_properties();
	const patternProperties_1 = require_patternProperties();
	const not_1 = require_not();
	const anyOf_1 = require_anyOf();
	const oneOf_1 = require_oneOf();
	const allOf_1 = require_allOf();
	const if_1 = require_if();
	const thenElse_1 = require_thenElse();
	function getApplicator(draft2020 = false) {
		const applicator = [
			not_1.default,
			anyOf_1.default,
			oneOf_1.default,
			allOf_1.default,
			if_1.default,
			thenElse_1.default,
			propertyNames_1.default,
			additionalProperties_1.default,
			dependencies_1.default,
			properties_1.default,
			patternProperties_1.default
		];
		if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
		else applicator.push(additionalItems_1.default, items_1.default);
		applicator.push(contains_1.default);
		return applicator;
	}
	exports.default = getApplicator;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/format/format.js
var require_format$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const error = {
		message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
		params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
	};
	const def = {
		keyword: "format",
		type: ["number", "string"],
		schemaType: "string",
		$data: true,
		error,
		code(cxt, ruleType) {
			const { gen, data, $data, schema, schemaCode, it } = cxt;
			const { opts, errSchemaPath, schemaEnv, self } = it;
			if (!opts.validateFormats) return;
			if ($data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
				const fType = gen.let("fType");
				const format$2 = gen.let("format");
				gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format$2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format$2, fDef));
				cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
				function unknownFmt() {
					if (opts.strictSchema === false) return codegen_1.nil;
					return (0, codegen_1._)`${schemaCode} && !${format$2}`;
				}
				function invalidFmt() {
					const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format$2}(${data}) : ${format$2}(${data}))` : (0, codegen_1._)`${format$2}(${data})`;
					const validData = (0, codegen_1._)`(typeof ${format$2} == "function" ? ${callFormat} : ${format$2}.test(${data}))`;
					return (0, codegen_1._)`${format$2} && ${format$2} !== true && ${fType} === ${ruleType} && !${validData}`;
				}
			}
			function validateFormat() {
				const formatDef = self.formats[schema];
				if (!formatDef) {
					unknownFormat();
					return;
				}
				if (formatDef === true) return;
				const [fmtType, format$2, fmtRef] = getFormat(formatDef);
				if (fmtType === ruleType) cxt.pass(validCondition());
				function unknownFormat() {
					if (opts.strictSchema === false) {
						self.logger.warn(unknownMsg());
						return;
					}
					throw new Error(unknownMsg());
					function unknownMsg() {
						return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
					}
				}
				function getFormat(fmtDef) {
					const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;
					const fmt = gen.scopeValue("formats", {
						key: schema,
						ref: fmtDef,
						code
					});
					if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
						return [
							fmtDef.type || "string",
							fmtDef.validate,
							(0, codegen_1._)`${fmt}.validate`
						];
					}
					return [
						"string",
						fmtDef,
						fmt
					];
				}
				function validCondition() {
					if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
						if (!schemaEnv.$async) throw new Error("async format in sync schema");
						return (0, codegen_1._)`await ${fmtRef}(${data})`;
					}
					return typeof format$2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
				}
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/format/index.js
var require_format = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const format_1 = require_format$1();
	const format = [format_1.default];
	exports.default = format;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.contentVocabulary = exports.metadataVocabulary = void 0;
	exports.metadataVocabulary = [
		"title",
		"description",
		"default",
		"deprecated",
		"readOnly",
		"writeOnly",
		"examples"
	];
	exports.contentVocabulary = [
		"contentMediaType",
		"contentEncoding",
		"contentSchema"
	];
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const core_1 = require_core();
	const validation_1 = require_validation();
	const applicator_1 = require_applicator();
	const format_1 = require_format();
	const metadata_1 = require_metadata();
	const draft7Vocabularies = [
		core_1.default,
		validation_1.default,
		(0, applicator_1.default)(),
		format_1.default,
		metadata_1.metadataVocabulary,
		metadata_1.contentVocabulary
	];
	exports.default = draft7Vocabularies;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DiscrError = void 0;
	var DiscrError;
	(function(DiscrError) {
		DiscrError["Tag"] = "tag";
		DiscrError["Mapping"] = "mapping";
	})(DiscrError || (exports.DiscrError = DiscrError = {}));
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1 = require_codegen();
	const types_1 = require_types();
	const compile_1 = require_compile();
	const ref_error_1 = require_ref_error();
	const util_1 = require_util();
	const error = {
		message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
		params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
	};
	const def = {
		keyword: "discriminator",
		type: "object",
		schemaType: "object",
		error,
		code(cxt) {
			const { gen, data, schema, parentSchema, it } = cxt;
			const { oneOf } = parentSchema;
			if (!it.opts.discriminator) {
				throw new Error("discriminator: requires discriminator option");
			}
			const tagName = schema.propertyName;
			if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
			if (schema.mapping) throw new Error("discriminator: mapping is not supported");
			if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
			const valid = gen.let("valid", false);
			const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
			gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, {
				discrError: types_1.DiscrError.Tag,
				tag,
				tagName
			}));
			cxt.ok(valid);
			function validateMapping() {
				const mapping = getMapping();
				gen.if(false);
				for (const tagValue in mapping) {
					gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
					gen.assign(valid, applyTagSchema(mapping[tagValue]));
				}
				gen.else();
				cxt.error(false, {
					discrError: types_1.DiscrError.Mapping,
					tag,
					tagName
				});
				gen.endIf();
			}
			function applyTagSchema(schemaProp) {
				const _valid = gen.name("valid");
				const schCxt = cxt.subschema({
					keyword: "oneOf",
					schemaProp
				}, _valid);
				cxt.mergeEvaluated(schCxt, codegen_1.Name);
				return _valid;
			}
			function getMapping() {
				var _a$1;
				const oneOfMapping = {};
				const topRequired = hasRequired(parentSchema);
				let tagRequired = true;
				for (let i = 0; i < oneOf.length; i++) {
					let sch = oneOf[i];
					if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
						const ref = sch.$ref;
						sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
						if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
						if (sch === undefined) throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
					}
					const propSch = (_a$1 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a$1 === void 0 ? void 0 : _a$1[tagName];
					if (typeof propSch != "object") {
						throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
					}
					tagRequired = tagRequired && (topRequired || hasRequired(sch));
					addMappings(propSch, i);
				}
				if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
				return oneOfMapping;
				function hasRequired({ required: required$2 }) {
					return Array.isArray(required$2) && required$2.includes(tagName);
				}
				function addMappings(sch, i) {
					if (sch.const) {
						addMapping(sch.const, i);
					} else if (sch.enum) {
						for (const tagValue of sch.enum) {
							addMapping(tagValue, i);
						}
					} else {
						throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
					}
				}
				function addMapping(tagValue, i) {
					if (typeof tagValue != "string" || tagValue in oneOfMapping) {
						throw new Error(`discriminator: "${tagName}" values must be unique strings`);
					}
					oneOfMapping[tagValue] = i;
				}
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "http://json-schema.org/draft-07/schema#",
		"title": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": { "$ref": "#" }
			},
			"nonNegativeInteger": {
				"type": "integer",
				"minimum": 0
			},
			"nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] },
			"simpleTypes": { "enum": [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			"stringArray": {
				"type": "array",
				"items": { "type": "string" },
				"uniqueItems": true,
				"default": []
			}
		},
		"type": ["object", "boolean"],
		"properties": {
			"$id": {
				"type": "string",
				"format": "uri-reference"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"$ref": {
				"type": "string",
				"format": "uri-reference"
			},
			"$comment": { "type": "string" },
			"title": { "type": "string" },
			"description": { "type": "string" },
			"default": true,
			"readOnly": {
				"type": "boolean",
				"default": false
			},
			"examples": {
				"type": "array",
				"items": true
			},
			"multipleOf": {
				"type": "number",
				"exclusiveMinimum": 0
			},
			"maximum": { "type": "number" },
			"exclusiveMaximum": { "type": "number" },
			"minimum": { "type": "number" },
			"exclusiveMinimum": { "type": "number" },
			"maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
			"minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": { "$ref": "#" },
			"items": {
				"anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
				"default": true
			},
			"maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
			"minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"contains": { "$ref": "#" },
			"maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
			"minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"required": { "$ref": "#/definitions/stringArray" },
			"additionalProperties": { "$ref": "#" },
			"definitions": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"propertyNames": { "format": "regex" },
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] }
			},
			"propertyNames": { "$ref": "#" },
			"const": true,
			"enum": {
				"type": "array",
				"items": true,
				"minItems": 1,
				"uniqueItems": true
			},
			"type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
				"type": "array",
				"items": { "$ref": "#/definitions/simpleTypes" },
				"minItems": 1,
				"uniqueItems": true
			}] },
			"format": { "type": "string" },
			"contentMediaType": { "type": "string" },
			"contentEncoding": { "type": "string" },
			"if": { "$ref": "#" },
			"then": { "$ref": "#" },
			"else": { "$ref": "#" },
			"allOf": { "$ref": "#/definitions/schemaArray" },
			"anyOf": { "$ref": "#/definitions/schemaArray" },
			"oneOf": { "$ref": "#/definitions/schemaArray" },
			"not": { "$ref": "#" }
		},
		"default": true
	};
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv/dist/ajv.js
var require_ajv = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
	const core_1 = require_core$1();
	const draft7_1 = require_draft7();
	const discriminator_1 = require_discriminator();
	const draft7MetaSchema = require_json_schema_draft_07();
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	var Ajv = class extends core_1.default {
		_addVocabularies() {
			super._addVocabularies();
			draft7_1.default.forEach((v) => this.addVocabulary(v));
			if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
		}
		_addDefaultMetaSchema() {
			super._addDefaultMetaSchema();
			if (!this.opts.meta) return;
			const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
			this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
			this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		}
		defaultMeta() {
			return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
		}
	};
	exports.Ajv = Ajv;
	module.exports = exports = Ajv;
	module.exports.Ajv = Ajv;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv;
	var validate_1 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1.KeywordCxt;
		}
	});
	var codegen_1 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1.CodeGen;
		}
	});
	var validation_error_1 = require_validation_error();
	Object.defineProperty(exports, "ValidationError", {
		enumerable: true,
		get: function() {
			return validation_error_1.default;
		}
	});
	var ref_error_1 = require_ref_error();
	Object.defineProperty(exports, "MissingRefError", {
		enumerable: true,
		get: function() {
			return ref_error_1.default;
		}
	});
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv-formats/dist/formats.js
var require_formats = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
	function fmtDef(validate, compare) {
		return {
			validate,
			compare
		};
	}
	exports.fullFormats = {
		date: fmtDef(date, compareDate),
		time: fmtDef(getTime(true), compareTime),
		"date-time": fmtDef(getDateTime(true), compareDateTime),
		"iso-time": fmtDef(getTime(), compareIsoTime),
		"iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
		duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
		uri,
		"uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
		"uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
		url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
		email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
		hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
		ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
		ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
		regex,
		uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
		"json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
		"json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
		"relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
		byte,
		int32: {
			type: "number",
			validate: validateInt32
		},
		int64: {
			type: "number",
			validate: validateInt64
		},
		float: {
			type: "number",
			validate: validateNumber
		},
		double: {
			type: "number",
			validate: validateNumber
		},
		password: true,
		binary: true
	};
	exports.fastFormats = {
		...exports.fullFormats,
		date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
		time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
		"date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
		"iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
		"iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
		uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
		"uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
		email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
	};
	exports.formatNames = Object.keys(exports.fullFormats);
	function isLeapYear(year) {
		return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
	}
	const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	const DAYS = [
		0,
		31,
		28,
		31,
		30,
		31,
		30,
		31,
		31,
		30,
		31,
		30,
		31
	];
	function date(str) {
		const matches = DATE.exec(str);
		if (!matches) return false;
		const year = +matches[1];
		const month = +matches[2];
		const day = +matches[3];
		return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
	}
	function compareDate(d1, d2) {
		if (!(d1 && d2)) return undefined;
		if (d1 > d2) return 1;
		if (d1 < d2) return -1;
		return 0;
	}
	const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
	function getTime(strictTimeZone) {
		return function time$3(str) {
			const matches = TIME.exec(str);
			if (!matches) return false;
			const hr = +matches[1];
			const min = +matches[2];
			const sec = +matches[3];
			const tz = matches[4];
			const tzSign = matches[5] === "-" ? -1 : 1;
			const tzH = +(matches[6] || 0);
			const tzM = +(matches[7] || 0);
			if (tzH > 23 || tzM > 59 || strictTimeZone && !tz) return false;
			if (hr <= 23 && min <= 59 && sec < 60) return true;
			const utcMin = min - tzM * tzSign;
			const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
			return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
		};
	}
	function compareTime(s1, s2) {
		if (!(s1 && s2)) return undefined;
		const t1 = new Date("2020-01-01T" + s1).valueOf();
		const t2 = new Date("2020-01-01T" + s2).valueOf();
		if (!(t1 && t2)) return undefined;
		return t1 - t2;
	}
	function compareIsoTime(t1, t2) {
		if (!(t1 && t2)) return undefined;
		const a1 = TIME.exec(t1);
		const a2 = TIME.exec(t2);
		if (!(a1 && a2)) return undefined;
		t1 = a1[1] + a1[2] + a1[3];
		t2 = a2[1] + a2[2] + a2[3];
		if (t1 > t2) return 1;
		if (t1 < t2) return -1;
		return 0;
	}
	const DATE_TIME_SEPARATOR = /t|\s/i;
	function getDateTime(strictTimeZone) {
		const time$3 = getTime(strictTimeZone);
		return function date_time(str) {
			const dateTime = str.split(DATE_TIME_SEPARATOR);
			return dateTime.length === 2 && date(dateTime[0]) && time$3(dateTime[1]);
		};
	}
	function compareDateTime(dt1, dt2) {
		if (!(dt1 && dt2)) return undefined;
		const d1 = new Date(dt1).valueOf();
		const d2 = new Date(dt2).valueOf();
		if (!(d1 && d2)) return undefined;
		return d1 - d2;
	}
	function compareIsoDateTime(dt1, dt2) {
		if (!(dt1 && dt2)) return undefined;
		const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
		const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
		const res = compareDate(d1, d2);
		if (res === undefined) return undefined;
		return res || compareTime(t1, t2);
	}
	const NOT_URI_FRAGMENT = /\/|:/;
	const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	function uri(str) {
		return NOT_URI_FRAGMENT.test(str) && URI.test(str);
	}
	const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
	function byte(str) {
		BYTE.lastIndex = 0;
		return BYTE.test(str);
	}
	const MIN_INT32 = -(2 ** 31);
	const MAX_INT32 = 2 ** 31 - 1;
	function validateInt32(value) {
		return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
	}
	function validateInt64(value) {
		return Number.isInteger(value);
	}
	function validateNumber() {
		return true;
	}
	const Z_ANCHOR = /[^\\]\\Z/;
	function regex(str) {
		if (Z_ANCHOR.test(str)) return false;
		try {
			new RegExp(str);
			return true;
		} catch (e) {
			return false;
		}
	}
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv-formats/dist/limit.js
var require_limit = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formatLimitDefinition = void 0;
	const ajv_1 = require_ajv();
	const codegen_1 = require_codegen();
	const ops = codegen_1.operators;
	const KWDs = {
		formatMaximum: {
			okStr: "<=",
			ok: ops.LTE,
			fail: ops.GT
		},
		formatMinimum: {
			okStr: ">=",
			ok: ops.GTE,
			fail: ops.LT
		},
		formatExclusiveMaximum: {
			okStr: "<",
			ok: ops.LT,
			fail: ops.GTE
		},
		formatExclusiveMinimum: {
			okStr: ">",
			ok: ops.GT,
			fail: ops.LTE
		}
	};
	const error = {
		message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
		params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
	};
	exports.formatLimitDefinition = {
		keyword: Object.keys(KWDs),
		type: "string",
		schemaType: "string",
		$data: true,
		error,
		code(cxt) {
			const { gen, data, schemaCode, keyword, it } = cxt;
			const { opts, self } = it;
			if (!opts.validateFormats) return;
			const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
			if (fCxt.$data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
				cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
			}
			function validateFormat() {
				const format$2 = fCxt.schema;
				const fmtDef = self.formats[format$2];
				if (!fmtDef || fmtDef === true) return;
				if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
					throw new Error(`"${keyword}": format "${format$2}" does not define "compare" function`);
				}
				const fmt = gen.scopeValue("formats", {
					key: format$2,
					ref: fmtDef,
					code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format$2)}` : undefined
				});
				cxt.fail$data(compareCode(fmt));
			}
			function compareCode(fmt) {
				return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
			}
		},
		dependencies: ["format"]
	};
	const formatLimitPlugin = (ajv) => {
		ajv.addKeyword(exports.formatLimitDefinition);
		return ajv;
	};
	exports.default = formatLimitPlugin;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/ajv-formats/dist/index.js
var require_dist = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const formats_1 = require_formats();
	const limit_1 = require_limit();
	const codegen_1 = require_codegen();
	const fullName = new codegen_1.Name("fullFormats");
	const fastName = new codegen_1.Name("fastFormats");
	const formatsPlugin = (ajv, opts = { keywords: true }) => {
		if (Array.isArray(opts)) {
			addFormats(ajv, opts, formats_1.fullFormats, fullName);
			return ajv;
		}
		const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
		const list = opts.formats || formats_1.formatNames;
		addFormats(ajv, list, formats, exportName);
		if (opts.keywords) (0, limit_1.default)(ajv);
		return ajv;
	};
	formatsPlugin.get = (name, mode = "full") => {
		const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
		const f = formats[name];
		if (!f) throw new Error(`Unknown format "${name}"`);
		return f;
	};
	function addFormats(ajv, list, fs$12, exportName) {
		var _a$1;
		var _b;
		(_a$1 = (_b = ajv.opts.code).formats) !== null && _a$1 !== void 0 ? _a$1 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
		for (const f of list) ajv.addFormat(f, fs$12[f]);
	}
	module.exports = exports = formatsPlugin;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = formatsPlugin;
}));

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = /* @__PURE__ */ __toESM(require_ajv(), 1);
var import_dist = /* @__PURE__ */ __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
	const ajv = new import_ajv.default({
		strict: false,
		validateFormats: true,
		validateSchema: false,
		allErrors: true
	});
	const addFormats = import_dist.default;
	addFormats(ajv);
	return ajv;
}
/**
* @example
* ```typescript
* // Use with default AJV instance (recommended)
* import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
* const validator = new AjvJsonSchemaValidator();
*
* // Use with custom AJV instance
* import { Ajv } from 'ajv';
* const ajv = new Ajv({ strict: true, allErrors: true });
* const validator = new AjvJsonSchemaValidator(ajv);
* ```
*/
var AjvJsonSchemaValidator = class {
	/**
	* Create an AJV validator
	*
	* @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
	*
	* @example
	* ```typescript
	* // Use default configuration (recommended for most cases)
	* import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
	* const validator = new AjvJsonSchemaValidator();
	*
	* // Or provide custom AJV instance for advanced configuration
	* import { Ajv } from 'ajv';
	* import addFormats from 'ajv-formats';
	*
	* const ajv = new Ajv({ validateFormats: true });
	* addFormats(ajv);
	* const validator = new AjvJsonSchemaValidator(ajv);
	* ```
	*/
	constructor(ajv) {
		this._ajv = ajv ?? createDefaultAjvInstance();
	}
	/**
	* Create a validator for the given JSON Schema
	*
	* The validator is compiled once and can be reused multiple times.
	* If the schema has an $id, it will be cached by AJV automatically.
	*
	* @param schema - Standard JSON Schema object
	* @returns A validator function that validates input data
	*/
	getValidator(schema) {
		const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
		return (input) => {
			const valid = ajvValidator(input);
			if (valid) {
				return {
					valid: true,
					data: input,
					errorMessage: undefined
				};
			} else {
				return {
					valid: false,
					data: undefined,
					errorMessage: this._ajv.errorsText(ajvValidator.errors)
				};
			}
		};
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
/**
* Experimental client task features for MCP SDK.
* WARNING: These APIs are experimental and may change without notice.
*
* @experimental
*/
/**
* Experimental task features for MCP clients.
*
* Access via `client.experimental.tasks`:
* ```typescript
* const stream = client.experimental.tasks.callToolStream({ name: 'tool', arguments: {} });
* const task = await client.experimental.tasks.getTask(taskId);
* ```
*
* @experimental
*/
var ExperimentalClientTasks = class {
	constructor(_client) {
		this._client = _client;
	}
	/**
	* Calls a tool and returns an AsyncGenerator that yields response messages.
	* The generator is guaranteed to end with either a 'result' or 'error' message.
	*
	* This method provides streaming access to tool execution, allowing you to
	* observe intermediate task status updates for long-running tool calls.
	* Automatically validates structured output if the tool has an outputSchema.
	*
	* @example
	* ```typescript
	* const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });
	* for await (const message of stream) {
	*   switch (message.type) {
	*     case 'taskCreated':
	*       console.log('Tool execution started:', message.task.taskId);
	*       break;
	*     case 'taskStatus':
	*       console.log('Tool status:', message.task.status);
	*       break;
	*     case 'result':
	*       console.log('Tool result:', message.result);
	*       break;
	*     case 'error':
	*       console.error('Tool error:', message.error);
	*       break;
	*   }
	* }
	* ```
	*
	* @param params - Tool call parameters (name and arguments)
	* @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)
	* @param options - Optional request options (timeout, signal, task creation params, etc.)
	* @returns AsyncGenerator that yields ResponseMessage objects
	*
	* @experimental
	*/
	async *callToolStream(params, resultSchema = CallToolResultSchema, options) {
		const clientInternal = this._client;
		const optionsWithTask = {
			...options,
			task: options?.task ?? (clientInternal.isToolTask(params.name) ? {} : undefined)
		};
		const stream$1 = clientInternal.requestStream({
			method: "tools/call",
			params
		}, resultSchema, optionsWithTask);
		const validator = clientInternal.getToolOutputValidator(params.name);
		for await (const message of stream$1) {
			if (message.type === "result" && validator) {
				const result = message.result;
				if (!result.structuredContent && !result.isError) {
					yield {
						type: "error",
						error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
					};
					return;
				}
				if (result.structuredContent) {
					try {
						const validationResult = validator(result.structuredContent);
						if (!validationResult.valid) {
							yield {
								type: "error",
								error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
							};
							return;
						}
					} catch (error$47) {
						if (error$47 instanceof McpError) {
							yield {
								type: "error",
								error: error$47
							};
							return;
						}
						yield {
							type: "error",
							error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error$47 instanceof Error ? error$47.message : String(error$47)}`)
						};
						return;
					}
				}
			}
			yield message;
		}
	}
	/**
	* Gets the current status of a task.
	*
	* @param taskId - The task identifier
	* @param options - Optional request options
	* @returns The task status
	*
	* @experimental
	*/
	async getTask(taskId, options) {
		return this._client.getTask({ taskId }, options);
	}
	/**
	* Retrieves the result of a completed task.
	*
	* @param taskId - The task identifier
	* @param resultSchema - Zod schema for validating the result
	* @param options - Optional request options
	* @returns The task result
	*
	* @experimental
	*/
	async getTaskResult(taskId, resultSchema, options) {
		return this._client.getTaskResult({ taskId }, resultSchema, options);
	}
	/**
	* Lists tasks with optional pagination.
	*
	* @param cursor - Optional pagination cursor
	* @param options - Optional request options
	* @returns List of tasks with optional next cursor
	*
	* @experimental
	*/
	async listTasks(cursor, options) {
		return this._client.listTasks(cursor ? { cursor } : undefined, options);
	}
	/**
	* Cancels a running task.
	*
	* @param taskId - The task identifier
	* @param options - Optional request options
	*
	* @experimental
	*/
	async cancelTask(taskId, options) {
		return this._client.cancelTask({ taskId }, options);
	}
	/**
	* Sends a request and returns an AsyncGenerator that yields response messages.
	* The generator is guaranteed to end with either a 'result' or 'error' message.
	*
	* This method provides streaming access to request processing, allowing you to
	* observe intermediate task status updates for task-augmented requests.
	*
	* @param request - The request to send
	* @param resultSchema - Zod schema for validating the result
	* @param options - Optional request options (timeout, signal, task creation params, etc.)
	* @returns AsyncGenerator that yields ResponseMessage objects
	*
	* @experimental
	*/
	requestStream(request, resultSchema, options) {
		return this._client.requestStream(request, resultSchema, options);
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
/**
* Experimental task capability assertion helpers.
* WARNING: These APIs are experimental and may change without notice.
*
* @experimental
*/
/**
* Asserts that task creation is supported for tools/call.
* Used by Client.assertTaskCapability and Server.assertTaskHandlerCapability.
*
* @param requests - The task requests capability object
* @param method - The method being checked
* @param entityName - 'Server' or 'Client' for error messages
* @throws Error if the capability is not supported
*
* @experimental
*/
function assertToolsCallTaskCapability(requests, method, entityName) {
	if (!requests) {
		throw new Error(`${entityName} does not support task creation (required for ${method})`);
	}
	switch (method) {
		case "tools/call":
			if (!requests.tools?.call) {
				throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
			}
			break;
		default: break;
	}
}
/**
* Asserts that task creation is supported for sampling/createMessage or elicitation/create.
* Used by Server.assertTaskCapability and Client.assertTaskHandlerCapability.
*
* @param requests - The task requests capability object
* @param method - The method being checked
* @param entityName - 'Server' or 'Client' for error messages
* @throws Error if the capability is not supported
*
* @experimental
*/
function assertClientRequestTaskCapability(requests, method, entityName) {
	if (!requests) {
		throw new Error(`${entityName} does not support task creation (required for ${method})`);
	}
	switch (method) {
		case "sampling/createMessage":
			if (!requests.sampling?.createMessage) {
				throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
			}
			break;
		case "elicitation/create":
			if (!requests.elicitation?.create) {
				throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
			}
			break;
		default: break;
	}
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
/**
* Elicitation default application helper. Applies defaults to the data based on the schema.
*
* @param schema - The schema to apply defaults to.
* @param data - The data to apply defaults to.
*/
function applyElicitationDefaults(schema, data) {
	if (!schema || data === null || typeof data !== "object") return;
	if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
		const obj = data;
		const props = schema.properties;
		for (const key of Object.keys(props)) {
			const propSchema = props[key];
			if (obj[key] === undefined && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
				obj[key] = propSchema.default;
			}
			if (obj[key] !== undefined) {
				applyElicitationDefaults(propSchema, obj[key]);
			}
		}
	}
	if (Array.isArray(schema.anyOf)) {
		for (const sub of schema.anyOf) {
			if (typeof sub !== "boolean") {
				applyElicitationDefaults(sub, data);
			}
		}
	}
	if (Array.isArray(schema.oneOf)) {
		for (const sub of schema.oneOf) {
			if (typeof sub !== "boolean") {
				applyElicitationDefaults(sub, data);
			}
		}
	}
}
/**
* Determines which elicitation modes are supported based on declared client capabilities.
*
* According to the spec:
* - An empty elicitation capability object defaults to form mode support (backwards compatibility)
* - URL mode is only supported if explicitly declared
*
* @param capabilities - The client's elicitation capabilities
* @returns An object indicating which modes are supported
*/
function getSupportedElicitationModes(capabilities) {
	if (!capabilities) {
		return {
			supportsFormMode: false,
			supportsUrlMode: false
		};
	}
	const hasFormCapability = capabilities.form !== undefined;
	const hasUrlCapability = capabilities.url !== undefined;
	const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
	const supportsUrlMode = hasUrlCapability;
	return {
		supportsFormMode,
		supportsUrlMode
	};
}
/**
* An MCP client on top of a pluggable transport.
*
* The client will automatically begin the initialization flow with the server when connect() is called.
*
* To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
*
* ```typescript
* // Custom schemas
* const CustomRequestSchema = RequestSchema.extend({...})
* const CustomNotificationSchema = NotificationSchema.extend({...})
* const CustomResultSchema = ResultSchema.extend({...})
*
* // Type aliases
* type CustomRequest = z.infer<typeof CustomRequestSchema>
* type CustomNotification = z.infer<typeof CustomNotificationSchema>
* type CustomResult = z.infer<typeof CustomResultSchema>
*
* // Create typed client
* const client = new Client<CustomRequest, CustomNotification, CustomResult>({
*   name: "CustomClient",
*   version: "1.0.0"
* })
* ```
*/
var Client = class extends Protocol {
	/**
	* Initializes this client with the given name and version information.
	*/
	constructor(_clientInfo, options) {
		super(options);
		this._clientInfo = _clientInfo;
		this._cachedToolOutputValidators = new Map();
		this._cachedKnownTaskTools = new Set();
		this._cachedRequiredTaskTools = new Set();
		this._listChangedDebounceTimers = new Map();
		this._capabilities = options?.capabilities ?? {};
		this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator();
		if (options?.listChanged) {
			this._pendingListChangedConfig = options.listChanged;
		}
	}
	/**
	* Set up handlers for list changed notifications based on config and server capabilities.
	* This should only be called after initialization when server capabilities are known.
	* Handlers are silently skipped if the server doesn't advertise the corresponding listChanged capability.
	* @internal
	*/
	_setupListChangedHandlers(config$1) {
		if (config$1.tools && this._serverCapabilities?.tools?.listChanged) {
			this._setupListChangedHandler("tools", ToolListChangedNotificationSchema, config$1.tools, async () => {
				const result = await this.listTools();
				return result.tools;
			});
		}
		if (config$1.prompts && this._serverCapabilities?.prompts?.listChanged) {
			this._setupListChangedHandler("prompts", PromptListChangedNotificationSchema, config$1.prompts, async () => {
				const result = await this.listPrompts();
				return result.prompts;
			});
		}
		if (config$1.resources && this._serverCapabilities?.resources?.listChanged) {
			this._setupListChangedHandler("resources", ResourceListChangedNotificationSchema, config$1.resources, async () => {
				const result = await this.listResources();
				return result.resources;
			});
		}
	}
	/**
	* Access experimental features.
	*
	* WARNING: These APIs are experimental and may change without notice.
	*
	* @experimental
	*/
	get experimental() {
		if (!this._experimental) {
			this._experimental = { tasks: new ExperimentalClientTasks(this) };
		}
		return this._experimental;
	}
	/**
	* Registers new capabilities. This can only be called before connecting to a transport.
	*
	* The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
	*/
	registerCapabilities(capabilities) {
		if (this.transport) {
			throw new Error("Cannot register capabilities after connecting to transport");
		}
		this._capabilities = mergeCapabilities(this._capabilities, capabilities);
	}
	/**
	* Override request handler registration to enforce client-side validation for elicitation.
	*/
	setRequestHandler(requestSchema, handler) {
		const shape = getObjectShape(requestSchema);
		const methodSchema = shape?.method;
		if (!methodSchema) {
			throw new Error("Schema is missing a method literal");
		}
		let methodValue;
		if (isZ4Schema(methodSchema)) {
			const v4Schema = methodSchema;
			const v4Def = v4Schema._zod?.def;
			methodValue = v4Def?.value ?? v4Schema.value;
		} else {
			const v3Schema = methodSchema;
			const legacyDef = v3Schema._def;
			methodValue = legacyDef?.value ?? v3Schema.value;
		}
		if (typeof methodValue !== "string") {
			throw new Error("Schema method literal must be a string");
		}
		const method = methodValue;
		if (method === "elicitation/create") {
			const wrappedHandler = async (request, extra) => {
				const validatedRequest = safeParse(ElicitRequestSchema, request);
				if (!validatedRequest.success) {
					const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
				}
				const { params } = validatedRequest.data;
				params.mode = params.mode ?? "form";
				const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
				if (params.mode === "form" && !supportsFormMode) {
					throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
				}
				if (params.mode === "url" && !supportsUrlMode) {
					throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
				}
				const result = await Promise.resolve(handler(request, extra));
				if (params.task) {
					const taskValidationResult = safeParse(CreateTaskResultSchema, result);
					if (!taskValidationResult.success) {
						const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
						throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
					}
					return taskValidationResult.data;
				}
				const validationResult = safeParse(ElicitResultSchema, result);
				if (!validationResult.success) {
					const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
				}
				const validatedResult = validationResult.data;
				const requestedSchema = params.mode === "form" ? params.requestedSchema : undefined;
				if (params.mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
					if (this._capabilities.elicitation?.form?.applyDefaults) {
						try {
							applyElicitationDefaults(requestedSchema, validatedResult.content);
						} catch {}
					}
				}
				return validatedResult;
			};
			return super.setRequestHandler(requestSchema, wrappedHandler);
		}
		if (method === "sampling/createMessage") {
			const wrappedHandler = async (request, extra) => {
				const validatedRequest = safeParse(CreateMessageRequestSchema, request);
				if (!validatedRequest.success) {
					const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
				}
				const { params } = validatedRequest.data;
				const result = await Promise.resolve(handler(request, extra));
				if (params.task) {
					const taskValidationResult = safeParse(CreateTaskResultSchema, result);
					if (!taskValidationResult.success) {
						const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
						throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
					}
					return taskValidationResult.data;
				}
				const validationResult = safeParse(CreateMessageResultSchema, result);
				if (!validationResult.success) {
					const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
				}
				return validationResult.data;
			};
			return super.setRequestHandler(requestSchema, wrappedHandler);
		}
		return super.setRequestHandler(requestSchema, handler);
	}
	assertCapability(capability, method) {
		if (!this._serverCapabilities?.[capability]) {
			throw new Error(`Server does not support ${capability} (required for ${method})`);
		}
	}
	async connect(transport, options) {
		await super.connect(transport);
		if (transport.sessionId !== undefined) {
			return;
		}
		try {
			const result = await this.request({
				method: "initialize",
				params: {
					protocolVersion: LATEST_PROTOCOL_VERSION,
					capabilities: this._capabilities,
					clientInfo: this._clientInfo
				}
			}, InitializeResultSchema, options);
			if (result === undefined) {
				throw new Error(`Server sent invalid initialize result: ${result}`);
			}
			if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
				throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
			}
			this._serverCapabilities = result.capabilities;
			this._serverVersion = result.serverInfo;
			if (transport.setProtocolVersion) {
				transport.setProtocolVersion(result.protocolVersion);
			}
			this._instructions = result.instructions;
			await this.notification({ method: "notifications/initialized" });
			if (this._pendingListChangedConfig) {
				this._setupListChangedHandlers(this._pendingListChangedConfig);
				this._pendingListChangedConfig = undefined;
			}
		} catch (error$47) {
			void this.close();
			throw error$47;
		}
	}
	/**
	* After initialization has completed, this will be populated with the server's reported capabilities.
	*/
	getServerCapabilities() {
		return this._serverCapabilities;
	}
	/**
	* After initialization has completed, this will be populated with information about the server's name and version.
	*/
	getServerVersion() {
		return this._serverVersion;
	}
	/**
	* After initialization has completed, this may be populated with information about the server's instructions.
	*/
	getInstructions() {
		return this._instructions;
	}
	assertCapabilityForMethod(method) {
		switch (method) {
			case "logging/setLevel":
				if (!this._serverCapabilities?.logging) {
					throw new Error(`Server does not support logging (required for ${method})`);
				}
				break;
			case "prompts/get":
			case "prompts/list":
				if (!this._serverCapabilities?.prompts) {
					throw new Error(`Server does not support prompts (required for ${method})`);
				}
				break;
			case "resources/list":
			case "resources/templates/list":
			case "resources/read":
			case "resources/subscribe":
			case "resources/unsubscribe":
				if (!this._serverCapabilities?.resources) {
					throw new Error(`Server does not support resources (required for ${method})`);
				}
				if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
					throw new Error(`Server does not support resource subscriptions (required for ${method})`);
				}
				break;
			case "tools/call":
			case "tools/list":
				if (!this._serverCapabilities?.tools) {
					throw new Error(`Server does not support tools (required for ${method})`);
				}
				break;
			case "completion/complete":
				if (!this._serverCapabilities?.completions) {
					throw new Error(`Server does not support completions (required for ${method})`);
				}
				break;
			case "initialize": break;
			case "ping": break;
		}
	}
	assertNotificationCapability(method) {
		switch (method) {
			case "notifications/roots/list_changed":
				if (!this._capabilities.roots?.listChanged) {
					throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
				}
				break;
			case "notifications/initialized": break;
			case "notifications/cancelled": break;
			case "notifications/progress": break;
		}
	}
	assertRequestHandlerCapability(method) {
		if (!this._capabilities) {
			return;
		}
		switch (method) {
			case "sampling/createMessage":
				if (!this._capabilities.sampling) {
					throw new Error(`Client does not support sampling capability (required for ${method})`);
				}
				break;
			case "elicitation/create":
				if (!this._capabilities.elicitation) {
					throw new Error(`Client does not support elicitation capability (required for ${method})`);
				}
				break;
			case "roots/list":
				if (!this._capabilities.roots) {
					throw new Error(`Client does not support roots capability (required for ${method})`);
				}
				break;
			case "tasks/get":
			case "tasks/list":
			case "tasks/result":
			case "tasks/cancel":
				if (!this._capabilities.tasks) {
					throw new Error(`Client does not support tasks capability (required for ${method})`);
				}
				break;
			case "ping": break;
		}
	}
	assertTaskCapability(method) {
		assertToolsCallTaskCapability(this._serverCapabilities?.tasks?.requests, method, "Server");
	}
	assertTaskHandlerCapability(method) {
		if (!this._capabilities) {
			return;
		}
		assertClientRequestTaskCapability(this._capabilities.tasks?.requests, method, "Client");
	}
	async ping(options) {
		return this.request({ method: "ping" }, EmptyResultSchema, options);
	}
	async complete(params, options) {
		return this.request({
			method: "completion/complete",
			params
		}, CompleteResultSchema, options);
	}
	async setLoggingLevel(level, options) {
		return this.request({
			method: "logging/setLevel",
			params: { level }
		}, EmptyResultSchema, options);
	}
	async getPrompt(params, options) {
		return this.request({
			method: "prompts/get",
			params
		}, GetPromptResultSchema, options);
	}
	async listPrompts(params, options) {
		return this.request({
			method: "prompts/list",
			params
		}, ListPromptsResultSchema, options);
	}
	async listResources(params, options) {
		return this.request({
			method: "resources/list",
			params
		}, ListResourcesResultSchema, options);
	}
	async listResourceTemplates(params, options) {
		return this.request({
			method: "resources/templates/list",
			params
		}, ListResourceTemplatesResultSchema, options);
	}
	async readResource(params, options) {
		return this.request({
			method: "resources/read",
			params
		}, ReadResourceResultSchema, options);
	}
	async subscribeResource(params, options) {
		return this.request({
			method: "resources/subscribe",
			params
		}, EmptyResultSchema, options);
	}
	async unsubscribeResource(params, options) {
		return this.request({
			method: "resources/unsubscribe",
			params
		}, EmptyResultSchema, options);
	}
	/**
	* Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.
	*
	* For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.
	*/
	async callTool(params, resultSchema = CallToolResultSchema, options) {
		if (this.isToolTaskRequired(params.name)) {
			throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
		}
		const result = await this.request({
			method: "tools/call",
			params
		}, resultSchema, options);
		const validator = this.getToolOutputValidator(params.name);
		if (validator) {
			if (!result.structuredContent && !result.isError) {
				throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
			}
			if (result.structuredContent) {
				try {
					const validationResult = validator(result.structuredContent);
					if (!validationResult.valid) {
						throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
					}
				} catch (error$47) {
					if (error$47 instanceof McpError) {
						throw error$47;
					}
					throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error$47 instanceof Error ? error$47.message : String(error$47)}`);
				}
			}
		}
		return result;
	}
	isToolTask(toolName) {
		if (!this._serverCapabilities?.tasks?.requests?.tools?.call) {
			return false;
		}
		return this._cachedKnownTaskTools.has(toolName);
	}
	/**
	* Check if a tool requires task-based execution.
	* Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.
	*/
	isToolTaskRequired(toolName) {
		return this._cachedRequiredTaskTools.has(toolName);
	}
	/**
	* Cache validators for tool output schemas.
	* Called after listTools() to pre-compile validators for better performance.
	*/
	cacheToolMetadata(tools) {
		this._cachedToolOutputValidators.clear();
		this._cachedKnownTaskTools.clear();
		this._cachedRequiredTaskTools.clear();
		for (const tool of tools) {
			if (tool.outputSchema) {
				const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
				this._cachedToolOutputValidators.set(tool.name, toolValidator);
			}
			const taskSupport = tool.execution?.taskSupport;
			if (taskSupport === "required" || taskSupport === "optional") {
				this._cachedKnownTaskTools.add(tool.name);
			}
			if (taskSupport === "required") {
				this._cachedRequiredTaskTools.add(tool.name);
			}
		}
	}
	/**
	* Get cached validator for a tool
	*/
	getToolOutputValidator(toolName) {
		return this._cachedToolOutputValidators.get(toolName);
	}
	async listTools(params, options) {
		const result = await this.request({
			method: "tools/list",
			params
		}, ListToolsResultSchema, options);
		this.cacheToolMetadata(result.tools);
		return result;
	}
	/**
	* Set up a single list changed handler.
	* @internal
	*/
	_setupListChangedHandler(listType, notificationSchema, options, fetcher) {
		const parseResult = ListChangedOptionsBaseSchema.safeParse(options);
		if (!parseResult.success) {
			throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);
		}
		if (typeof options.onChanged !== "function") {
			throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);
		}
		const { autoRefresh, debounceMs } = parseResult.data;
		const { onChanged } = options;
		const refresh = async () => {
			if (!autoRefresh) {
				onChanged(null, null);
				return;
			}
			try {
				const items = await fetcher();
				onChanged(null, items);
			} catch (e) {
				const error$47 = e instanceof Error ? e : new Error(String(e));
				onChanged(error$47, null);
			}
		};
		const handler = () => {
			if (debounceMs) {
				const existingTimer = this._listChangedDebounceTimers.get(listType);
				if (existingTimer) {
					clearTimeout(existingTimer);
				}
				const timer = setTimeout(refresh, debounceMs);
				this._listChangedDebounceTimers.set(listType, timer);
			} else {
				refresh();
			}
		};
		this.setNotificationHandler(notificationSchema, handler);
	}
	async sendRootsListChanged() {
		return this.notification({ method: "notifications/roots/list_changed" });
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
	constructor(message, options) {
		super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
	}
};
function noop(_arg) {}
function createParser(callbacks) {
	if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
	const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
	let incompleteLine = "", isFirstChunk = !0, id, data = "", eventType = "";
	function feed(newChunk) {
		const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
		for (const line of complete) parseLine(line);
		incompleteLine = incomplete, isFirstChunk = !1;
	}
	function parseLine(line) {
		if (line === "") {
			dispatchEvent();
			return;
		}
		if (line.startsWith(":")) {
			onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
			return;
		}
		const fieldSeparatorIndex = line.indexOf(":");
		if (fieldSeparatorIndex !== -1) {
			const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
			processField(field, value, line);
			return;
		}
		processField(line, "", line);
	}
	function processField(field, value, line) {
		switch (field) {
			case "event":
				eventType = value;
				break;
			case "data":
				data = `${data}${value}
`;
				break;
			case "id":
				id = value.includes("\0") ? void 0 : value;
				break;
			case "retry":
				/^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
					type: "invalid-retry",
					value,
					line
				}));
				break;
			default:
				onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
					type: "unknown-field",
					field,
					value,
					line
				}));
				break;
		}
	}
	function dispatchEvent() {
		data.length > 0 && onEvent({
			id,
			event: eventType || void 0,
			data: data.endsWith(`
`) ? data.slice(0, -1) : data
		}), id = void 0, data = "", eventType = "";
	}
	function reset(options = {}) {
		incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = "", eventType = "", incompleteLine = "";
	}
	return {
		feed,
		reset
	};
}
function splitLines(chunk) {
	const lines = [];
	let incompleteLine = "", searchIndex = 0;
	for (; searchIndex < chunk.length;) {
		const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
		let lineEnd = -1;
		if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
			incompleteLine = chunk.slice(searchIndex);
			break;
		} else {
			const line = chunk.slice(searchIndex, lineEnd);
			lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
		}
	}
	return [lines, incompleteLine];
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/eventsource/dist/index.js
var ErrorEvent = class extends Event {
	/**
	* Constructs a new `ErrorEvent` instance. This is typically not called directly,
	* but rather emitted by the `EventSource` object when an error occurs.
	*
	* @param type - The type of the event (should be "error")
	* @param errorEventInitDict - Optional properties to include in the error event
	*/
	constructor(type, errorEventInitDict) {
		var _a$1, _b;
		super(type), this.code = (_a$1 = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a$1 : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
	}
	/**
	* Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
	* when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
	* we explicitly include the properties in the `inspect` method.
	*
	* This is automatically called by Node.js when you `console.log` an instance of this class.
	*
	* @param _depth - The current depth
	* @param options - The options passed to `util.inspect`
	* @param inspect - The inspect function to use (prevents having to import it from `util`)
	* @returns A string representation of the error
	*/
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		return inspect(inspectableError(this), options);
	}
	/**
	* Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
	* when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
	* we explicitly include the properties in the `inspect` method.
	*
	* This is automatically called by Deno when you `console.log` an instance of this class.
	*
	* @param inspect - The inspect function to use (prevents having to import it from `util`)
	* @param options - The options passed to `Deno.inspect`
	* @returns A string representation of the error
	*/
	[Symbol.for("Deno.customInspect")](inspect, options) {
		return inspect(inspectableError(this), options);
	}
};
function syntaxError(message) {
	const DomException = globalThis.DOMException;
	return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
function flattenError(err) {
	return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;
}
function inspectableError(err) {
	return {
		type: err.type,
		message: err.message,
		code: err.code,
		defaultPrevented: err.defaultPrevented,
		cancelable: err.cancelable,
		timeStamp: err.timeStamp
	};
}
var __typeError = (msg) => {
	throw TypeError(msg);
}, __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value), __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method), _readyState, _url, _redirectUrl, _withCredentials, _fetch, _reconnectInterval, _reconnectTimer, _lastEventId, _controller, _parser, _onError, _onMessage, _onOpen, _EventSource_instances, connect_fn, _onFetchResponse, _onFetchError, getRequestOptions_fn, _onEvent, _onRetryChange, failConnection_fn, scheduleReconnect_fn, _reconnect;
var EventSource = class extends EventTarget {
	constructor(url$2, eventSourceInitDict) {
		var _a$1, _b;
		super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response) => {
			var _a2;
			__privateGet(this, _parser).reset();
			const { body, redirected, status, headers } = response;
			if (status === 204) {
				__privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
				return;
			}
			if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
				__privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
				return;
			}
			if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
				__privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid content type, expected \"text/event-stream\"", status);
				return;
			}
			if (__privateGet(this, _readyState) === this.CLOSED) return;
			__privateSet(this, _readyState, this.OPEN);
			const openEvent = new Event("open");
			if ((_a2 = __privateGet(this, _onOpen)) == null || _a2.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
				__privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
				return;
			}
			const decoder = new TextDecoder(), reader = body.getReader();
			let open = !0;
			do {
				const { done, value } = await reader.read();
				value && __privateGet(this, _parser).feed(decoder.decode(value, { stream: !done })), done && (open = !1, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
			} while (open);
		}), __privateAdd(this, _onFetchError, (err) => {
			__privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));
		}), __privateAdd(this, _onEvent, (event) => {
			typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
			const messageEvent = new MessageEvent(event.event || "message", {
				data: event.data,
				origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,
				lastEventId: event.id || ""
			});
			__privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
		}), __privateAdd(this, _onRetryChange, (value) => {
			__privateSet(this, _reconnectInterval, value);
		}), __privateAdd(this, _reconnect, () => {
			__privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
		});
		try {
			if (url$2 instanceof URL) __privateSet(this, _url, url$2);
			else if (typeof url$2 == "string") __privateSet(this, _url, new URL(url$2, getBaseURL()));
			else throw new Error("Invalid URL");
		} catch {
			throw syntaxError("An invalid or illegal string was specified");
		}
		__privateSet(this, _parser, createParser({
			onEvent: __privateGet(this, _onEvent),
			onRetry: __privateGet(this, _onRetryChange)
		})), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a$1 = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a$1 : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : !1), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
	}
	/**
	* Returns the state of this EventSource object's connection. It can have the values described below.
	*
	* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
	*
	* Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
	* defined in the TypeScript `dom` library.
	*
	* @public
	*/
	get readyState() {
		return __privateGet(this, _readyState);
	}
	/**
	* Returns the URL providing the event stream.
	*
	* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
	*
	* @public
	*/
	get url() {
		return __privateGet(this, _url).href;
	}
	/**
	* Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
	*
	* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
	*/
	get withCredentials() {
		return __privateGet(this, _withCredentials);
	}
	/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
	get onerror() {
		return __privateGet(this, _onError);
	}
	set onerror(value) {
		__privateSet(this, _onError, value);
	}
	/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
	get onmessage() {
		return __privateGet(this, _onMessage);
	}
	set onmessage(value) {
		__privateSet(this, _onMessage, value);
	}
	/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
	get onopen() {
		return __privateGet(this, _onOpen);
	}
	set onopen(value) {
		__privateSet(this, _onOpen, value);
	}
	addEventListener(type, listener, options) {
		const listen = listener;
		super.addEventListener(type, listen, options);
	}
	removeEventListener(type, listener, options) {
		const listen = listener;
		super.removeEventListener(type, listen, options);
	}
	/**
	* Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
	*
	* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
	*
	* @public
	*/
	close() {
		__privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
	}
};
_readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), connect_fn = function() {
	__privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), getRequestOptions_fn = function() {
	var _a$1;
	const init = {
		mode: "cors",
		redirect: "follow",
		headers: {
			Accept: "text/event-stream",
			...__privateGet(this, _lastEventId) ? { "Last-Event-ID": __privateGet(this, _lastEventId) } : void 0
		},
		cache: "no-store",
		signal: (_a$1 = __privateGet(this, _controller)) == null ? void 0 : _a$1.signal
	};
	return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), failConnection_fn = function(message, code) {
	var _a$1;
	__privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
	const errorEvent = new ErrorEvent("error", {
		code,
		message
	});
	(_a$1 = __privateGet(this, _onError)) == null || _a$1.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, scheduleReconnect_fn = function(message, code) {
	var _a$1;
	if (__privateGet(this, _readyState) === this.CLOSED) return;
	__privateSet(this, _readyState, this.CONNECTING);
	const errorEvent = new ErrorEvent("error", {
		code,
		message
	});
	(_a$1 = __privateGet(this, _onError)) == null || _a$1.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
}, _reconnect = /* @__PURE__ */ new WeakMap(), EventSource.CONNECTING = 0, EventSource.OPEN = 1, EventSource.CLOSED = 2;
function getBaseURL() {
	const doc = "document" in globalThis ? globalThis.document : void 0;
	return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/transport.js
/**
* Normalizes HeadersInit to a plain Record<string, string> for manipulation.
* Handles Headers objects, arrays of tuples, and plain objects.
*/
function normalizeHeaders(headers) {
	if (!headers) return {};
	if (headers instanceof Headers) {
		return Object.fromEntries(headers.entries());
	}
	if (Array.isArray(headers)) {
		return Object.fromEntries(headers);
	}
	return { ...headers };
}
/**
* Creates a fetch function that includes base RequestInit options.
* This ensures requests inherit settings like credentials, mode, headers, etc. from the base init.
*
* @param baseFetch - The base fetch function to wrap (defaults to global fetch)
* @param baseInit - The base RequestInit to merge with each request
* @returns A wrapped fetch function that merges base options with call-specific options
*/
function createFetchWithInit(baseFetch = fetch, baseInit) {
	if (!baseInit) {
		return baseFetch;
	}
	return async (url$2, init) => {
		const mergedInit = {
			...baseInit,
			...init,
			headers: init?.headers ? {
				...normalizeHeaders(baseInit.headers),
				...normalizeHeaders(init.headers)
			} : baseInit.headers
		};
		return baseFetch(url$2, mergedInit);
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/client/sse.js
var SseError = class extends Error {
	constructor(code, message, event) {
		super(`SSE error: ${message}`);
		this.code = code;
		this.event = event;
	}
};
/**
* Client transport for SSE: this will connect to a server using Server-Sent Events for receiving
* messages and make separate POST requests for sending messages.
* @deprecated SSEClientTransport is deprecated. Prefer to use StreamableHTTPClientTransport where possible instead. Note that because some servers are still using SSE, clients may need to support both transports during the migration period.
*/
var SSEClientTransport = class {
	constructor(url$2, opts) {
		this._url = url$2;
		this._resourceMetadataUrl = undefined;
		this._scope = undefined;
		this._eventSourceInit = opts?.eventSourceInit;
		this._requestInit = opts?.requestInit;
		this._authProvider = opts?.authProvider;
		this._fetch = opts?.fetch;
		this._fetchWithInit = createFetchWithInit(opts?.fetch, opts?.requestInit);
	}
	async _authThenStart() {
		if (!this._authProvider) {
			throw new UnauthorizedError("No auth provider");
		}
		let result;
		try {
			result = await auth(this._authProvider, {
				serverUrl: this._url,
				resourceMetadataUrl: this._resourceMetadataUrl,
				scope: this._scope,
				fetchFn: this._fetchWithInit
			});
		} catch (error$47) {
			this.onerror?.(error$47);
			throw error$47;
		}
		if (result !== "AUTHORIZED") {
			throw new UnauthorizedError();
		}
		return await this._startOrAuth();
	}
	async _commonHeaders() {
		const headers = {};
		if (this._authProvider) {
			const tokens = await this._authProvider.tokens();
			if (tokens) {
				headers["Authorization"] = `Bearer ${tokens.access_token}`;
			}
		}
		if (this._protocolVersion) {
			headers["mcp-protocol-version"] = this._protocolVersion;
		}
		const extraHeaders = normalizeHeaders(this._requestInit?.headers);
		return new Headers({
			...headers,
			...extraHeaders
		});
	}
	_startOrAuth() {
		const fetchImpl = this?._eventSourceInit?.fetch ?? this._fetch ?? fetch;
		return new Promise((resolve, reject) => {
			this._eventSource = new EventSource(this._url.href, {
				...this._eventSourceInit,
				fetch: async (url$2, init) => {
					const headers = await this._commonHeaders();
					headers.set("Accept", "text/event-stream");
					const response = await fetchImpl(url$2, {
						...init,
						headers
					});
					if (response.status === 401 && response.headers.has("www-authenticate")) {
						const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
						this._resourceMetadataUrl = resourceMetadataUrl;
						this._scope = scope;
					}
					return response;
				}
			});
			this._abortController = new AbortController();
			this._eventSource.onerror = (event) => {
				if (event.code === 401 && this._authProvider) {
					this._authThenStart().then(resolve, reject);
					return;
				}
				const error$47 = new SseError(event.code, event.message, event);
				reject(error$47);
				this.onerror?.(error$47);
			};
			this._eventSource.onopen = () => {};
			this._eventSource.addEventListener("endpoint", (event) => {
				const messageEvent = event;
				try {
					this._endpoint = new URL(messageEvent.data, this._url);
					if (this._endpoint.origin !== this._url.origin) {
						throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
					}
				} catch (error$47) {
					reject(error$47);
					this.onerror?.(error$47);
					void this.close();
					return;
				}
				resolve();
			});
			this._eventSource.onmessage = (event) => {
				const messageEvent = event;
				let message;
				try {
					message = JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));
				} catch (error$47) {
					this.onerror?.(error$47);
					return;
				}
				this.onmessage?.(message);
			};
		});
	}
	async start() {
		if (this._eventSource) {
			throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
		}
		return await this._startOrAuth();
	}
	/**
	* Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
	*/
	async finishAuth(authorizationCode) {
		if (!this._authProvider) {
			throw new UnauthorizedError("No auth provider");
		}
		const result = await auth(this._authProvider, {
			serverUrl: this._url,
			authorizationCode,
			resourceMetadataUrl: this._resourceMetadataUrl,
			scope: this._scope,
			fetchFn: this._fetchWithInit
		});
		if (result !== "AUTHORIZED") {
			throw new UnauthorizedError("Failed to authorize");
		}
	}
	async close() {
		this._abortController?.abort();
		this._eventSource?.close();
		this.onclose?.();
	}
	async send(message) {
		if (!this._endpoint) {
			throw new Error("Not connected");
		}
		try {
			const headers = await this._commonHeaders();
			headers.set("content-type", "application/json");
			const init = {
				...this._requestInit,
				method: "POST",
				headers,
				body: JSON.stringify(message),
				signal: this._abortController?.signal
			};
			const response = await (this._fetch ?? fetch)(this._endpoint, init);
			if (!response.ok) {
				const text = await response.text().catch(() => null);
				if (response.status === 401 && this._authProvider) {
					const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
					this._resourceMetadataUrl = resourceMetadataUrl;
					this._scope = scope;
					const result = await auth(this._authProvider, {
						serverUrl: this._url,
						resourceMetadataUrl: this._resourceMetadataUrl,
						scope: this._scope,
						fetchFn: this._fetchWithInit
					});
					if (result !== "AUTHORIZED") {
						throw new UnauthorizedError();
					}
					return this.send(message);
				}
				throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
			}
			await response.body?.cancel();
		} catch (error$47) {
			this.onerror?.(error$47);
			throw error$47;
		}
	}
	setProtocolVersion(version$1) {
		this._protocolVersion = version$1;
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
	constructor({ onError, onRetry, onComment } = {}) {
		let parser;
		super({
			start(controller) {
				parser = createParser({
					onEvent: (event) => {
						controller.enqueue(event);
					},
					onError(error$47) {
						onError === "terminate" ? controller.error(error$47) : typeof onError == "function" && onError(error$47);
					},
					onRetry,
					onComment
				});
			},
			transform(chunk) {
				parser.feed(chunk);
			}
		});
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
const DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
	initialReconnectionDelay: 1e3,
	maxReconnectionDelay: 3e4,
	reconnectionDelayGrowFactor: 1.5,
	maxRetries: 2
};
var StreamableHTTPError = class extends Error {
	constructor(code, message) {
		super(`Streamable HTTP error: ${message}`);
		this.code = code;
	}
};
/**
* Client transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.
* It will connect to a server using HTTP POST for sending messages and HTTP GET with Server-Sent Events
* for receiving messages.
*/
var StreamableHTTPClientTransport = class {
	constructor(url$2, opts) {
		this._hasCompletedAuthFlow = false;
		this._url = url$2;
		this._resourceMetadataUrl = undefined;
		this._scope = undefined;
		this._requestInit = opts?.requestInit;
		this._authProvider = opts?.authProvider;
		this._fetch = opts?.fetch;
		this._fetchWithInit = createFetchWithInit(opts?.fetch, opts?.requestInit);
		this._sessionId = opts?.sessionId;
		this._reconnectionOptions = opts?.reconnectionOptions ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
	}
	async _authThenStart() {
		if (!this._authProvider) {
			throw new UnauthorizedError("No auth provider");
		}
		let result;
		try {
			result = await auth(this._authProvider, {
				serverUrl: this._url,
				resourceMetadataUrl: this._resourceMetadataUrl,
				scope: this._scope,
				fetchFn: this._fetchWithInit
			});
		} catch (error$47) {
			this.onerror?.(error$47);
			throw error$47;
		}
		if (result !== "AUTHORIZED") {
			throw new UnauthorizedError();
		}
		return await this._startOrAuthSse({ resumptionToken: undefined });
	}
	async _commonHeaders() {
		const headers = {};
		if (this._authProvider) {
			const tokens = await this._authProvider.tokens();
			if (tokens) {
				headers["Authorization"] = `Bearer ${tokens.access_token}`;
			}
		}
		if (this._sessionId) {
			headers["mcp-session-id"] = this._sessionId;
		}
		if (this._protocolVersion) {
			headers["mcp-protocol-version"] = this._protocolVersion;
		}
		const extraHeaders = normalizeHeaders(this._requestInit?.headers);
		return new Headers({
			...headers,
			...extraHeaders
		});
	}
	async _startOrAuthSse(options) {
		const { resumptionToken } = options;
		try {
			const headers = await this._commonHeaders();
			headers.set("Accept", "text/event-stream");
			if (resumptionToken) {
				headers.set("last-event-id", resumptionToken);
			}
			const response = await (this._fetch ?? fetch)(this._url, {
				method: "GET",
				headers,
				signal: this._abortController?.signal
			});
			if (!response.ok) {
				await response.body?.cancel();
				if (response.status === 401 && this._authProvider) {
					return await this._authThenStart();
				}
				if (response.status === 405) {
					return;
				}
				throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
			}
			this._handleSseStream(response.body, options, true);
		} catch (error$47) {
			this.onerror?.(error$47);
			throw error$47;
		}
	}
	/**
	* Calculates the next reconnection delay using  backoff algorithm
	*
	* @param attempt Current reconnection attempt count for the specific stream
	* @returns Time to wait in milliseconds before next reconnection attempt
	*/
	_getNextReconnectionDelay(attempt) {
		if (this._serverRetryMs !== undefined) {
			return this._serverRetryMs;
		}
		const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
		const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
		const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
		return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
	}
	/**
	* Schedule a reconnection attempt using server-provided retry interval or backoff
	*
	* @param lastEventId The ID of the last received event for resumability
	* @param attemptCount Current reconnection attempt count for this specific stream
	*/
	_scheduleReconnection(options, attemptCount = 0) {
		const maxRetries = this._reconnectionOptions.maxRetries;
		if (attemptCount >= maxRetries) {
			this.onerror?.(new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
			return;
		}
		const delay$1 = this._getNextReconnectionDelay(attemptCount);
		this._reconnectionTimeout = setTimeout(() => {
			this._startOrAuthSse(options).catch((error$47) => {
				this.onerror?.(new Error(`Failed to reconnect SSE stream: ${error$47 instanceof Error ? error$47.message : String(error$47)}`));
				this._scheduleReconnection(options, attemptCount + 1);
			});
		}, delay$1);
	}
	_handleSseStream(stream$1, options, isReconnectable) {
		if (!stream$1) {
			return;
		}
		const { onresumptiontoken, replayMessageId } = options;
		let lastEventId;
		let hasPrimingEvent = false;
		let receivedResponse = false;
		const processStream = async () => {
			try {
				const reader = stream$1.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream({ onRetry: (retryMs) => {
					this._serverRetryMs = retryMs;
				} })).getReader();
				while (true) {
					const { value: event, done } = await reader.read();
					if (done) {
						break;
					}
					if (event.id) {
						lastEventId = event.id;
						hasPrimingEvent = true;
						onresumptiontoken?.(event.id);
					}
					if (!event.data) {
						continue;
					}
					if (!event.event || event.event === "message") {
						try {
							const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));
							if (isJSONRPCResultResponse(message)) {
								receivedResponse = true;
								if (replayMessageId !== undefined) {
									message.id = replayMessageId;
								}
							}
							this.onmessage?.(message);
						} catch (error$47) {
							this.onerror?.(error$47);
						}
					}
				}
				const canResume = isReconnectable || hasPrimingEvent;
				const needsReconnect = canResume && !receivedResponse;
				if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
					this._scheduleReconnection({
						resumptionToken: lastEventId,
						onresumptiontoken,
						replayMessageId
					}, 0);
				}
			} catch (error$47) {
				this.onerror?.(new Error(`SSE stream disconnected: ${error$47}`));
				const canResume = isReconnectable || hasPrimingEvent;
				const needsReconnect = canResume && !receivedResponse;
				if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
					try {
						this._scheduleReconnection({
							resumptionToken: lastEventId,
							onresumptiontoken,
							replayMessageId
						}, 0);
					} catch (error$48) {
						this.onerror?.(new Error(`Failed to reconnect: ${error$48 instanceof Error ? error$48.message : String(error$48)}`));
					}
				}
			}
		};
		processStream();
	}
	async start() {
		if (this._abortController) {
			throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
		}
		this._abortController = new AbortController();
	}
	/**
	* Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
	*/
	async finishAuth(authorizationCode) {
		if (!this._authProvider) {
			throw new UnauthorizedError("No auth provider");
		}
		const result = await auth(this._authProvider, {
			serverUrl: this._url,
			authorizationCode,
			resourceMetadataUrl: this._resourceMetadataUrl,
			scope: this._scope,
			fetchFn: this._fetchWithInit
		});
		if (result !== "AUTHORIZED") {
			throw new UnauthorizedError("Failed to authorize");
		}
	}
	async close() {
		if (this._reconnectionTimeout) {
			clearTimeout(this._reconnectionTimeout);
			this._reconnectionTimeout = undefined;
		}
		this._abortController?.abort();
		this.onclose?.();
	}
	async send(message, options) {
		try {
			const { resumptionToken, onresumptiontoken } = options || {};
			if (resumptionToken) {
				this._startOrAuthSse({
					resumptionToken,
					replayMessageId: isJSONRPCRequest(message) ? message.id : undefined
				}).catch((err) => this.onerror?.(err));
				return;
			}
			const headers = await this._commonHeaders();
			headers.set("content-type", "application/json");
			headers.set("accept", "application/json, text/event-stream");
			const init = {
				...this._requestInit,
				method: "POST",
				headers,
				body: JSON.stringify(message),
				signal: this._abortController?.signal
			};
			const response = await (this._fetch ?? fetch)(this._url, init);
			const sessionId = response.headers.get("mcp-session-id");
			if (sessionId) {
				this._sessionId = sessionId;
			}
			if (!response.ok) {
				const text = await response.text().catch(() => null);
				if (response.status === 401 && this._authProvider) {
					if (this._hasCompletedAuthFlow) {
						throw new StreamableHTTPError(401, "Server returned 401 after successful authentication");
					}
					const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
					this._resourceMetadataUrl = resourceMetadataUrl;
					this._scope = scope;
					const result = await auth(this._authProvider, {
						serverUrl: this._url,
						resourceMetadataUrl: this._resourceMetadataUrl,
						scope: this._scope,
						fetchFn: this._fetchWithInit
					});
					if (result !== "AUTHORIZED") {
						throw new UnauthorizedError();
					}
					this._hasCompletedAuthFlow = true;
					return this.send(message);
				}
				if (response.status === 403 && this._authProvider) {
					const { resourceMetadataUrl, scope, error: error$47 } = extractWWWAuthenticateParams(response);
					if (error$47 === "insufficient_scope") {
						const wwwAuthHeader = response.headers.get("WWW-Authenticate");
						if (this._lastUpscopingHeader === wwwAuthHeader) {
							throw new StreamableHTTPError(403, "Server returned 403 after trying upscoping");
						}
						if (scope) {
							this._scope = scope;
						}
						if (resourceMetadataUrl) {
							this._resourceMetadataUrl = resourceMetadataUrl;
						}
						this._lastUpscopingHeader = wwwAuthHeader ?? undefined;
						const result = await auth(this._authProvider, {
							serverUrl: this._url,
							resourceMetadataUrl: this._resourceMetadataUrl,
							scope: this._scope,
							fetchFn: this._fetch
						});
						if (result !== "AUTHORIZED") {
							throw new UnauthorizedError();
						}
						return this.send(message);
					}
				}
				throw new StreamableHTTPError(response.status, `Error POSTing to endpoint: ${text}`);
			}
			this._hasCompletedAuthFlow = false;
			this._lastUpscopingHeader = undefined;
			if (response.status === 202) {
				await response.body?.cancel();
				if (isInitializedNotification(message)) {
					this._startOrAuthSse({ resumptionToken: undefined }).catch((err) => this.onerror?.(err));
				}
				return;
			}
			const messages = Array.isArray(message) ? message : [message];
			const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== undefined).length > 0;
			const contentType = response.headers.get("content-type");
			if (hasRequests) {
				if (contentType?.includes("text/event-stream")) {
					this._handleSseStream(response.body, { onresumptiontoken }, false);
				} else if (contentType?.includes("application/json")) {
					const data = await response.json();
					const responseMessages = Array.isArray(data) ? data.map((msg) => JSONRPCMessageSchema.parse(msg)) : [JSONRPCMessageSchema.parse(data)];
					for (const msg of responseMessages) {
						this.onmessage?.(msg);
					}
				} else {
					await response.body?.cancel();
					throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
				}
			} else {
				await response.body?.cancel();
			}
		} catch (error$47) {
			this.onerror?.(error$47);
			throw error$47;
		}
	}
	get sessionId() {
		return this._sessionId;
	}
	/**
	* Terminates the current session by sending a DELETE request to the server.
	*
	* Clients that no longer need a particular session
	* (e.g., because the user is leaving the client application) SHOULD send an
	* HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
	* terminate the session.
	*
	* The server MAY respond with HTTP 405 Method Not Allowed, indicating that
	* the server does not allow clients to terminate sessions.
	*/
	async terminateSession() {
		if (!this._sessionId) {
			return;
		}
		try {
			const headers = await this._commonHeaders();
			const init = {
				...this._requestInit,
				method: "DELETE",
				headers,
				signal: this._abortController?.signal
			};
			const response = await (this._fetch ?? fetch)(this._url, init);
			await response.body?.cancel();
			if (!response.ok && response.status !== 405) {
				throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
			}
			this._sessionId = undefined;
		} catch (error$47) {
			this.onerror?.(error$47);
			throw error$47;
		}
	}
	setProtocolVersion(version$1) {
		this._protocolVersion = version$1;
	}
	get protocolVersion() {
		return this._protocolVersion;
	}
	/**
	* Resume an SSE stream from a previous event ID.
	* Opens a GET SSE connection with Last-Event-ID header to replay missed events.
	*
	* @param lastEventId The event ID to resume from
	* @param options Optional callback to receive new resumption tokens
	*/
	async resumeStream(lastEventId, options) {
		await this._startOrAuthSse({
			resumptionToken: lastEventId,
			onresumptiontoken: options?.onresumptiontoken
		});
	}
};

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/fs-json.js
async function readJsonFile(filePath) {
	try {
		const content = await node_fs_promises.default.readFile(filePath, "utf8");
		return JSON.parse(content);
	} catch (error$47) {
		if (error$47.code === "ENOENT") {
			return undefined;
		}
		throw error$47;
	}
}
async function writeJsonFile(filePath, data) {
	await node_fs_promises.default.mkdir(node_path.default.dirname(filePath), { recursive: true });
	await node_fs_promises.default.writeFile(filePath, JSON.stringify(data, null, 2), "utf8");
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/oauth-vault.js
const VAULT_PATH = node_path.default.join(node_os.default.homedir(), ".mcporter", "credentials.json");
async function readVault() {
	let shouldRewrite = false;
	try {
		const existing = await readJsonFile(VAULT_PATH);
		if (existing && existing.version === 1 && existing.entries && typeof existing.entries === "object") {
			return existing;
		}
		shouldRewrite = true;
	} catch {
		shouldRewrite = true;
	}
	const empty = {
		version: 1,
		entries: {}
	};
	if (shouldRewrite) {
		await writeVault(empty);
	}
	return empty;
}
async function writeVault(contents) {
	const dir = node_path.default.dirname(VAULT_PATH);
	await node_fs_promises.default.mkdir(dir, { recursive: true });
	await writeJsonFile(VAULT_PATH, contents);
}
function vaultKeyForDefinition(definition) {
	const descriptor = {
		name: definition.name,
		url: definition.command.kind === "http" ? definition.command.url.toString() : null,
		command: definition.command.kind === "stdio" ? {
			command: definition.command.command,
			args: definition.command.args ?? []
		} : null
	};
	const hash$2 = node_crypto.default.createHash("sha256").update(JSON.stringify(descriptor)).digest("hex").slice(0, 16);
	return `${definition.name}|${hash$2}`;
}
async function loadVaultEntry(definition) {
	const vault = await readVault();
	return vault.entries[vaultKeyForDefinition(definition)];
}
async function saveVaultEntry(definition, patch) {
	const vault = await readVault();
	const key = vaultKeyForDefinition(definition);
	const current = vault.entries[key] ?? {
		serverName: definition.name,
		serverUrl: definition.command.kind === "http" ? definition.command.url.toString() : undefined,
		updatedAt: new Date().toISOString()
	};
	vault.entries[key] = {
		...current,
		...patch,
		updatedAt: new Date().toISOString()
	};
	await writeVault(vault);
}
async function clearVaultEntry(definition, scope) {
	const vault = await readVault();
	const key = vaultKeyForDefinition(definition);
	const existing = vault.entries[key];
	if (!existing) {
		return;
	}
	if (scope === "all") {
		delete vault.entries[key];
	} else {
		const updated = { ...existing };
		if (scope === "tokens") {
			delete updated.tokens;
		}
		if (scope === "client") {
			delete updated.clientInfo;
		}
		if (scope === "verifier") {
			delete updated.codeVerifier;
		}
		if (scope === "state") {
			delete updated.state;
		}
		updated.updatedAt = new Date().toISOString();
		vault.entries[key] = updated;
	}
	await writeVault(vault);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/oauth-persistence.js
var DirectoryPersistence = class {
	root;
	logger;
	tokenPath;
	clientInfoPath;
	codeVerifierPath;
	statePath;
	constructor(root, logger) {
		this.root = root;
		this.logger = logger;
		this.tokenPath = node_path.default.join(root, "tokens.json");
		this.clientInfoPath = node_path.default.join(root, "client.json");
		this.codeVerifierPath = node_path.default.join(root, "code_verifier.txt");
		this.statePath = node_path.default.join(root, "state.txt");
	}
	describe() {
		return this.root;
	}
	async ensureDir() {
		await node_fs_promises.default.mkdir(this.root, { recursive: true });
	}
	async readTokens() {
		return readJsonFile(this.tokenPath);
	}
	async saveTokens(tokens) {
		await this.ensureDir();
		await writeJsonFile(this.tokenPath, tokens);
		this.logger?.debug?.(`Saved tokens to ${this.tokenPath}`);
	}
	async readClientInfo() {
		return readJsonFile(this.clientInfoPath);
	}
	async saveClientInfo(info) {
		await this.ensureDir();
		await writeJsonFile(this.clientInfoPath, info);
	}
	async readCodeVerifier() {
		try {
			return (await node_fs_promises.default.readFile(this.codeVerifierPath, "utf8")).trim();
		} catch (error$47) {
			if (error$47.code === "ENOENT") {
				return undefined;
			}
			throw error$47;
		}
	}
	async saveCodeVerifier(value) {
		await this.ensureDir();
		await node_fs_promises.default.writeFile(this.codeVerifierPath, value, "utf8");
	}
	async readState() {
		return readJsonFile(this.statePath);
	}
	async saveState(value) {
		await this.ensureDir();
		await writeJsonFile(this.statePath, value);
	}
	async clear(scope) {
		const files = [];
		if (scope === "all" || scope === "tokens") {
			files.push(this.tokenPath);
		}
		if (scope === "all" || scope === "client") {
			files.push(this.clientInfoPath);
		}
		if (scope === "all" || scope === "verifier") {
			files.push(this.codeVerifierPath);
		}
		if (scope === "all" || scope === "state") {
			files.push(this.statePath);
		}
		await Promise.all(files.map(async (file$2) => {
			try {
				await node_fs_promises.default.unlink(file$2);
			} catch (error$47) {
				if (error$47.code !== "ENOENT") {
					throw error$47;
				}
			}
		}));
	}
};
var VaultPersistence = class {
	definition;
	constructor(definition) {
		this.definition = definition;
	}
	describe() {
		return "~/.mcporter/credentials.json (vault)";
	}
	async readTokens() {
		return (await loadVaultEntry(this.definition))?.tokens;
	}
	async saveTokens(tokens) {
		await saveVaultEntry(this.definition, { tokens });
	}
	async readClientInfo() {
		return (await loadVaultEntry(this.definition))?.clientInfo;
	}
	async saveClientInfo(info) {
		await saveVaultEntry(this.definition, { clientInfo: info });
	}
	async readCodeVerifier() {
		return (await loadVaultEntry(this.definition))?.codeVerifier;
	}
	async saveCodeVerifier(value) {
		await saveVaultEntry(this.definition, { codeVerifier: value });
	}
	async readState() {
		return (await loadVaultEntry(this.definition))?.state;
	}
	async saveState(value) {
		await saveVaultEntry(this.definition, { state: value });
	}
	async clear(scope) {
		await clearVaultEntry(this.definition, scope);
	}
};
var CompositePersistence = class {
	stores;
	constructor(stores) {
		this.stores = stores;
	}
	describe() {
		return this.stores.map((store) => store.describe()).join(" + ");
	}
	async readTokens() {
		for (const store of this.stores) {
			const result = await store.readTokens();
			if (result) {
				return result;
			}
		}
		return undefined;
	}
	async saveTokens(tokens) {
		await Promise.all(this.stores.map((store) => store.saveTokens(tokens)));
	}
	async readClientInfo() {
		for (const store of this.stores) {
			const result = await store.readClientInfo();
			if (result) {
				return result;
			}
		}
		return undefined;
	}
	async saveClientInfo(info) {
		await Promise.all(this.stores.map((store) => store.saveClientInfo(info)));
	}
	async readCodeVerifier() {
		for (const store of this.stores) {
			const result = await store.readCodeVerifier();
			if (result) {
				return result;
			}
		}
		return undefined;
	}
	async saveCodeVerifier(value) {
		await Promise.all(this.stores.map((store) => store.saveCodeVerifier(value)));
	}
	async readState() {
		for (const store of this.stores) {
			const result = await store.readState();
			if (result) {
				return result;
			}
		}
		return undefined;
	}
	async saveState(value) {
		await Promise.all(this.stores.map((store) => store.saveState(value)));
	}
	async clear(scope) {
		await Promise.all(this.stores.map((store) => store.clear(scope)));
	}
};
async function buildOAuthPersistence(definition, logger) {
	const vault = new VaultPersistence(definition);
	const stores = [vault];
	if (definition.tokenCacheDir) {
		stores.unshift(new DirectoryPersistence(definition.tokenCacheDir, logger));
	}
	const legacyDir = node_path.default.join(node_os.default.homedir(), ".mcporter", definition.name);
	if (!definition.tokenCacheDir && legacyDir) {
		const legacy = new DirectoryPersistence(legacyDir, logger);
		const legacyTokens = await legacy.readTokens();
		const legacyClient = await legacy.readClientInfo();
		const legacyVerifier = await legacy.readCodeVerifier();
		const legacyState = await legacy.readState();
		if (legacyTokens || legacyClient || legacyVerifier || legacyState) {
			if (legacyTokens) {
				await vault.saveTokens(legacyTokens);
			}
			if (legacyClient) {
				await vault.saveClientInfo(legacyClient);
			}
			if (legacyVerifier) {
				await vault.saveCodeVerifier(legacyVerifier);
			}
			if (legacyState) {
				await vault.saveState(legacyState);
			}
			logger?.info?.(`Migrated legacy OAuth cache for '${definition.name}' into vault.`);
		}
	}
	return stores.length === 1 ? vault : new CompositePersistence(stores);
}
async function clearOAuthCaches(definition, logger, scope = "all") {
	const persistence = await buildOAuthPersistence(definition, logger);
	await persistence.clear(scope);
	const legacyDir = node_path.default.join(node_os.default.homedir(), ".mcporter", definition.name);
	if (legacyDir && (!definition.tokenCacheDir || legacyDir !== definition.tokenCacheDir)) {
		const legacy = new DirectoryPersistence(legacyDir, logger);
		await legacy.clear(scope);
	}
	if (definition.tokenCacheDir) {
		await node_fs_promises.default.rm(definition.tokenCacheDir, {
			recursive: true,
			force: true
		});
	}
	const legacyFiles = [];
	if (definition.name.toLowerCase() === "gmail") {
		legacyFiles.push(node_path.default.join(node_os.default.homedir(), ".gmail-mcp", "credentials.json"));
	}
	await Promise.all(legacyFiles.map(async (file$2) => {
		try {
			await node_fs_promises.default.unlink(file$2);
			logger?.info?.(`Cleared legacy OAuth cache file ${file$2}`);
		} catch (error$47) {
			if (error$47.code !== "ENOENT") {
				throw error$47;
			}
		}
	}));
}
async function readCachedAccessToken(definition, logger) {
	const persistence = await buildOAuthPersistence(definition, logger);
	const tokens = await persistence.readTokens();
	if (tokens && typeof tokens.access_token === "string" && tokens.access_token.trim().length > 0) {
		return tokens.access_token;
	}
	return undefined;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/oauth.js
const CALLBACK_HOST = "127.0.0.1";
const CALLBACK_PATH = "/callback";
function createDeferred() {
	let resolve;
	let reject;
	const promise$2 = new Promise((res, rej) => {
		resolve = res;
		reject = rej;
	});
	return {
		promise: promise$2,
		resolve,
		reject
	};
}
function openExternal(url$2) {
	const platform = process.platform;
	const stdio = "ignore";
	try {
		if (platform === "darwin") {
			const child = (0, node_child_process.spawn)("open", [url$2], {
				stdio,
				detached: true
			});
			child.unref();
		} else if (platform === "win32") {
			const child = (0, node_child_process.spawn)("cmd", [
				"/c",
				"start",
				"\"\"",
				url$2
			], {
				stdio,
				detached: true
			});
			child.unref();
		} else {
			const child = (0, node_child_process.spawn)("xdg-open", [url$2], {
				stdio,
				detached: true
			});
			child.unref();
		}
	} catch {}
}
var PersistentOAuthClientProvider = class PersistentOAuthClientProvider {
	definition;
	metadata;
	logger;
	persistence;
	redirectUrlValue;
	authorizationDeferred = null;
	server;
	constructor(definition, persistence, redirectUrl, logger) {
		this.definition = definition;
		this.redirectUrlValue = redirectUrl;
		this.logger = logger;
		this.persistence = persistence;
		this.metadata = {
			client_name: definition.clientName ?? `mcporter (${definition.name})`,
			redirect_uris: [this.redirectUrlValue.toString()],
			grant_types: ["authorization_code", "refresh_token"],
			response_types: ["code"],
			token_endpoint_auth_method: "none",
			scope: "mcp:tools"
		};
	}
	static async create(definition, logger) {
		const persistence = await buildOAuthPersistence(definition, logger);
		const server = node_http.default.createServer();
		const overrideRedirect = definition.oauthRedirectUrl ? new node_url.URL(definition.oauthRedirectUrl) : null;
		const listenHost = overrideRedirect?.hostname ?? CALLBACK_HOST;
		const overridePort = overrideRedirect?.port ?? "";
		const usesDynamicPort = !overrideRedirect || overridePort === "" || overridePort === "0";
		const desiredPort = usesDynamicPort ? undefined : Number.parseInt(overridePort, 10);
		const callbackPath = overrideRedirect?.pathname && overrideRedirect.pathname !== "/" ? overrideRedirect.pathname : CALLBACK_PATH;
		const port = await new Promise((resolve, reject) => {
			server.listen(desiredPort ?? 0, listenHost, () => {
				const address = server.address();
				if (typeof address === "object" && address && "port" in address) {
					resolve(address.port);
				} else {
					reject(new Error("Failed to determine callback port"));
				}
			});
			server.once("error", (error$47) => reject(error$47));
		});
		const redirectUrl = overrideRedirect ? new node_url.URL(overrideRedirect.toString()) : new node_url.URL(`http://${listenHost}:${port}${callbackPath}`);
		if (usesDynamicPort) {
			redirectUrl.port = String(port);
		}
		if (!overrideRedirect || overrideRedirect.pathname === "/" || overrideRedirect.pathname === "") {
			redirectUrl.pathname = callbackPath;
		}
		const provider = new PersistentOAuthClientProvider(definition, persistence, redirectUrl, logger);
		provider.attachServer(server);
		return {
			provider,
			close: async () => {
				await provider.close();
			}
		};
	}
	attachServer(server) {
		this.server = server;
		server.on("request", async (req, res) => {
			try {
				const url$2 = req.url ?? "";
				const parsed = new node_url.URL(url$2, this.redirectUrlValue);
				const expectedPath = this.redirectUrlValue.pathname || "/callback";
				if (parsed.pathname !== expectedPath) {
					res.statusCode = 404;
					res.end("Not found");
					return;
				}
				const code = parsed.searchParams.get("code");
				const error$47 = parsed.searchParams.get("error");
				const receivedState = parsed.searchParams.get("state");
				const expectedState = await this.persistence.readState();
				if (expectedState && receivedState && receivedState !== expectedState) {
					res.statusCode = 400;
					res.setHeader("Content-Type", "text/html");
					res.end("<html><body><h1>Authorization failed</h1><p>Invalid OAuth state</p></body></html>");
					this.authorizationDeferred?.reject(new Error("Invalid OAuth state"));
					this.authorizationDeferred = null;
					return;
				}
				if (code) {
					this.logger.info(`Received OAuth authorization code for ${this.definition.name}`);
					res.statusCode = 200;
					res.setHeader("Content-Type", "text/html");
					res.end("<html><body><h1>Authorization successful</h1><p>You can return to the CLI.</p></body></html>");
					this.authorizationDeferred?.resolve(code);
					this.authorizationDeferred = null;
				} else if (error$47) {
					res.statusCode = 400;
					res.setHeader("Content-Type", "text/html");
					res.end(`<html><body><h1>Authorization failed</h1><p>${error$47}</p></body></html>`);
					this.authorizationDeferred?.reject(new Error(`OAuth error: ${error$47}`));
					this.authorizationDeferred = null;
				} else {
					res.statusCode = 400;
					res.end("Missing authorization code");
					this.authorizationDeferred?.reject(new Error("Missing authorization code"));
					this.authorizationDeferred = null;
				}
			} catch (error$47) {
				this.authorizationDeferred?.reject(error$47);
				this.authorizationDeferred = null;
			}
		});
	}
	get redirectUrl() {
		return this.redirectUrlValue;
	}
	get clientMetadata() {
		return this.metadata;
	}
	async state() {
		const existing = await this.persistence.readState();
		if (existing) {
			return existing;
		}
		const state = (0, node_crypto.randomUUID)();
		await this.persistence.saveState(state);
		return state;
	}
	async clientInformation() {
		return this.persistence.readClientInfo();
	}
	async saveClientInformation(clientInformation) {
		await this.persistence.saveClientInfo(clientInformation);
	}
	async tokens() {
		return this.persistence.readTokens();
	}
	async saveTokens(tokens) {
		await this.persistence.saveTokens(tokens);
		this.logger.info(`Saved OAuth tokens for ${this.definition.name} (${this.persistence.describe()})`);
	}
	async redirectToAuthorization(authorizationUrl) {
		this.logger.info(`Authorization required for ${this.definition.name}. Opening browser...`);
		this.authorizationDeferred = createDeferred();
		openExternal(authorizationUrl.toString());
		this.logger.info(`If the browser did not open, visit ${authorizationUrl.toString()} manually.`);
	}
	async saveCodeVerifier(codeVerifier) {
		await this.persistence.saveCodeVerifier(codeVerifier);
	}
	async codeVerifier() {
		const value = await this.persistence.readCodeVerifier();
		if (!value) {
			throw new Error(`Missing PKCE code verifier for ${this.definition.name}`);
		}
		return value.trim();
	}
	async invalidateCredentials(scope) {
		await this.persistence.clear(scope);
	}
	async waitForAuthorizationCode() {
		if (!this.authorizationDeferred) {
			this.authorizationDeferred = createDeferred();
		}
		return this.authorizationDeferred.promise;
	}
	async close() {
		if (this.authorizationDeferred) {
			this.authorizationDeferred.reject(new Error("OAuth session closed before receiving authorization code."));
			this.authorizationDeferred = null;
		}
		if (!this.server) {
			return;
		}
		await new Promise((resolve) => {
			this.server?.close(() => resolve());
		});
		this.server = undefined;
	}
};
async function createOAuthSession(definition, logger) {
	const { provider, close } = await PersistentOAuthClientProvider.create(definition, logger);
	const waitForAuthorizationCode = () => provider.waitForAuthorizationCode();
	return {
		provider,
		waitForAuthorizationCode,
		close
	};
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime-header-utils.js
function materializeHeaders(headers, serverName) {
	if (!headers) {
		return undefined;
	}
	const resolved = {};
	for (const [key, value] of Object.entries(headers)) {
		try {
			resolved[key] = resolveEnvPlaceholders(value);
		} catch (error$47) {
			const message = error$47 instanceof Error ? error$47.message : String(error$47);
			throw new Error(`Failed to resolve header '${key}' for server '${serverName}': ${message}`);
		}
	}
	return resolved;
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime/utils.js
const ENV_PLACEHOLDER_PATTERN = /\$\{[A-Za-z_][A-Za-z0-9_]*\}/;
function resolveCommandArgument(value) {
	if (!value) {
		return value;
	}
	if (!value.includes("$")) {
		return value;
	}
	const needsInterpolation = value.startsWith("$env:") || ENV_PLACEHOLDER_PATTERN.test(value);
	if (!needsInterpolation) {
		return value;
	}
	return resolveEnvPlaceholders(value);
}
function resolveCommandArguments(args) {
	if (!args || args.length === 0) {
		return [];
	}
	return args.map((arg) => resolveCommandArgument(arg));
}
function normalizeTimeout(raw) {
	if (raw == null) {
		return undefined;
	}
	if (!Number.isFinite(raw)) {
		return undefined;
	}
	const coerced = Math.trunc(raw);
	return coerced > 0 ? coerced : undefined;
}
function raceWithTimeout(promise$2, timeoutMs) {
	return new Promise((resolve, reject) => {
		const timer = setTimeout(() => {
			reject(new Error("Timeout"));
		}, timeoutMs);
		promise$2.then((value) => {
			clearTimeout(timer);
			resolve(value);
		}, (error$47) => {
			clearTimeout(timer);
			reject(error$47);
		});
	});
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime/transport.js
const STDIO_TRACE_ENABLED = process.env.MCPORTER_STDIO_TRACE === "1";
function attachStdioTraceLogging(_transport, _label) {}
async function createClientContext(definition, logger, clientInfo, options = {}) {
	const client = new Client(clientInfo);
	let activeDefinition = definition;
	if (options.allowCachedAuth && activeDefinition.auth === "oauth" && activeDefinition.command.kind === "http") {
		try {
			const cached$1 = await readCachedAccessToken(activeDefinition, logger);
			if (cached$1) {
				const existingHeaders = activeDefinition.command.headers ?? {};
				if (!("Authorization" in existingHeaders)) {
					activeDefinition = {
						...activeDefinition,
						command: {
							...activeDefinition.command,
							headers: {
								...existingHeaders,
								Authorization: `Bearer ${cached$1}`
							}
						}
					};
					logger.debug?.(`Using cached OAuth access token for '${activeDefinition.name}' (non-interactive).`);
				}
			}
		} catch (error$47) {
			logger.debug?.(`Failed to read cached OAuth token for '${activeDefinition.name}': ${error$47 instanceof Error ? error$47.message : String(error$47)}`);
		}
	}
	return withEnvOverrides(activeDefinition.env, async () => {
		if (activeDefinition.command.kind === "stdio") {
			const resolvedEnvOverrides = activeDefinition.env && Object.keys(activeDefinition.env).length > 0 ? Object.fromEntries(Object.entries(activeDefinition.env).map(([key, raw]) => [key, resolveEnvValue(raw)]).filter(([, value]) => value !== "")) : undefined;
			const mergedEnv = resolvedEnvOverrides && Object.keys(resolvedEnvOverrides).length > 0 ? {
				...process.env,
				...resolvedEnvOverrides
			} : { ...process.env };
			const transport = new StdioClientTransport({
				command: resolveCommandArgument(activeDefinition.command.command),
				args: resolveCommandArguments(activeDefinition.command.args),
				cwd: activeDefinition.command.cwd,
				env: mergedEnv
			});
			if (STDIO_TRACE_ENABLED) {
				attachStdioTraceLogging(transport, activeDefinition.name ?? activeDefinition.command.command);
			}
			try {
				await client.connect(transport);
			} catch (error$47) {
				await closeTransportAndWait(logger, transport).catch(() => {});
				throw error$47;
			}
			return {
				client,
				transport,
				definition: activeDefinition,
				oauthSession: undefined
			};
		}
		while (true) {
			const command = activeDefinition.command;
			if (command.kind !== "http") {
				throw new Error(`Server '${activeDefinition.name}' is not configured for HTTP transport.`);
			}
			let oauthSession;
			const shouldEstablishOAuth = activeDefinition.auth === "oauth" && options.maxOAuthAttempts !== 0;
			if (shouldEstablishOAuth) {
				oauthSession = await createOAuthSession(activeDefinition, logger);
			}
			const resolvedHeaders = materializeHeaders(command.headers, activeDefinition.name);
			const requestInit = resolvedHeaders ? { headers: resolvedHeaders } : undefined;
			const baseOptions = {
				requestInit,
				authProvider: oauthSession?.provider
			};
			const attemptConnect = async () => {
				const streamableTransport = new StreamableHTTPClientTransport(command.url, baseOptions);
				try {
					await connectWithAuth(client, streamableTransport, oauthSession, logger, {
						serverName: activeDefinition.name,
						maxAttempts: options.maxOAuthAttempts,
						oauthTimeoutMs: options.oauthTimeoutMs
					});
					return {
						client,
						transport: streamableTransport,
						definition: activeDefinition,
						oauthSession
					};
				} catch (error$47) {
					await closeTransportAndWait(logger, streamableTransport).catch(() => {});
					throw error$47;
				}
			};
			try {
				return await attemptConnect();
			} catch (primaryError) {
				if (isUnauthorizedError(primaryError)) {
					await oauthSession?.close().catch(() => {});
					oauthSession = undefined;
					if (options.maxOAuthAttempts !== 0) {
						const promoted = maybeEnableOAuth(activeDefinition, logger);
						if (promoted) {
							activeDefinition = promoted;
							options.onDefinitionPromoted?.(promoted);
							continue;
						}
					}
				}
				if (primaryError instanceof OAuthTimeoutError) {
					await oauthSession?.close().catch(() => {});
					throw primaryError;
				}
				if (primaryError instanceof Error) {
					logger.info(`Falling back to SSE transport for '${activeDefinition.name}': ${primaryError.message}`);
				}
				const sseTransport = new SSEClientTransport(command.url, { ...baseOptions });
				try {
					await connectWithAuth(client, sseTransport, oauthSession, logger, {
						serverName: activeDefinition.name,
						maxAttempts: options.maxOAuthAttempts,
						oauthTimeoutMs: options.oauthTimeoutMs
					});
					return {
						client,
						transport: sseTransport,
						definition: activeDefinition,
						oauthSession
					};
				} catch (sseError) {
					await closeTransportAndWait(logger, sseTransport).catch(() => {});
					await oauthSession?.close().catch(() => {});
					if (sseError instanceof OAuthTimeoutError) {
						throw sseError;
					}
					if (isUnauthorizedError(sseError) && options.maxOAuthAttempts !== 0) {
						const promoted = maybeEnableOAuth(activeDefinition, logger);
						if (promoted) {
							activeDefinition = promoted;
							options.onDefinitionPromoted?.(promoted);
							continue;
						}
					}
					throw sseError;
				}
			}
		}
	});
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/runtime.js
const PACKAGE_NAME = "mcporter";
const CLIENT_VERSION = (() => {
	try {
		return (0, node_module.createRequire)(require("url").pathToFileURL(__filename).href)("../package.json").version;
	} catch {
		return process.env.MCPORTER_VERSION ?? "0.0.0-dev";
	}
})();
const MCPORTER_VERSION = CLIENT_VERSION;
const OAUTH_CODE_TIMEOUT_MS = resolveOAuthTimeoutFromEnv();
async function createRuntime(options = {}) {
	const servers = options.servers ?? await loadServerDefinitions({
		configPath: options.configPath,
		rootDir: options.rootDir
	});
	const runtime = new McpRuntime(servers, options);
	return runtime;
}
async function callOnce(params) {
	const runtime = await createRuntime({ configPath: params.configPath });
	try {
		return await runtime.callTool(params.server, params.toolName, { args: params.args });
	} finally {
		await runtime.close(params.server);
	}
}
var McpRuntime = class {
	definitions;
	clients = new Map();
	logger;
	clientInfo;
	oauthTimeoutMs;
	constructor(servers, options = {}) {
		this.definitions = new Map(servers.map((entry) => [entry.name, entry]));
		this.logger = options.logger ?? createConsoleLogger();
		this.clientInfo = options.clientInfo ?? {
			name: PACKAGE_NAME,
			version: CLIENT_VERSION
		};
		this.oauthTimeoutMs = options.oauthTimeoutMs;
	}
	listServers() {
		return [...this.definitions.keys()].sort((a, b) => a.localeCompare(b));
	}
	getDefinitions() {
		return [...this.definitions.values()];
	}
	getDefinition(server) {
		const definition = this.definitions.get(server);
		if (!definition) {
			throw new Error(`Unknown MCP server '${server}'.`);
		}
		return definition;
	}
	registerDefinition(definition, options = {}) {
		if (!options.overwrite && this.definitions.has(definition.name)) {
			throw new Error(`MCP server '${definition.name}' already exists.`);
		}
		this.definitions.set(definition.name, definition);
		this.clients.delete(definition.name);
	}
	async listTools(server, options = {}) {
		const autoAuthorize = options.autoAuthorize !== false;
		const context = await this.connect(server, {
			maxOAuthAttempts: autoAuthorize ? undefined : 0,
			skipCache: !autoAuthorize,
			allowCachedAuth: options.allowCachedAuth
		});
		try {
			const tools = [];
			let cursor;
			do {
				const response = await context.client.listTools(cursor ? { cursor } : undefined);
				tools.push(...(response.tools ?? []).map((tool) => ({
					name: tool.name,
					description: tool.description ?? undefined,
					inputSchema: options.includeSchema ? tool.inputSchema : undefined,
					outputSchema: options.includeSchema ? tool.outputSchema : undefined
				})));
				cursor = response.nextCursor ?? undefined;
			} while (cursor);
			return tools;
		} catch (error$47) {
			await this.resetConnectionOnError(server, error$47);
			throw error$47;
		} finally {
			if (!autoAuthorize) {
				await context.client.close().catch(() => {});
				await closeTransportAndWait(this.logger, context.transport).catch(() => {});
				await context.oauthSession?.close().catch(() => {});
			}
		}
	}
	async callTool(server, toolName, options = {}) {
		try {
			const { client } = await this.connect(server);
			const params = {
				name: toolName,
				arguments: options.args ?? {}
			};
			const timeoutMs = normalizeTimeout(options.timeoutMs);
			const resultPromise = client.callTool(params, undefined, {
				timeout: timeoutMs,
				resetTimeoutOnProgress: true,
				maxTotalTimeout: timeoutMs
			});
			if (!timeoutMs) {
				return await resultPromise;
			}
			return await raceWithTimeout(resultPromise, timeoutMs);
		} catch (error$47) {
			await this.resetConnectionOnError(server, error$47);
			throw error$47;
		}
	}
	async listResources(server, options = {}) {
		try {
			const { client } = await this.connect(server);
			return await client.listResources(options);
		} catch (error$47) {
			await this.resetConnectionOnError(server, error$47);
			throw error$47;
		}
	}
	async connect(server, options = {}) {
		const normalized = server.trim();
		const useCache = options.skipCache !== true && options.maxOAuthAttempts === undefined;
		if (useCache) {
			const existing = this.clients.get(normalized);
			if (existing) {
				return existing;
			}
		}
		const definition = this.definitions.get(normalized);
		if (!definition) {
			throw new Error(`Unknown MCP server '${normalized}'.`);
		}
		const connection = createClientContext(definition, this.logger, this.clientInfo, {
			maxOAuthAttempts: options.maxOAuthAttempts,
			oauthTimeoutMs: this.oauthTimeoutMs ?? OAUTH_CODE_TIMEOUT_MS,
			onDefinitionPromoted: (promoted) => this.definitions.set(promoted.name, promoted),
			allowCachedAuth: options.allowCachedAuth
		});
		if (useCache) {
			this.clients.set(normalized, connection);
			try {
				return await connection;
			} catch (error$47) {
				this.clients.delete(normalized);
				throw error$47;
			}
		}
		return connection;
	}
	async close(server) {
		if (server) {
			const normalized = server.trim();
			const context = await this.clients.get(normalized);
			if (!context) {
				return;
			}
			await context.client.close().catch(() => {});
			await closeTransportAndWait(this.logger, context.transport).catch(() => {});
			await context.oauthSession?.close().catch(() => {});
			this.clients.delete(normalized);
			return;
		}
		for (const [name, promise$2] of this.clients.entries()) {
			try {
				const context = await promise$2;
				await context.client.close().catch(() => {});
				await closeTransportAndWait(this.logger, context.transport).catch(() => {});
				await context.oauthSession?.close().catch(() => {});
			} finally {
				this.clients.delete(name);
			}
		}
	}
	async resetConnectionOnError(server, error$47) {
		if (!shouldResetConnection(error$47)) {
			return;
		}
		const normalized = server.trim();
		if (!this.clients.has(normalized)) {
			return;
		}
		try {
			await this.close(normalized);
		} catch (closeError) {
			const detail = closeError instanceof Error ? closeError.message : String(closeError);
			this.logger.warn(`Failed to reset '${normalized}' after error: ${detail}`);
		}
	}
};
function createConsoleLogger(level = resolveLogLevelFromEnv()) {
	return createPrefixedConsoleLogger("mcporter", level);
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/schema-cache.js
const SCHEMA_FILENAME = "schema.json";
function resolveSchemaCacheDir(definition) {
	return definition.tokenCacheDir ?? node_path.default.join(node_os.default.homedir(), ".mcporter", definition.name);
}
function resolveSchemaCachePath(definition) {
	return node_path.default.join(resolveSchemaCacheDir(definition), SCHEMA_FILENAME);
}
async function readSchemaCache(definition) {
	const filePath = resolveSchemaCachePath(definition);
	try {
		const raw = await node_fs_promises.default.readFile(filePath, "utf8");
		const parsed = JSON.parse(raw);
		if (!parsed || typeof parsed !== "object") {
			return undefined;
		}
		if (!parsed.tools || typeof parsed.tools !== "object") {
			return undefined;
		}
		return parsed;
	} catch (error$47) {
		if (error$47.code === "ENOENT") {
			return undefined;
		}
		throw error$47;
	}
}
async function writeSchemaCache(definition, snapshot) {
	const filePath = resolveSchemaCachePath(definition);
	await node_fs_promises.default.mkdir(node_path.default.dirname(filePath), { recursive: true });
	await node_fs_promises.default.writeFile(filePath, JSON.stringify(snapshot, null, 2), "utf8");
}

//#endregion
//#region ../.npm/_npx/c7f8321b6c938c94/node_modules/mcporter/dist/server-proxy.js
const KNOWN_OPTION_KEYS = new Set([
	"tailLog",
	"timeout",
	"stream",
	"streamLog",
	"mimeType",
	"metadata",
	"log"
]);
function defaultToolNameMapper(propertyKey) {
	if (typeof propertyKey !== "string") {
		throw new TypeError("Tool name must be a string when using server proxy.");
	}
	return propertyKey.replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
}
function canonicalizeToolName(name) {
	return name.toLowerCase().replace(/[^a-z0-9]/g, "");
}
function isPlainObject(value) {
	return typeof value === "object" && value !== null && !Array.isArray(value);
}
function createToolSchemaInfo(schemaRaw) {
	if (!schemaRaw || typeof schemaRaw !== "object") {
		return undefined;
	}
	const schema = schemaRaw;
	const propertiesRaw = schema.properties;
	const propertyKeys = propertiesRaw && typeof propertiesRaw === "object" ? Object.keys(propertiesRaw) : [];
	const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
	const orderedKeys = [];
	const seen = new Set();
	for (const key of requiredKeys) {
		if (typeof key === "string" && !seen.has(key)) {
			orderedKeys.push(key);
			seen.add(key);
		}
	}
	for (const key of propertyKeys) {
		if (!seen.has(key)) {
			orderedKeys.push(key);
			seen.add(key);
		}
	}
	return {
		schema,
		orderedKeys,
		requiredKeys,
		propertySet: new Set([...propertyKeys, ...requiredKeys])
	};
}
function applyDefaults(meta$3, args) {
	const propertiesRaw = meta$3.schema.properties;
	if (!propertiesRaw || typeof propertiesRaw !== "object") {
		return args;
	}
	const result = isPlainObject(args) ? { ...args } : {};
	for (const [key, value] of Object.entries(propertiesRaw)) {
		if (value && typeof value === "object" && "default" in value && result[key] === undefined) {
			result[key] = value.default;
		}
	}
	if (Object.keys(result).length === 0 && !isPlainObject(args)) {
		return args;
	}
	return result;
}
function validateRequired(meta$3, args) {
	if (meta$3.requiredKeys.length === 0) {
		return;
	}
	if (!isPlainObject(args)) {
		throw new Error(`Missing required arguments: ${meta$3.requiredKeys.join(", ")}`);
	}
	const missing = meta$3.requiredKeys.filter((key) => args[key] === undefined);
	if (missing.length > 0) {
		throw new Error(`Missing required arguments: ${missing.join(", ")}`);
	}
}
function createServerProxy(runtime, serverName, mapOrOptions, maybeOptions) {
	let mapPropertyToTool = defaultToolNameMapper;
	let options;
	if (typeof mapOrOptions === "function") {
		mapPropertyToTool = mapOrOptions;
		options = maybeOptions;
	} else if (mapOrOptions) {
		options = mapOrOptions;
		if (typeof mapOrOptions.mapPropertyToTool === "function") {
			mapPropertyToTool = mapOrOptions.mapPropertyToTool;
		}
	}
	const cacheSchemas = options?.cacheSchemas ?? true;
	const initialSchemas = options?.initialSchemas ?? undefined;
	const toolSchemaCache = new Map();
	const persistedSchemas = new Map();
	const toolAliasMap = new Map();
	let schemaFetch = null;
	let diskLoad = null;
	let persistPromise = null;
	let refreshPending = false;
	let definitionForCache;
	if (cacheSchemas) {
		try {
			definitionForCache = runtime.getDefinition(serverName);
		} catch {
			definitionForCache = undefined;
		}
	}
	if (cacheSchemas && !initialSchemas && definitionForCache) {
		diskLoad = loadSchemasFromDisk(definitionForCache);
		refreshPending = true;
	}
	if (initialSchemas) {
		for (const [key, schemaRaw] of Object.entries(initialSchemas)) {
			storeSchema(key, schemaRaw);
		}
		persistPromise = persistSchemas();
	}
	async function consumePersist() {
		if (!persistPromise) {
			return;
		}
		try {
			await persistPromise;
		} finally {
			persistPromise = null;
		}
	}
	async function ensureMetadata(toolName) {
		await consumePersist();
		const cached$1 = toolSchemaCache.get(toolName);
		if (cached$1 && !refreshPending) {
			return cached$1;
		}
		if (diskLoad) {
			try {
				await diskLoad;
			} finally {
				diskLoad = null;
			}
			if (toolSchemaCache.has(toolName) && !refreshPending) {
				return toolSchemaCache.get(toolName);
			}
		}
		if (!schemaFetch) {
			schemaFetch = runtime.listTools(serverName, { includeSchema: true }).then((tools) => {
				for (const tool of tools) {
					if (!tool.inputSchema || typeof tool.inputSchema !== "object") {
						continue;
					}
					storeSchema(tool.name, tool.inputSchema);
				}
				persistPromise = persistSchemas();
				refreshPending = false;
			}).catch((error$47) => {
				schemaFetch = null;
				throw error$47;
			});
		}
		await schemaFetch;
		await consumePersist();
		return toolSchemaCache.get(toolName);
	}
	function storeSchema(key, schemaRaw) {
		const info = createToolSchemaInfo(schemaRaw);
		if (!info) {
			return;
		}
		const canonical = mapPropertyToTool(key);
		toolSchemaCache.set(canonical, info);
		if (canonical !== key) {
			toolSchemaCache.set(key, info);
		}
		const canonicalAlias = canonicalizeToolName(key);
		if (!toolAliasMap.has(canonicalAlias)) {
			toolAliasMap.set(canonicalAlias, key);
		}
		const mapperAlias = canonicalizeToolName(canonical);
		if (!toolAliasMap.has(mapperAlias)) {
			toolAliasMap.set(mapperAlias, key);
		}
		if (cacheSchemas && definitionForCache && isPlainObject(schemaRaw)) {
			persistedSchemas.set(canonical, schemaRaw);
		}
	}
	async function loadSchemasFromDisk(definition) {
		try {
			const snapshot = await readSchemaCache(definition);
			if (!snapshot) {
				return;
			}
			for (const [key, schemaRaw] of Object.entries(snapshot.tools)) {
				storeSchema(key, schemaRaw);
			}
		} catch {}
	}
	function persistSchemas() {
		if (!cacheSchemas || !definitionForCache || persistedSchemas.size === 0) {
			return null;
		}
		const definition = definitionForCache;
		const snapshot = {
			updatedAt: new Date().toISOString(),
			tools: Object.fromEntries(persistedSchemas.entries())
		};
		return writeSchemaCache(definition, snapshot).catch(() => {});
	}
	const base = {
		call: async (toolName, options$1) => {
			const result = await runtime.callTool(serverName, toolName, options$1 ?? {});
			return createCallResult(result);
		},
		listTools: (options$1) => runtime.listTools(serverName, options$1)
	};
	return new Proxy(base, { get(target, property, receiver) {
		if (Reflect.has(target, property)) {
			return Reflect.get(target, property, receiver);
		}
		const propertyKey = property;
		const canonicalKey = typeof propertyKey === "string" ? canonicalizeToolName(propertyKey) : null;
		let resolvedToolName = typeof propertyKey === "string" && canonicalKey ? toolAliasMap.get(canonicalKey) ?? mapPropertyToTool(propertyKey) : mapPropertyToTool(propertyKey);
		return async (...callArgs) => {
			let schemaInfo;
			try {
				schemaInfo = await ensureMetadata(resolvedToolName);
			} catch {
				schemaInfo = undefined;
			}
			if (typeof propertyKey === "string" && canonicalKey) {
				const alias = toolAliasMap.get(canonicalKey);
				if (alias && alias !== resolvedToolName) {
					resolvedToolName = alias;
					try {
						schemaInfo = await ensureMetadata(resolvedToolName);
					} catch {}
				}
			}
			const positional = [];
			const argsAccumulator = {};
			const optionsAccumulator = {};
			for (const arg of callArgs) {
				if (isPlainObject(arg)) {
					const keys = Object.keys(arg);
					const treatAsArgs = schemaInfo !== undefined && keys.length > 0 && (keys.every((key) => schemaInfo.propertySet.has(key)) || keys.every((key) => !KNOWN_OPTION_KEYS.has(key)));
					if (treatAsArgs) {
						Object.assign(argsAccumulator, arg);
					} else {
						Object.assign(optionsAccumulator, arg);
					}
				} else {
					positional.push(arg);
				}
			}
			const explicitArgs = optionsAccumulator.args;
			if (explicitArgs !== undefined) {
				delete optionsAccumulator.args;
			}
			const finalOptions = { ...optionsAccumulator };
			let combinedArgs = explicitArgs;
			if (schemaInfo) {
				const schema = schemaInfo;
				if (positional.length > schema.orderedKeys.length) {
					throw new Error(`Too many positional arguments for tool "${resolvedToolName}"`);
				}
				if (positional.length > 0) {
					const baseArgs = isPlainObject(combinedArgs) ? { ...combinedArgs } : {};
					positional.forEach((value, idx) => {
						const key = schema.orderedKeys[idx];
						if (key) {
							baseArgs[key] = value;
						}
					});
					combinedArgs = baseArgs;
				}
				if (Object.keys(argsAccumulator).length > 0) {
					const baseArgs = isPlainObject(combinedArgs) ? { ...combinedArgs } : {};
					Object.assign(baseArgs, argsAccumulator);
					combinedArgs = baseArgs;
				}
				if (combinedArgs !== undefined) {
					combinedArgs = applyDefaults(schema, combinedArgs);
				} else {
					const defaults = applyDefaults(schema, undefined);
					if (defaults && typeof defaults === "object") {
						combinedArgs = defaults;
					}
				}
				validateRequired(schema, combinedArgs);
			} else {
				if (positional.length > 0) {
					combinedArgs = positional;
				}
				if (Object.keys(argsAccumulator).length > 0) {
					const baseArgs = isPlainObject(combinedArgs) ? { ...combinedArgs } : {};
					Object.assign(baseArgs, argsAccumulator);
					combinedArgs = baseArgs;
				}
			}
			if (combinedArgs !== undefined) {
				finalOptions.args = combinedArgs;
			}
			const result = await runtime.callTool(serverName, resolvedToolName, finalOptions);
			return createCallResult(result);
		};
	} });
}

//#endregion
//#region ../../../private/var/folders/d9/sg75n7q5239bf2bdzzhl3fpr0000gp/T/tmp.8eAWZJMdFi/pal.ts
const embeddedServer = {
	"name": "pal",
	"command": {
		"kind": "stdio",
		"command": "bash",
		"args": ["-lc", "for p in $(which uvx 2>/dev/null) $HOME/.local/bin/uvx /opt/homebrew/bin/uvx /usr/local/bin/uvx uvx; do\n  if [ -x \"$p\" ]; then\n    exec \"$p\" --from \"${PAL_MCP_FROM:-git+https://github.com/BeehiveInnovations/pal-mcp-server.git}\" pal-mcp-server\n  fi\ndone\necho \"uvx not found. Install uv/uvx, or put uvx on PATH.\" >&2\nexit 1"]
	},
	"env": { "DEFAULT_MODEL": "${PAL_DEFAULT_MODEL:-auto}" },
	"description": "When the user names a specific model (e.g. 'use chat with gpt5'), send that exact model in the tool call. When no model is mentioned, first use the `listmodels` tool from PAL to obtain available models to choose the best one from."
};
const embeddedSchemas = {
	"chat": {
		"type": "object",
		"properties": {
			"prompt": {
				"type": "string",
				"description": "Your question or idea for collaborative thinking to be sent to the external model. Provide detailed context, including your goal, what you've tried, and any specific challenges. WARNING: Large inline code must NOT be shared in prompt. Provide full-path to files on disk as separate parameter."
			},
			"absolute_file_paths": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Full, absolute file paths to relevant code in order to share with external model"
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Image paths (absolute) or base64 strings for optional visual context."
			},
			"working_directory_absolute_path": {
				"type": "string",
				"description": "Absolute path to an existing directory where generated code artifacts can be saved."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			}
		},
		"required": [
			"prompt",
			"working_directory_absolute_path",
			"model"
		],
		"additionalProperties": false
	},
	"clink": {
		"type": "object",
		"properties": {
			"prompt": {
				"type": "string",
				"description": "User request forwarded to the CLI (conversation context is pre-applied)."
			},
			"cli_name": {
				"type": "string",
				"enum": [
					"claude",
					"codex",
					"gemini"
				],
				"description": "Configured CLI client name (from conf/cli_clients). Available: claude, codex, gemini"
			},
			"role": {
				"type": "string",
				"enum": [
					"codereviewer",
					"default",
					"planner"
				],
				"description": "Optional role preset defined for the selected CLI (defaults to 'default'). Roles per CLI: claude: codereviewer, default, planner; codex: codereviewer, default, planner; gemini: codereviewer, default, planner"
			},
			"absolute_file_paths": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Full paths to relevant code"
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional absolute image paths or base64 blobs for visual context."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			}
		},
		"required": ["prompt", "cli_name"],
		"additionalProperties": false
	},
	"thinkdeep": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Current work step content and findings from your overall work"
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current step number in work sequence (starts at 1)"
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Estimated total steps needed to complete work"
			},
			"next_step_required": {
				"type": "boolean",
				"description": "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch."
			},
			"findings": {
				"type": "string",
				"description": "Important findings, evidence and insights discovered in this step"
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "List of files examined during this work step"
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Files identified as relevant to issue/goal (FULL absolute paths to real files/folders - DO NOT SHORTEN)"
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Issues identified with severity levels during work"
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed)"
			},
			"hypothesis": {
				"type": "string",
				"description": "Current theory about issue/goal based on work"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional absolute image paths or base64 blobs for visual context."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"problem_context": {
				"type": "string",
				"description": "Additional context about problem/goal. Be expressive."
			},
			"focus_areas": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Focus aspects (architecture, performance, security, etc.)"
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "ThinkdeepRequest"
	},
	"planner": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Planning content for this step. Step 1: describe the task, problem and scope. Later steps: capture updates, revisions, branches, or open questions that shape the plan."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current step number in work sequence (starts at 1)"
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Estimated total steps needed to complete work"
			},
			"next_step_required": {
				"type": "boolean",
				"description": "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch."
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"is_step_revision": {
				"type": "boolean",
				"description": "Set true when you are replacing a previously recorded step."
			},
			"revises_step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Step number being replaced when revising."
			},
			"is_branch_point": {
				"type": "boolean",
				"description": "True when this step creates a new branch to explore an alternative path."
			},
			"branch_from_step": {
				"type": "integer",
				"minimum": 1,
				"description": "If branching, the step number that this branch starts from."
			},
			"branch_id": {
				"type": "string",
				"description": "Name for this branch (e.g. 'approach-A', 'migration-path')."
			},
			"more_steps_needed": {
				"type": "boolean",
				"description": "True when you now expect to add additional steps beyond the prior estimate."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "PlannerRequest"
	},
	"consensus": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Consensus prompt. Step 1: write the exact proposal/question every model will see (use 'Evaluate', not meta commentary). Steps 2+: capture internal notes about the latest model responsethese notes are NOT sent to other models."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current step index (starts at 1). Step 1 is your analysis; steps 2+ handle each model response."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Total steps = number of models consulted plus the final synthesis step."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "True if more model consultations remain; set false when ready to synthesize."
			},
			"findings": {
				"type": "string",
				"description": "Step 1: your independent analysis for later synthesis (not shared with other models). Steps 2+: summarize the newest model response."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional supporting files that help the consensus analysis. Must be absolute full, non-abbreviated paths."
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional absolute image paths or base64 references that add helpful visual context."
			},
			"models": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"model": { "type": "string" },
						"stance": {
							"type": "string",
							"enum": [
								"for",
								"against",
								"neutral"
							],
							"default": "neutral"
						},
						"stance_prompt": { "type": "string" }
					},
					"required": ["model"]
				},
				"description": "User-specified roster of models to consult (provide at least two entries). User-specified list of models to consult (provide at least two entries). Each entry may include model, stance (for/against/neutral), and stance_prompt. Each (model, stance) pair must be unique, e.g. [{'model':'gpt5','stance':'for'}, {'model':'pro','stance':'against'}]. When the user names a model, you MUST use that exact value or report the provider errornever swap in another option. Use the `listmodels` tool for the full roster. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.",
				"minItems": 2
			},
			"current_model_index": {
				"type": "integer",
				"minimum": 0,
				"description": "0-based index of the next model to consult (managed internally)."
			},
			"model_responses": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Internal log of responses gathered so far."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "ConsensusRequest"
	},
	"codereview": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Review narrative. Step 1: outline the review strategy. Later steps: report findings. MUST cover quality, security, performance, and architecture. Reference code via `relevant_files`; avoid dumping large snippets."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current review step (starts at 1)  each step should build on the last."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Number of review steps planned. External validation: two steps (analysis + summary). Internal validation: one step. Use the same limits when continuing an existing review via continuation_id."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "True when another review step follows. External validation: step 1  True, step 2  False. Internal validation: set False immediately. Apply the same rule on continuation flows."
			},
			"findings": {
				"type": "string",
				"description": "Capture findings (positive and negative) across quality, security, performance, and architecture; update each step."
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Absolute paths of every file reviewed, including those ruled out."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Step 1: list all files/dirs under review. Must be absolute full non-abbreviated paths. Final step: narrow to files tied to key findings."
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Issues with severity (critical/high/medium/low) and descriptions."
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed)"
			},
			"hypothesis": {
				"type": "string",
				"description": "Current theory about issue/goal based on work"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional diagram or screenshot paths that clarify review context."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"review_validation_type": {
				"type": "string",
				"enum": ["external", "internal"],
				"default": "external",
				"description": "Set 'external' (default) for expert follow-up or 'internal' for local-only review."
			},
			"review_type": {
				"type": "string",
				"enum": [
					"full",
					"security",
					"performance",
					"quick"
				],
				"default": "full",
				"description": "Review focus: full, security, performance, or quick."
			},
			"focus_on": {
				"type": "string",
				"description": "Optional note on areas to emphasise (e.g. 'threading', 'auth flow')."
			},
			"standards": {
				"type": "string",
				"description": "Coding standards or style guides to enforce."
			},
			"severity_filter": {
				"type": "string",
				"enum": [
					"critical",
					"high",
					"medium",
					"low",
					"all"
				],
				"default": "all",
				"description": "Lowest severity to include when reporting issues (critical/high/medium/low/all)."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "CodereviewRequest"
	},
	"precommit": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Step 1: outline how you'll validate the git changes. Later steps: report findings. Review diffs and impacts, use `relevant_files`, and avoid pasting large snippets."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current pre-commit step number (starts at 1)."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 3,
				"description": "Planned number of validation steps. External validation: use at most three (analysis  follow-ups  summary). Internal validation: a single step. Honour these limits when resuming via continuation_id."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "True to continue with another step, False when validation is complete. CRITICAL: If total_steps>=3 or when `precommit_type = external`, set to True until the final step. When continuation_id is provided: Follow the same validation rules based on precommit_type."
			},
			"findings": {
				"type": "string",
				"description": "Record git diff insights, risks, missing tests, security concerns, and positives; update previous notes as you go."
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Absolute paths for every file examined, including ruled-out candidates."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Absolute paths of files involved in the change or validation (code, configs, tests, docs). Must be absolute full non-abbreviated paths."
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "List issues with severity (critical/high/medium/low) plus descriptions (bugs, security, performance, coverage)."
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed)"
			},
			"hypothesis": {
				"type": "string",
				"description": "Current theory about issue/goal based on work"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional absolute paths to screenshots or diagrams that aid validation."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"precommit_type": {
				"type": "string",
				"enum": ["external", "internal"],
				"default": "external",
				"description": "'external' (default, triggers expert model) or 'internal' (local-only validation)."
			},
			"path": {
				"type": "string",
				"description": "Absolute path to the repository root. Required in step 1."
			},
			"compare_to": {
				"type": "string",
				"description": "Optional git ref (branch/tag/commit) to diff against; falls back to staged/unstaged changes."
			},
			"include_staged": {
				"type": "boolean",
				"default": true,
				"description": "Whether to inspect staged changes (ignored when `compare_to` is set)."
			},
			"include_unstaged": {
				"type": "boolean",
				"default": true,
				"description": "Whether to inspect unstaged changes (ignored when `compare_to` is set)."
			},
			"focus_on": {
				"type": "string",
				"description": "Optional emphasis areas such as security, performance, or test coverage."
			},
			"severity_filter": {
				"type": "string",
				"enum": [
					"critical",
					"high",
					"medium",
					"low",
					"all"
				],
				"default": "all",
				"description": "Lowest severity to include when reporting issues."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "PrecommitRequest"
	},
	"debug": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Investigation step. Step 1: State issue+direction. Symptoms misleading; 'no bug' valid. Trace dependencies, verify hypotheses. Use relevant_files for code; this for text only."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current step index (starts at 1). Build upon previous steps."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Estimated total steps needed to complete the investigation. Adjust as new findings emerge. IMPORTANT: When continuation_id is provided (continuing a previous conversation), set this to 1 as we're not starting a new multi-step investigation."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "True if you plan to continue the investigation with another step. False means root cause is known or investigation is complete. IMPORTANT: When continuation_id is provided (continuing a previous conversation), set this to False to immediately proceed with expert analysis."
			},
			"findings": {
				"type": "string",
				"description": "Discoveries: clues, code/log evidence, disproven theories. Be specific. If no bug found, document clearly as valid."
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "All examined files (absolute paths), including ruled-out ones."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Files directly relevant to issue (absolute paths). Cause, trigger, or manifestation locations."
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Issues identified with severity levels during work"
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "Your confidence in the hypothesis: exploring (starting out), low (early idea), medium (some evidence), high (strong evidence), very_high (very strong evidence), almost_certain (nearly confirmed), certain (100% confidence - root cause and fix are both confirmed locally with no need for external validation). WARNING: Do NOT use 'certain' unless the issue can be fully resolved with a fix, use 'very_high' or 'almost_certain' instead when not 100% sure. Using 'certain' means you have ABSOLUTE confidence locally and PREVENTS external model validation."
			},
			"hypothesis": {
				"type": "string",
				"description": "Concrete root cause theory from evidence. Can revise. Valid: 'No bug found - user misunderstanding' or 'Symptoms unrelated to code' if supported."
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional screenshots/visuals clarifying issue (absolute paths)."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "DebugRequest"
	},
	"secaudit": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Step 1: outline the audit strategy (OWASP Top 10, auth, validation, etc.). Later steps: report findings. MANDATORY: use `relevant_files` for code references and avoid large snippets."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current security-audit step number (starts at 1)."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Expected number of audit steps; adjust as new risks surface."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "True while additional threat analysis remains; set False once you are ready to hand off for validation."
			},
			"findings": {
				"type": "string",
				"description": "Summarize vulnerabilities, auth issues, validation gaps, compliance notes, and positives; update prior findings as needed."
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Absolute paths for every file inspected, including rejected candidates."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Absolute paths for security-relevant files (auth modules, configs, sensitive code)."
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Security issues with severity (critical/high/medium/low) and descriptions (vulns, auth flaws, injection, crypto, config)."
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "exploring/low/medium/high/very_high/almost_certain/certain. 'certain' blocks external validationuse only when fully complete."
			},
			"hypothesis": {
				"type": "string",
				"description": "Current theory about issue/goal based on work"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional absolute paths to diagrams or threat models that inform the audit."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"security_scope": {
				"type": "string",
				"description": "Security context (web, mobile, API, cloud, etc.) including stack, user types, data sensitivity, and threat landscape."
			},
			"threat_level": {
				"type": "string",
				"enum": [
					"low",
					"medium",
					"high",
					"critical"
				],
				"default": "medium",
				"description": "Assess the threat level: low (internal/low-risk), medium (customer-facing/business data), high (regulated or sensitive), critical (financial/healthcare/PII)."
			},
			"compliance_requirements": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Applicable compliance frameworks or standards (SOC2, PCI DSS, HIPAA, GDPR, ISO 27001, NIST, etc.)."
			},
			"audit_focus": {
				"type": "string",
				"enum": [
					"owasp",
					"compliance",
					"infrastructure",
					"dependencies",
					"comprehensive"
				],
				"default": "comprehensive",
				"description": "Primary focus area: owasp, compliance, infrastructure, dependencies, or comprehensive."
			},
			"severity_filter": {
				"type": "string",
				"enum": [
					"critical",
					"high",
					"medium",
					"low",
					"all"
				],
				"default": "all",
				"description": "Minimum severity to include when reporting security issues."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "SecauditRequest"
	},
	"docgen": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Current work step content and findings from your overall work"
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current step number in work sequence (starts at 1)"
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Estimated total steps needed to complete work"
			},
			"next_step_required": {
				"type": "boolean",
				"description": "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch."
			},
			"findings": {
				"type": "string",
				"description": "Important findings, evidence and insights discovered in this step"
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Files identified as relevant to issue/goal (FULL absolute paths to real files/folders - DO NOT SHORTEN)"
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Issues identified with severity levels during work"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"document_complexity": {
				"type": "boolean",
				"default": true,
				"description": "Include algorithmic complexity (Big O) analysis when True (default)."
			},
			"document_flow": {
				"type": "boolean",
				"default": true,
				"description": "Include call flow/dependency notes when True (default)."
			},
			"update_existing": {
				"type": "boolean",
				"default": true,
				"description": "True (default) to polish inaccurate or outdated docs instead of leaving them untouched."
			},
			"comments_on_complex_logic": {
				"type": "boolean",
				"default": true,
				"description": "True (default) to add inline comments around non-obvious logic."
			},
			"num_files_documented": {
				"type": "integer",
				"default": 0,
				"minimum": 0,
				"description": "Count of files finished so far. Increment only when a file is fully documented."
			},
			"total_files_to_document": {
				"type": "integer",
				"default": 0,
				"minimum": 0,
				"description": "Total files identified in discovery; completion requires matching this count."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"document_complexity",
			"document_flow",
			"update_existing",
			"comments_on_complex_logic",
			"num_files_documented",
			"total_files_to_document"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "DocgenRequest"
	},
	"analyze": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "The analysis plan. Step 1: State your strategy, including how you will map the codebase structure, understand business logic, and assess code quality, performance implications, and architectural patterns. Later steps: Report findings and adapt the approach as new insights emerge."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "The index of the current step in the analysis sequence, beginning at 1. Each step should build upon or revise the previous one."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Your current estimate for how many steps will be needed to complete the analysis. Adjust as new findings emerge."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "Set to true if you plan to continue the investigation with another step. False means you believe the analysis is complete and ready for expert validation."
			},
			"findings": {
				"type": "string",
				"description": "Summary of discoveries from this step, including architectural patterns, tech stack assessment, scalability characteristics, performance implications, maintainability factors, and strategic improvement opportunities. IMPORTANT: Document both strengths (good patterns, solid architecture) and concerns (tech debt, overengineering, unnecessary complexity). In later steps, confirm or update past findings with additional evidence."
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "List all files examined (absolute paths). Include even ruled-out files to track exploration path."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Subset of files_checked directly relevant to analysis findings (absolute paths). Include files with significant patterns, architectural decisions, or strategic improvement opportunities."
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Issues or concerns identified during analysis, each with severity level (critical, high, medium, low)"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional absolute paths to architecture diagrams or visual references that help with analysis context."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "Your confidence in the analysis: exploring, low, medium, high, very_high, almost_certain, or certain. 'certain' indicates the analysis is complete and ready for validation."
			},
			"analysis_type": {
				"type": "string",
				"enum": [
					"architecture",
					"performance",
					"security",
					"quality",
					"general"
				],
				"default": "general",
				"description": "Type of analysis to perform (architecture, performance, security, quality, general)"
			},
			"output_format": {
				"type": "string",
				"enum": [
					"summary",
					"detailed",
					"actionable"
				],
				"default": "detailed",
				"description": "How to format the output (summary, detailed, actionable)"
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "AnalyzeRequest"
	},
	"refactor": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "The refactoring plan. Step 1: State strategy. Later steps: Report findings. CRITICAL: Examine code for smells, and opportunities for decomposition, modernization, and organization. Use 'relevant_files' for code. FORBIDDEN: Large code snippets."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "The index of the current step in the refactoring investigation sequence, beginning at 1. Each step should build upon or revise the previous one."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Your current estimate for how many steps will be needed to complete the refactoring investigation. Adjust as new opportunities emerge."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "Set to true if you plan to continue the investigation with another step. False means you believe the refactoring analysis is complete and ready for expert validation."
			},
			"findings": {
				"type": "string",
				"description": "Summary of discoveries from this step, including code smells and opportunities for decomposition, modernization, or organization. Document both strengths and weaknesses. In later steps, confirm or update past findings."
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "List all files examined (absolute paths). Include even ruled-out files to track exploration path."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Subset of files_checked with code requiring refactoring (absolute paths). Include files with code smells, decomposition needs, or improvement opportunities."
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Refactoring opportunities as dictionaries with 'severity' (critical/high/medium/low), 'type' (codesmells/decompose/modernize/organization), and 'description'. Include all improvement opportunities found."
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"incomplete",
					"partial",
					"complete"
				],
				"default": "incomplete",
				"description": "Your confidence in refactoring analysis: exploring (starting), incomplete (significant work remaining), partial (some opportunities found, more analysis needed), complete (comprehensive analysis finished, all major opportunities identified). WARNING: Use 'complete' ONLY when fully analyzed and can provide recommendations without expert help. 'complete' PREVENTS expert validation. Use 'partial' for large files or uncertain analysis."
			},
			"hypothesis": {
				"type": "string",
				"description": "Current theory about issue/goal based on work"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional list of absolute paths to architecture diagrams, UI mockups, design documents, or visual references that help with refactoring context. Only include if they materially assist understanding or assessment."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"refactor_type": {
				"type": "string",
				"enum": [
					"codesmells",
					"decompose",
					"modernize",
					"organization"
				],
				"default": "codesmells",
				"description": "Type of refactoring analysis to perform (codesmells, decompose, modernize, organization)"
			},
			"focus_areas": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Specific areas to focus on (e.g., 'performance', 'readability', 'maintainability', 'security')"
			},
			"style_guide_examples": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional existing code files to use as style/pattern reference (must be FULL absolute paths to real files / folders - DO NOT SHORTEN). These files represent the target coding style and patterns for the project."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "RefactorRequest"
	},
	"tracer": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Current work step content and findings from your overall work"
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current step number in work sequence (starts at 1)"
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Estimated total steps needed to complete work"
			},
			"next_step_required": {
				"type": "boolean",
				"description": "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch."
			},
			"findings": {
				"type": "string",
				"description": "Important findings, evidence and insights discovered in this step"
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "List of files examined during this work step"
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Files identified as relevant to issue/goal (FULL absolute paths to real files/folders - DO NOT SHORTEN)"
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed)"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional paths to architecture diagrams or flow charts that help understand the tracing context."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			},
			"trace_mode": {
				"type": "string",
				"enum": [
					"precision",
					"dependencies",
					"ask"
				],
				"description": "Type of tracing: 'ask' (default - prompts user to choose mode), 'precision' (execution flow) or 'dependencies' (structural relationships)"
			},
			"target_description": {
				"type": "string",
				"description": "Description of what to trace and WHY. Include context about what you're trying to understand or analyze."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"target_description",
			"trace_mode",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "TracerRequest"
	},
	"testgen": {
		"type": "object",
		"properties": {
			"step": {
				"type": "string",
				"description": "Test plan for this step. Step 1: outline how you'll analyse structure, business logic, critical paths, and edge cases. Later steps: record findings and new scenarios as they emerge."
			},
			"step_number": {
				"type": "integer",
				"minimum": 1,
				"description": "Current test-generation step (starts at 1)  each step should build on prior work."
			},
			"total_steps": {
				"type": "integer",
				"minimum": 1,
				"description": "Estimated number of steps needed for test planning; adjust as new scenarios appear."
			},
			"next_step_required": {
				"type": "boolean",
				"description": "True while more investigation or planning remains; set False when test planning is ready for expert validation."
			},
			"findings": {
				"type": "string",
				"description": "Summarise functionality, critical paths, edge cases, boundary conditions, error handling, and existing test patterns. Cover both happy and failure paths."
			},
			"files_checked": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Absolute paths of every file examined, including those ruled out."
			},
			"relevant_files": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Absolute paths of code that requires new or updated tests (implementation, dependencies, existing test fixtures)."
			},
			"relevant_context": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Methods/functions identified as involved in the issue"
			},
			"issues_found": {
				"type": "array",
				"items": { "type": "object" },
				"description": "Issues identified with severity levels during work"
			},
			"confidence": {
				"type": "string",
				"enum": [
					"exploring",
					"low",
					"medium",
					"high",
					"very_high",
					"almost_certain",
					"certain"
				],
				"description": "Indicate your current confidence in the test generation assessment. Use: 'exploring' (starting analysis), 'low' (early investigation), 'medium' (some patterns identified), 'high' (strong understanding), 'very_high' (very strong understanding), 'almost_certain' (nearly complete test plan), 'certain' (100% confidence - test plan is thoroughly complete and all test scenarios are identified with no need for external model validation). Do NOT use 'certain' unless the test generation analysis is comprehensively complete, use 'very_high' or 'almost_certain' instead if not 100% sure. Using 'certain' means you have complete confidence locally and prevents external model validation."
			},
			"hypothesis": {
				"type": "string",
				"description": "Current theory about issue/goal based on work"
			},
			"use_assistant_model": {
				"type": "boolean",
				"default": true,
				"description": "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation."
			},
			"temperature": {
				"type": "number",
				"description": "0 = deterministic  1 = creative.",
				"minimum": 0,
				"maximum": 1
			},
			"thinking_mode": {
				"type": "string",
				"enum": [
					"minimal",
					"low",
					"medium",
					"high",
					"max"
				],
				"description": "Reasoning depth: minimal, low, medium, high, or max."
			},
			"continuation_id": {
				"type": "string",
				"description": "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly."
			},
			"images": {
				"type": "array",
				"items": { "type": "string" },
				"description": "Optional absolute paths to diagrams or visuals that clarify the system under test."
			},
			"model": {
				"type": "string",
				"description": "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`."
			}
		},
		"required": [
			"step",
			"step_number",
			"total_steps",
			"next_step_required",
			"findings",
			"model"
		],
		"$schema": "http://json-schema.org/draft-07/schema#",
		"additionalProperties": false,
		"title": "TestgenRequest"
	},
	"challenge": {
		"type": "object",
		"properties": { "prompt": {
			"type": "string",
			"description": "Statement to scrutinize. If you invoke `challenge` manually, strip the word 'challenge' and pass just the statement. Automatic invocations send the full user message as-is; do not modify it."
		} },
		"required": ["prompt"]
	},
	"apilookup": {
		"type": "object",
		"properties": { "prompt": {
			"type": "string",
			"description": "The API, SDK, library, framework, or technology you need current documentation, version info, breaking changes, or migration guidance for."
		} },
		"required": ["prompt"]
	},
	"listmodels": {
		"type": "object",
		"properties": {},
		"required": [],
		"additionalProperties": false
	},
	"version": {
		"type": "object",
		"properties": {},
		"required": [],
		"additionalProperties": false
	}
};
const embeddedName = "pal";
const embeddedDescription = "When the user names a specific model (e.g. 'use chat with gpt5'), send that exact model in the tool call. When no model is mentioned, first use the `listmodels` tool from PAL to obtain available models to choose the best one from.";
const generatorInfo = "Generated by mcporter@0.7.3  https://github.com/steipete/mcporter";
const generatorTools = [
	{
		"name": "chat",
		"description": "General chat and collaborative thinking partner for brainstorming, development discussion, getting second opinions, and exploring ideas. Use for ideas, validations, questions, and thoughtful explanations.",
		"usage": "chat --prompt <prompt> [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] --working-directory-absolute-path <working-directory-absolute-path> --model <model> [--raw <json>]",
		"flags": "--prompt <prompt> [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] --working-directory-absolute-path <working-directory-absolute-path> --model <model> [--raw <json>]"
	},
	{
		"name": "clink",
		"description": "Link a request to an external AI CLI (Gemini CLI, Qwen CLI, etc.) through PAL MCP to reuse their capabilities inside existing workflows.",
		"usage": "clink --prompt <prompt> --cli-name <cli-name:claude|codex|gemini> [--role <role:codereviewer|default|planner>] [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] [--raw <json>]",
		"flags": "--prompt <prompt> --cli-name <cli-name:claude|codex|gemini> [--role <role:codereviewer|default|planner>] [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] [--raw <json>]"
	},
	{
		"name": "thinkdeep",
		"description": "Performs multi-stage investigation and reasoning for complex problem analysis. Use for architecture decisions, complex bugs, performance challenges, and security analysis. Provides systematic hypothesis testing, evidence-based investigation, and expert validation.",
		"usage": "thinkdeep --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "planner",
		"description": "Breaks down complex tasks through interactive, sequential planning with revision and branching capabilities. Use for complex project planning, system design, migration strategies, and architectural decisions. Builds plans incrementally with deep reflection for complex scenarios.",
		"usage": "planner --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --model <model> [--raw <json>]"
	},
	{
		"name": "consensus",
		"description": "Builds multi-model consensus through systematic analysis and structured debate. Use for complex decisions, architectural choices, feature proposals, and technology evaluations. Consults multiple models with different stances to synthesize comprehensive recommendations.",
		"usage": "consensus --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> [--raw <json>]"
	},
	{
		"name": "codereview",
		"description": "Performs systematic, step-by-step code review with expert validation. Use for comprehensive analysis covering quality, security, performance, and architecture. Guides through structured investigation to ensure thoroughness.",
		"usage": "codereview --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "precommit",
		"description": "Validates git changes and repository state before committing with systematic analysis. Use for multi-repository validation, security review, change impact assessment, and completeness verification. Guides through structured investigation with expert analysis.",
		"usage": "precommit --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "debug",
		"description": "Performs systematic debugging and root cause analysis for any type of issue. Use for complex bugs, mysterious errors, performance issues, race conditions, memory leaks, and integration problems. Guides through structured investigation with hypothesis testing and expert analysis.",
		"usage": "debug --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "secaudit",
		"description": "Performs comprehensive security audit with systematic vulnerability assessment. Use for OWASP Top 10 analysis, compliance evaluation, threat modeling, and security architecture review. Guides through structured security investigation with expert validation.",
		"usage": "secaudit --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "docgen",
		"description": "Generates comprehensive code documentation with systematic analysis of functions, classes, and complexity. Use for documentation generation, code analysis, complexity assessment, and API documentation. Analyzes code structure and patterns to create thorough documentation.",
		"usage": "docgen --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --document-complexity <document-complexity:true|false> --document-flow <document-flow:true|false> --update-existing <update-existing:true|false> --comments-on-complex-logic <comments-on-complex-logic:true|false> --num-files-documented <num-files-documented:number> --total-files-to-document <total-files-to-document:number> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --document-complexity <document-complexity:true|false> --document-flow <document-flow:true|false> --update-existing <update-existing:true|false> --comments-on-complex-logic <comments-on-complex-logic:true|false> --num-files-documented <num-files-documented:number> --total-files-to-document <total-files-to-document:number> [--raw <json>]"
	},
	{
		"name": "analyze",
		"description": "Performs comprehensive code analysis with systematic investigation and expert validation. Use for architecture, performance, maintainability, and pattern analysis. Guides through structured code review and strategic planning.",
		"usage": "analyze --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "refactor",
		"description": "Analyzes code for refactoring opportunities with systematic investigation. Use for code smell detection, decomposition planning, modernization, and maintainability improvements. Guides through structured analysis with expert validation.",
		"usage": "refactor --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "tracer",
		"description": "Performs systematic code tracing with modes for execution flow or dependency mapping. Use for method execution analysis, call chain tracing, dependency mapping, and architectural understanding. Supports precision mode (execution flow) and dependencies mode (structural relationships).",
		"usage": "tracer --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> --trace-mode <trace-mode:precision|dependencies|ask> --target-description <target-description> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> --trace-mode <trace-mode:precision|dependencies|ask> --target-description <target-description> [--raw <json>]"
	},
	{
		"name": "testgen",
		"description": "Creates comprehensive test suites with edge case coverage for specific functions, classes, or modules. Analyzes code paths, identifies failure modes, and generates framework-specific tests. Be specific about scope - target particular components rather than testing everything.",
		"usage": "testgen --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]",
		"flags": "--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]"
	},
	{
		"name": "challenge",
		"description": "Prevents reflexive agreement by forcing critical thinking and reasoned analysis when a statement is challenged. Trigger automatically when a user critically questions, disagrees or appears to push back on earlier answers, and use it manually to sanity-check contentious claims.",
		"usage": "challenge --prompt <prompt> [--raw <json>]",
		"flags": "--prompt <prompt> [--raw <json>]"
	},
	{
		"name": "apilookup",
		"description": "Use this tool automatically when you need current API/SDK documentation, latest version info, breaking changes, deprecations, migration guides, or official release notes. This tool searches authoritative sources (official docs, GitHub, package registries) to ensure up-to-date accuracy.",
		"usage": "apilookup --prompt <prompt> [--raw <json>]",
		"flags": "--prompt <prompt> [--raw <json>]"
	},
	{
		"name": "listmodels",
		"description": "Shows which AI model providers are configured, available model names, their aliases and capabilities.",
		"usage": "listmodels [--raw <json>]",
		"flags": "[--raw <json>]"
	},
	{
		"name": "version",
		"description": "Get server version, configuration details, and list of available tools.",
		"usage": "version [--raw <json>]",
		"flags": "[--raw <json>]"
	}
];
const embeddedMetadata = {
	"schemaVersion": 1,
	"generatedAt": "2026-01-12T07:17:45.190Z",
	"generator": {
		"name": "mcporter",
		"version": "0.7.3"
	},
	"server": {
		"name": "pal",
		"definition": {
			"name": "pal",
			"description": "When the user names a specific model (e.g. 'use chat with gpt5'), send that exact model in the tool call. When no model is mentioned, first use the `listmodels` tool from PAL to obtain available models to choose the best one from.",
			"command": {
				"kind": "stdio",
				"command": "bash",
				"args": ["-lc", "for p in $(which uvx 2>/dev/null) $HOME/.local/bin/uvx /opt/homebrew/bin/uvx /usr/local/bin/uvx uvx; do\n  if [ -x \"$p\" ]; then\n    exec \"$p\" --from \"${PAL_MCP_FROM:-git+https://github.com/BeehiveInnovations/pal-mcp-server.git}\" pal-mcp-server\n  fi\ndone\necho \"uvx not found. Install uv/uvx, or put uvx on PATH.\" >&2\nexit 1"]
			},
			"env": { "DEFAULT_MODEL": "${PAL_DEFAULT_MODEL:-auto}" }
		}
	},
	"artifact": {
		"path": "",
		"kind": "template"
	},
	"invocation": {
		"serverRef": "{\"name\": \"pal\", \"command\": {\"kind\": \"stdio\", \"command\": \"bash\", \"args\": [\"-lc\", \"for p in $(which uvx 2>/dev/null) $HOME/.local/bin/uvx /opt/homebrew/bin/uvx /usr/local/bin/uvx uvx; do\\n  if [ -x \\\"$p\\\" ]; then\\n    exec \\\"$p\\\" --from \\\"${PAL_MCP_FROM:-git+https://github.com/BeehiveInnovations/pal-mcp-server.git}\\\" pal-mcp-server\\n  fi\\ndone\\necho \\\"uvx not found. Install uv/uvx, or put uvx on PATH.\\\" >&2\\nexit 1\"]}, \"env\": {\"DEFAULT_MODEL\": \"${PAL_DEFAULT_MODEL:-auto}\"}}",
		"runtime": "node",
		"bundler": "rolldown",
		"outputPath": "/var/folders/d9/sg75n7q5239bf2bdzzhl3fpr0000gp/T/tmp.8eAWZJMdFi/pal.ts",
		"bundle": "/Users/prateek/dotfiles/.codex/skills/pal-mcporter/scripts/pal-cli.js",
		"timeoutMs": 12e4,
		"minify": false
	}
};
const artifactKind = determineArtifactKind();
const program = new import_commander.Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option("-t, --timeout <ms>", "Call timeout in milliseconds", (value) => parseInt(value, 10), 12e4);
program.option("-o, --output <format>", "Output format: text|markdown|json|raw", "text");
const commandSignatures = {
	"chat": "function chat(prompt: string, absolute_file_paths?: string[], images?: string[], working_directory_absolute_path: string, model: string);",
	"clink": "function clink(prompt: string, cli_name: \"claude\" | \"codex\" | \"gemini\", role?: \"codereviewer\" | \"default\" | \"planner\", absolute_file_paths?: string[], images?: string[]);",
	"thinkdeep": "function thinkdeep(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"planner": "function planner(step: string, step_number: number, total_steps: number, next_step_required: boolean, model: string);",
	"consensus": "function consensus(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string);",
	"codereview": "function codereview(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"precommit": "function precommit(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"debug": "function debug(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"secaudit": "function secaudit(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"docgen": "function docgen(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, document_complexity: boolean, document_flow: boolean, update_existing: boolean, comments_on_complex_logic: boolean, num_files_documented: number, total_files_to_document: number);",
	"analyze": "function analyze(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"refactor": "function refactor(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"tracer": "function tracer(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string, trace_mode: \"precision\" | \"dependencies\" | \"ask\", target_description: string);",
	"testgen": "function testgen(step: string, step_number: number, total_steps: number, next_step_required: boolean, findings: string, model: string);",
	"challenge": "function challenge(prompt: string);",
	"apilookup": "function apilookup(prompt: string);",
	"listmodels": "function listmodels();",
	"version": "function version();"
};
program.configureHelp({ commandTerm(cmd) {
	const term = cmd.name();
	return commandSignatures[term] ?? cmd.name();
} });
program.showSuggestionAfterError(true);
program.command("chat").summary("chat --prompt <prompt> [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] --working-directory-absolute-path <working-directory-absolute-path> --model <model> [--raw <json>]").description("General chat and collaborative thinking partner for brainstorming, development discussion, getting second opinions, and exploring ideas. Use for ideas, validations, questions, and thoughtful explanations.").usage("--prompt <prompt> [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] --working-directory-absolute-path <working-directory-absolute-path> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--prompt <prompt>", "Your question or idea for collaborative thinking to be sent to the external model. Provide detailed context, including your goal, what you've tried, and any specific challenges. WARNING: Large inline code must NOT be shared in prompt. Provide full-path to files on disk as separate parameter.").option("--absolute-file-paths <absolute-file-paths:value1,value2>", "Full, absolute file paths to relevant code in order to share with external model (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--images <images:value1,value2>", "Image paths (absolute) or base64 strings for optional visual context. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--working-directory-absolute-path <working-directory-absolute-path>", "Absolute path to an existing directory where generated code artifacts can be saved. (example: /path/to/file.md)").requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.prompt !== undefined) args.prompt = cmdOpts.prompt;
		if (cmdOpts.absoluteFilePaths !== undefined) args.absolute_file_paths = cmdOpts.absoluteFilePaths;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.workingDirectoryAbsolutePath !== undefined) args.working_directory_absolute_path = cmdOpts.workingDirectoryAbsolutePath;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		const call = proxy.chat(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.chat(prompt: \"value\", absolute_file_paths: [\"value1\", \"v, ...)").addHelpText("afterAll", () => "\n" + "// optional (3): temperature, thinking_mode, continuation_id" + "\n");
program.command("clink").summary("clink --prompt <prompt> --cli-name <cli-name:claude|codex|gemini> [--role <role:codereviewer|default|planner>] [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] [--raw <json>]").description("Link a request to an external AI CLI (Gemini CLI, Qwen CLI, etc.) through PAL MCP to reuse their capabilities inside existing workflows.").usage("--prompt <prompt> --cli-name <cli-name:claude|codex|gemini> [--role <role:codereviewer|default|planner>] [--absolute-file-paths <absolute-file-paths:value1,value2>] [--images <images:value1,value2>] [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--prompt <prompt>", "User request forwarded to the CLI (conversation context is pre-applied).").requiredOption("--cli-name <cli-name:claude|codex|gemini>", "Configured CLI client name (from conf/cli_clients). Available: claude, codex, gemini (choices: claude, codex, gemini; example: claude)").option("--role <role:codereviewer|default|planner>", "Optional role preset defined for the selected CLI (defaults to 'default'). Roles per CLI: claude: codereviewer, default, planner; codex: codereviewer, default, planner; gemini: codereviewer, default, planner (choices: codereviewer, default, planner; example: codereviewer)").option("--absolute-file-paths <absolute-file-paths:value1,value2>", "Full paths to relevant code (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--images <images:value1,value2>", "Optional absolute image paths or base64 blobs for visual context. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.prompt !== undefined) args.prompt = cmdOpts.prompt;
		if (cmdOpts.cliName !== undefined) args.cli_name = cmdOpts.cliName;
		if (cmdOpts.role !== undefined) args.role = cmdOpts.role;
		if (cmdOpts.absoluteFilePaths !== undefined) args.absolute_file_paths = cmdOpts.absoluteFilePaths;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		const call = proxy.clink(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.clink(prompt: \"value\", cli_name: \"claude\", role: \"codere, ...)").addHelpText("afterAll", () => "\n" + "// optional (1): continuation_id" + "\n");
program.command("thinkdeep").summary("thinkdeep --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Performs multi-stage investigation and reasoning for complex problem analysis. Use for architecture decisions, complex bugs, performance challenges, and security analysis. Provides systematic hypothesis testing, evidence-based investigation, and expert validation.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Current work step content and findings from your overall work").requiredOption("--step-number <step-number:number>", "Current step number in work sequence (starts at 1) (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Estimated total steps needed to complete work (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Important findings, evidence and insights discovered in this step").option("--files-checked <files-checked:value1,value2>", "List of files examined during this work step (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Files identified as relevant to issue/goal (FULL absolute paths to real files/folders - DO NOT SHORTEN) (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Issues identified with severity levels during work (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed) (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--hypothesis <hypothesis>", "Current theory about issue/goal based on work").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional absolute image paths or base64 blobs for visual context. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--problem-context <problem-context>", "Additional context about problem/goal. Be expressive.").option("--focus-areas <focus-areas:value1,value2>", "Focus aspects (architecture, performance, security, etc.) (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.hypothesis !== undefined) args.hypothesis = cmdOpts.hypothesis;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.problemContext !== undefined) args.problem_context = cmdOpts.problemContext;
		if (cmdOpts.focusAreas !== undefined) args.focus_areas = cmdOpts.focusAreas;
		const call = proxy.thinkdeep(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.thinkdeep(step: \"value\", step_number: 1, total_steps: 1, ...)").addHelpText("afterAll", () => "\n" + "// optional (13): files_checked, relevant_files, relevant_context, issues_found, confidence, ..." + "\n");
program.command("planner").summary("planner --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --model <model> [--raw <json>]").description("Breaks down complex tasks through interactive, sequential planning with revision and branching capabilities. Use for complex project planning, system design, migration strategies, and architectural decisions. Builds plans incrementally with deep reflection for complex scenarios.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Planning content for this step. Step 1: describe the task, problem and scope. Later steps: capture updates, revisions, branches, or open questions that shape the plan.").requiredOption("--step-number <step-number:number>", "Current step number in work sequence (starts at 1) (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Estimated total steps needed to complete work (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch. (example: true)", (value) => value !== "false").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--is-step-revision <is-step-revision:true|false>", "Set true when you are replacing a previously recorded step. (example: true)", (value) => value !== "false").option("--revises-step-number <revises-step-number:number>", "Step number being replaced when revising. (example: 1)", (value) => parseFloat(value)).option("--is-branch-point <is-branch-point:true|false>", "True when this step creates a new branch to explore an alternative path. (example: true)", (value) => value !== "false").option("--branch-from-step <branch-from-step:number>", "If branching, the step number that this branch starts from. (example: 1)", (value) => parseFloat(value)).option("--branch-id <branch-id>", "Name for this branch (e.g. 'approach-A', 'migration-path'). (example: example-id)").option("--more-steps-needed <more-steps-needed:true|false>", "True when you now expect to add additional steps beyond the prior estimate. (example: true)", (value) => value !== "false").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.isStepRevision !== undefined) args.is_step_revision = cmdOpts.isStepRevision;
		if (cmdOpts.revisesStepNumber !== undefined) args.revises_step_number = cmdOpts.revisesStepNumber;
		if (cmdOpts.isBranchPoint !== undefined) args.is_branch_point = cmdOpts.isBranchPoint;
		if (cmdOpts.branchFromStep !== undefined) args.branch_from_step = cmdOpts.branchFromStep;
		if (cmdOpts.branchId !== undefined) args.branch_id = cmdOpts.branchId;
		if (cmdOpts.moreStepsNeeded !== undefined) args.more_steps_needed = cmdOpts.moreStepsNeeded;
		const call = proxy.planner(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.planner(step: \"value\", step_number: 1, total_steps: 1, n, ...)").addHelpText("afterAll", () => "\n" + "// optional (8): use_assistant_model, continuation_id, is_step_revision, revises_step_number, is_branch_point, ..." + "\n");
program.command("consensus").summary("consensus --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> [--raw <json>]").description("Builds multi-model consensus through systematic analysis and structured debate. Use for complex decisions, architectural choices, feature proposals, and technology evaluations. Consults multiple models with different stances to synthesize comprehensive recommendations.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Consensus prompt. Step 1: write the exact proposal/question every model will see (use 'Evaluate', not meta commentary). Steps 2+: capture internal notes about the latest model responsethese notes are NOT sent to other models.").requiredOption("--step-number <step-number:number>", "Current step index (starts at 1). Step 1 is your analysis; steps 2+ handle each model response. (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Total steps = number of models consulted plus the final synthesis step. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "True if more model consultations remain; set false when ready to synthesize. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Step 1: your independent analysis for later synthesis (not shared with other models). Steps 2+: summarize the newest model response.").option("--relevant-files <relevant-files:value1,value2>", "Optional supporting files that help the consensus analysis. Must be absolute full, non-abbreviated paths. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional absolute image paths or base64 references that add helpful visual context. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--models <models:value1,value2>", "User-specified roster of models to consult (provide at least two entries). User-specified list of models to consult (provide at least two entries). Each entry may include model, stance (for/against/neutral), and stance_prompt. Each (model, stance) pair must be unique, e.g. [{'model':'gpt5','stance':'for'}, {'model':'pro','stance':'against'}]. When the user names a model, you MUST use that exact value or report the provider errornever swap in another option. Use the `listmodels` tool for the full roster. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--current-model-index <current-model-index:number>", "0-based index of the next model to consult (managed internally). (example: 1)", (value) => parseFloat(value)).option("--model-responses <model-responses:value1,value2>", "Internal log of responses gathered so far. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.models !== undefined) args.models = cmdOpts.models;
		if (cmdOpts.currentModelIndex !== undefined) args.current_model_index = cmdOpts.currentModelIndex;
		if (cmdOpts.modelResponses !== undefined) args.model_responses = cmdOpts.modelResponses;
		const call = proxy.consensus(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.consensus(step: \"value\", step_number: 1, total_steps: 1, ...)").addHelpText("afterAll", () => "\n" + "// optional (7): relevant_files, use_assistant_model, continuation_id, images, models, ..." + "\n");
program.command("codereview").summary("codereview --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Performs systematic, step-by-step code review with expert validation. Use for comprehensive analysis covering quality, security, performance, and architecture. Guides through structured investigation to ensure thoroughness.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Review narrative. Step 1: outline the review strategy. Later steps: report findings. MUST cover quality, security, performance, and architecture. Reference code via `relevant_files`; avoid dumping large snippets.").requiredOption("--step-number <step-number:number>", "Current review step (starts at 1)  each step should build on the last. (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Number of review steps planned. External validation: two steps (analysis + summary). Internal validation: one step. Use the same limits when continuing an existing review via continuation_id. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "True when another review step follows. External validation: step 1  True, step 2  False. Internal validation: set False immediately. Apply the same rule on continuation flows. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Capture findings (positive and negative) across quality, security, performance, and architecture; update each step.").option("--files-checked <files-checked:value1,value2>", "Absolute paths of every file reviewed, including those ruled out. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Step 1: list all files/dirs under review. Must be absolute full non-abbreviated paths. Final step: narrow to files tied to key findings. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Issues with severity (critical/high/medium/low) and descriptions. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed) (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--hypothesis <hypothesis>", "Current theory about issue/goal based on work").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional diagram or screenshot paths that clarify review context. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--review-validation-type <review-validation-type:external|internal>", "Set 'external' (default) for expert follow-up or 'internal' for local-only review. (choices: external, internal; default: external; example: external)").option("--review-type <review-type:full|security|performance|quick>", "Review focus: full, security, performance, or quick. (choices: full, security, performance, quick; default: full; example: full)").option("--focus-on <focus-on>", "Optional note on areas to emphasise (e.g. 'threading', 'auth flow').").option("--standards <standards>", "Coding standards or style guides to enforce.").option("--severity-filter <severity-filter:critical|high|medium|low|all>", "Lowest severity to include when reporting issues (critical/high/medium/low/all). (choices: critical, high, medium, low, all; default: all; example: critical)").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.hypothesis !== undefined) args.hypothesis = cmdOpts.hypothesis;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.reviewValidationType !== undefined) args.review_validation_type = cmdOpts.reviewValidationType;
		if (cmdOpts.reviewType !== undefined) args.review_type = cmdOpts.reviewType;
		if (cmdOpts.focusOn !== undefined) args.focus_on = cmdOpts.focusOn;
		if (cmdOpts.standards !== undefined) args.standards = cmdOpts.standards;
		if (cmdOpts.severityFilter !== undefined) args.severity_filter = cmdOpts.severityFilter;
		const call = proxy.codereview(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.codereview(step: \"value\", step_number: 1, total_steps: 1, ...)").addHelpText("afterAll", () => "\n" + "// optional (16): files_checked, relevant_files, relevant_context, issues_found, confidence, ..." + "\n");
program.command("precommit").summary("precommit --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Validates git changes and repository state before committing with systematic analysis. Use for multi-repository validation, security review, change impact assessment, and completeness verification. Guides through structured investigation with expert analysis.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Step 1: outline how you'll validate the git changes. Later steps: report findings. Review diffs and impacts, use `relevant_files`, and avoid pasting large snippets.").requiredOption("--step-number <step-number:number>", "Current pre-commit step number (starts at 1). (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Planned number of validation steps. External validation: use at most three (analysis  follow-ups  summary). Internal validation: a single step. Honour these limits when resuming via continuation_id. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "True to continue with another step, False when validation is complete. CRITICAL: If total_steps>=3 or when `precommit_type = external`, set to True until the final step. When continuation_id is provided: Follow the same validation rules based on precommit_type. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Record git diff insights, risks, missing tests, security concerns, and positives; update previous notes as you go.").option("--files-checked <files-checked:value1,value2>", "Absolute paths for every file examined, including ruled-out candidates. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Absolute paths of files involved in the change or validation (code, configs, tests, docs). Must be absolute full non-abbreviated paths. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "List issues with severity (critical/high/medium/low) plus descriptions (bugs, security, performance, coverage). (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed) (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--hypothesis <hypothesis>", "Current theory about issue/goal based on work").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional absolute paths to screenshots or diagrams that aid validation. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--precommit-type <precommit-type:external|internal>", "'external' (default, triggers expert model) or 'internal' (local-only validation). (choices: external, internal; default: external; example: external)").option("--path <path>", "Absolute path to the repository root. Required in step 1. (example: /path/to/file.md)").option("--compare-to <compare-to>", "Optional git ref (branch/tag/commit) to diff against; falls back to staged/unstaged changes.").option("--include-staged <include-staged:true|false>", "Whether to inspect staged changes (ignored when `compare_to` is set). (default: true; example: true)", (value) => value !== "false").option("--include-unstaged <include-unstaged:true|false>", "Whether to inspect unstaged changes (ignored when `compare_to` is set). (default: true; example: true)", (value) => value !== "false").option("--focus-on <focus-on>", "Optional emphasis areas such as security, performance, or test coverage.").option("--severity-filter <severity-filter:critical|high|medium|low|all>", "Lowest severity to include when reporting issues. (choices: critical, high, medium, low, all; default: all; example: critical)").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.hypothesis !== undefined) args.hypothesis = cmdOpts.hypothesis;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.precommitType !== undefined) args.precommit_type = cmdOpts.precommitType;
		if (cmdOpts.path !== undefined) args.path = cmdOpts.path;
		if (cmdOpts.compareTo !== undefined) args.compare_to = cmdOpts.compareTo;
		if (cmdOpts.includeStaged !== undefined) args.include_staged = cmdOpts.includeStaged;
		if (cmdOpts.includeUnstaged !== undefined) args.include_unstaged = cmdOpts.includeUnstaged;
		if (cmdOpts.focusOn !== undefined) args.focus_on = cmdOpts.focusOn;
		if (cmdOpts.severityFilter !== undefined) args.severity_filter = cmdOpts.severityFilter;
		const call = proxy.precommit(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.precommit(step: \"value\", step_number: 1, total_steps: 1, ...)").addHelpText("afterAll", () => "\n" + "// optional (18): files_checked, relevant_files, relevant_context, issues_found, confidence, ..." + "\n");
program.command("debug").summary("debug --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Performs systematic debugging and root cause analysis for any type of issue. Use for complex bugs, mysterious errors, performance issues, race conditions, memory leaks, and integration problems. Guides through structured investigation with hypothesis testing and expert analysis.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Investigation step. Step 1: State issue+direction. Symptoms misleading; 'no bug' valid. Trace dependencies, verify hypotheses. Use relevant_files for code; this for text only.").requiredOption("--step-number <step-number:number>", "Current step index (starts at 1). Build upon previous steps. (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Estimated total steps needed to complete the investigation. Adjust as new findings emerge. IMPORTANT: When continuation_id is provided (continuing a previous conversation), set this to 1 as we're not starting a new multi-step investigation. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "True if you plan to continue the investigation with another step. False means root cause is known or investigation is complete. IMPORTANT: When continuation_id is provided (continuing a previous conversation), set this to False to immediately proceed with expert analysis. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Discoveries: clues, code/log evidence, disproven theories. Be specific. If no bug found, document clearly as valid.").option("--files-checked <files-checked:value1,value2>", "All examined files (absolute paths), including ruled-out ones. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Files directly relevant to issue (absolute paths). Cause, trigger, or manifestation locations. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Issues identified with severity levels during work (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "Your confidence in the hypothesis: exploring (starting out), low (early idea), medium (some evidence), high (strong evidence), very_high (very strong evidence), almost_certain (nearly confirmed), certain (100% confidence - root cause and fix are both confirmed locally with no need for external validation). WARNING: Do NOT use 'certain' unless the issue can be fully resolved with a fix, use 'very_high' or 'almost_certain' instead when not 100% sure. Using 'certain' means you have ABSOLUTE confidence locally and PREVENTS external model validation. (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--hypothesis <hypothesis>", "Concrete root cause theory from evidence. Can revise. Valid: 'No bug found - user misunderstanding' or 'Symptoms unrelated to code' if supported.").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional screenshots/visuals clarifying issue (absolute paths). (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.hypothesis !== undefined) args.hypothesis = cmdOpts.hypothesis;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		const call = proxy.debug(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.debug(step: \"value\", step_number: 1, total_steps: 1, nex, ...)").addHelpText("afterAll", () => "\n" + "// optional (11): files_checked, relevant_files, relevant_context, issues_found, confidence, ..." + "\n");
program.command("secaudit").summary("secaudit --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Performs comprehensive security audit with systematic vulnerability assessment. Use for OWASP Top 10 analysis, compliance evaluation, threat modeling, and security architecture review. Guides through structured security investigation with expert validation.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Step 1: outline the audit strategy (OWASP Top 10, auth, validation, etc.). Later steps: report findings. MANDATORY: use `relevant_files` for code references and avoid large snippets.").requiredOption("--step-number <step-number:number>", "Current security-audit step number (starts at 1). (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Expected number of audit steps; adjust as new risks surface. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "True while additional threat analysis remains; set False once you are ready to hand off for validation. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Summarize vulnerabilities, auth issues, validation gaps, compliance notes, and positives; update prior findings as needed.").option("--files-checked <files-checked:value1,value2>", "Absolute paths for every file inspected, including rejected candidates. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Absolute paths for security-relevant files (auth modules, configs, sensitive code). (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Security issues with severity (critical/high/medium/low) and descriptions (vulns, auth flaws, injection, crypto, config). (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "exploring/low/medium/high/very_high/almost_certain/certain. 'certain' blocks external validationuse only when fully complete. (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--hypothesis <hypothesis>", "Current theory about issue/goal based on work").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional absolute paths to diagrams or threat models that inform the audit. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--security-scope <security-scope>", "Security context (web, mobile, API, cloud, etc.) including stack, user types, data sensitivity, and threat landscape.").option("--threat-level <threat-level:low|medium|high|critical>", "Assess the threat level: low (internal/low-risk), medium (customer-facing/business data), high (regulated or sensitive), critical (financial/healthcare/PII). (choices: low, medium, high, critical; default: medium; example: low)").option("--compliance-requirements <compliance-requirements:value1,value2>", "Applicable compliance frameworks or standards (SOC2, PCI DSS, HIPAA, GDPR, ISO 27001, NIST, etc.). (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--audit-focus <audit-focus:owasp|compliance|infrastructure|dependencies|comprehensive>", "Primary focus area: owasp, compliance, infrastructure, dependencies, or comprehensive. (choices: owasp, compliance, infrastructure, dependencies, comprehensive; default: comprehensive; example: owasp)").option("--severity-filter <severity-filter:critical|high|medium|low|all>", "Minimum severity to include when reporting security issues. (choices: critical, high, medium, low, all; default: all; example: critical)").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.hypothesis !== undefined) args.hypothesis = cmdOpts.hypothesis;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.securityScope !== undefined) args.security_scope = cmdOpts.securityScope;
		if (cmdOpts.threatLevel !== undefined) args.threat_level = cmdOpts.threatLevel;
		if (cmdOpts.complianceRequirements !== undefined) args.compliance_requirements = cmdOpts.complianceRequirements;
		if (cmdOpts.auditFocus !== undefined) args.audit_focus = cmdOpts.auditFocus;
		if (cmdOpts.severityFilter !== undefined) args.severity_filter = cmdOpts.severityFilter;
		const call = proxy.secaudit(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.secaudit(step: \"value\", step_number: 1, total_steps: 1, ...)").addHelpText("afterAll", () => "\n" + "// optional (16): files_checked, relevant_files, relevant_context, issues_found, confidence, ..." + "\n");
program.command("docgen").summary("docgen --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --document-complexity <document-complexity:true|false> --document-flow <document-flow:true|false> --update-existing <update-existing:true|false> --comments-on-complex-logic <comments-on-complex-logic:true|false> --num-files-documented <num-files-documented:number> --total-files-to-document <total-files-to-document:number> [--raw <json>]").description("Generates comprehensive code documentation with systematic analysis of functions, classes, and complexity. Use for documentation generation, code analysis, complexity assessment, and API documentation. Analyzes code structure and patterns to create thorough documentation.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --document-complexity <document-complexity:true|false> --document-flow <document-flow:true|false> --update-existing <update-existing:true|false> --comments-on-complex-logic <comments-on-complex-logic:true|false> --num-files-documented <num-files-documented:number> --total-files-to-document <total-files-to-document:number> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Current work step content and findings from your overall work").requiredOption("--step-number <step-number:number>", "Current step number in work sequence (starts at 1) (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Estimated total steps needed to complete work (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Important findings, evidence and insights discovered in this step").option("--relevant-files <relevant-files:value1,value2>", "Files identified as relevant to issue/goal (FULL absolute paths to real files/folders - DO NOT SHORTEN) (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Issues identified with severity levels during work (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").requiredOption("--document-complexity <document-complexity:true|false>", "Include algorithmic complexity (Big O) analysis when True (default). (default: true; example: true)", (value) => value !== "false").requiredOption("--document-flow <document-flow:true|false>", "Include call flow/dependency notes when True (default). (default: true; example: true)", (value) => value !== "false").requiredOption("--update-existing <update-existing:true|false>", "True (default) to polish inaccurate or outdated docs instead of leaving them untouched. (default: true; example: true)", (value) => value !== "false").requiredOption("--comments-on-complex-logic <comments-on-complex-logic:true|false>", "True (default) to add inline comments around non-obvious logic. (default: true; example: true)", (value) => value !== "false").requiredOption("--num-files-documented <num-files-documented:number>", "Count of files finished so far. Increment only when a file is fully documented. (default: 0; example: 0)", (value) => parseFloat(value)).requiredOption("--total-files-to-document <total-files-to-document:number>", "Total files identified in discovery; completion requires matching this count. (default: 0; example: 0)", (value) => parseFloat(value)).action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.documentComplexity !== undefined) args.document_complexity = cmdOpts.documentComplexity;
		if (cmdOpts.documentFlow !== undefined) args.document_flow = cmdOpts.documentFlow;
		if (cmdOpts.updateExisting !== undefined) args.update_existing = cmdOpts.updateExisting;
		if (cmdOpts.commentsOnComplexLogic !== undefined) args.comments_on_complex_logic = cmdOpts.commentsOnComplexLogic;
		if (cmdOpts.numFilesDocumented !== undefined) args.num_files_documented = cmdOpts.numFilesDocumented;
		if (cmdOpts.totalFilesToDocument !== undefined) args.total_files_to_document = cmdOpts.totalFilesToDocument;
		const call = proxy.docgen(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.docgen(step: \"value\", step_number: 1, total_steps: 1, ne, ...)").addHelpText("afterAll", () => "\n" + "// optional (5): relevant_files, relevant_context, issues_found, use_assistant_model, continuation_id" + "\n");
program.command("analyze").summary("analyze --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Performs comprehensive code analysis with systematic investigation and expert validation. Use for architecture, performance, maintainability, and pattern analysis. Guides through structured code review and strategic planning.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "The analysis plan. Step 1: State your strategy, including how you will map the codebase structure, understand business logic, and assess code quality, performance implications, and architectural patterns. Later steps: Report findings and adapt the approach as new insights emerge.").requiredOption("--step-number <step-number:number>", "The index of the current step in the analysis sequence, beginning at 1. Each step should build upon or revise the previous one. (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Your current estimate for how many steps will be needed to complete the analysis. Adjust as new findings emerge. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "Set to true if you plan to continue the investigation with another step. False means you believe the analysis is complete and ready for expert validation. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Summary of discoveries from this step, including architectural patterns, tech stack assessment, scalability characteristics, performance implications, maintainability factors, and strategic improvement opportunities. IMPORTANT: Document both strengths (good patterns, solid architecture) and concerns (tech debt, overengineering, unnecessary complexity). In later steps, confirm or update past findings with additional evidence.").option("--files-checked <files-checked:value1,value2>", "List all files examined (absolute paths). Include even ruled-out files to track exploration path. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Subset of files_checked directly relevant to analysis findings (absolute paths). Include files with significant patterns, architectural decisions, or strategic improvement opportunities. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Issues or concerns identified during analysis, each with severity level (critical, high, medium, low) (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional absolute paths to architecture diagrams or visual references that help with analysis context. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "Your confidence in the analysis: exploring, low, medium, high, very_high, almost_certain, or certain. 'certain' indicates the analysis is complete and ready for validation. (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--analysis-type <analysis-type:architecture|performance|security|quality|general>", "Type of analysis to perform (architecture, performance, security, quality, general) (choices: architecture, performance, security, quality, general; default: general; example: architecture)").option("--output-format <output-format:summary|detailed|actionable>", "How to format the output (summary, detailed, actionable) (choices: summary, detailed, actionable; default: detailed; example: summary)").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.analysisType !== undefined) args.analysis_type = cmdOpts.analysisType;
		if (cmdOpts.outputFormat !== undefined) args.output_format = cmdOpts.outputFormat;
		const call = proxy.analyze(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.analyze(step: \"value\", step_number: 1, total_steps: 1, n, ...)").addHelpText("afterAll", () => "\n" + "// optional (12): files_checked, relevant_files, relevant_context, issues_found, use_assistant_model, ..." + "\n");
program.command("refactor").summary("refactor --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Analyzes code for refactoring opportunities with systematic investigation. Use for code smell detection, decomposition planning, modernization, and maintainability improvements. Guides through structured analysis with expert validation.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "The refactoring plan. Step 1: State strategy. Later steps: Report findings. CRITICAL: Examine code for smells, and opportunities for decomposition, modernization, and organization. Use 'relevant_files' for code. FORBIDDEN: Large code snippets.").requiredOption("--step-number <step-number:number>", "The index of the current step in the refactoring investigation sequence, beginning at 1. Each step should build upon or revise the previous one. (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Your current estimate for how many steps will be needed to complete the refactoring investigation. Adjust as new opportunities emerge. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "Set to true if you plan to continue the investigation with another step. False means you believe the refactoring analysis is complete and ready for expert validation. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Summary of discoveries from this step, including code smells and opportunities for decomposition, modernization, or organization. Document both strengths and weaknesses. In later steps, confirm or update past findings.").option("--files-checked <files-checked:value1,value2>", "List all files examined (absolute paths). Include even ruled-out files to track exploration path. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Subset of files_checked with code requiring refactoring (absolute paths). Include files with code smells, decomposition needs, or improvement opportunities. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Refactoring opportunities as dictionaries with 'severity' (critical/high/medium/low), 'type' (codesmells/decompose/modernize/organization), and 'description'. Include all improvement opportunities found. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|incomplete|partial|complete>", "Your confidence in refactoring analysis: exploring (starting), incomplete (significant work remaining), partial (some opportunities found, more analysis needed), complete (comprehensive analysis finished, all major opportunities identified). WARNING: Use 'complete' ONLY when fully analyzed and can provide recommendations without expert help. 'complete' PREVENTS expert validation. Use 'partial' for large files or uncertain analysis. (choices: exploring, incomplete, partial, complete; default: incomplete; example: exploring)").option("--hypothesis <hypothesis>", "Current theory about issue/goal based on work").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional list of absolute paths to architecture diagrams, UI mockups, design documents, or visual references that help with refactoring context. Only include if they materially assist understanding or assessment. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").option("--refactor-type <refactor-type:codesmells|decompose|modernize|organization>", "Type of refactoring analysis to perform (codesmells, decompose, modernize, organization) (choices: codesmells, decompose, modernize, organization; default: codesmells; example: codesmells)").option("--focus-areas <focus-areas:value1,value2>", "Specific areas to focus on (e.g., 'performance', 'readability', 'maintainability', 'security') (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--style-guide-examples <style-guide-examples:value1,value2>", "Optional existing code files to use as style/pattern reference (must be FULL absolute paths to real files / folders - DO NOT SHORTEN). These files represent the target coding style and patterns for the project. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.hypothesis !== undefined) args.hypothesis = cmdOpts.hypothesis;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.refactorType !== undefined) args.refactor_type = cmdOpts.refactorType;
		if (cmdOpts.focusAreas !== undefined) args.focus_areas = cmdOpts.focusAreas;
		if (cmdOpts.styleGuideExamples !== undefined) args.style_guide_examples = cmdOpts.styleGuideExamples;
		const call = proxy.refactor(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.refactor(step: \"value\", step_number: 1, total_steps: 1, ...)").addHelpText("afterAll", () => "\n" + "// optional (14): files_checked, relevant_files, relevant_context, issues_found, confidence, ..." + "\n");
program.command("tracer").summary("tracer --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> --trace-mode <trace-mode:precision|dependencies|ask> --target-description <target-description> [--raw <json>]").description("Performs systematic code tracing with modes for execution flow or dependency mapping. Use for method execution analysis, call chain tracing, dependency mapping, and architectural understanding. Supports precision mode (execution flow) and dependencies mode (structural relationships).").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> --trace-mode <trace-mode:precision|dependencies|ask> --target-description <target-description> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Current work step content and findings from your overall work").requiredOption("--step-number <step-number:number>", "Current step number in work sequence (starts at 1) (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Estimated total steps needed to complete work (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "Whether another work step is needed. When false, aim to reduce total_steps to match step_number to avoid mismatch. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Important findings, evidence and insights discovered in this step").option("--files-checked <files-checked:value1,value2>", "List of files examined during this work step (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Files identified as relevant to issue/goal (FULL absolute paths to real files/folders - DO NOT SHORTEN) (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "Confidence level: exploring (just starting), low (early investigation), medium (some evidence), high (strong evidence), very_high (comprehensive understanding), almost_certain (near complete confidence), certain (100% confidence locally - no external validation needed) (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional paths to architecture diagrams or flow charts that help understand the tracing context. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").requiredOption("--trace-mode <trace-mode:precision|dependencies|ask>", "Type of tracing: 'ask' (default - prompts user to choose mode), 'precision' (execution flow) or 'dependencies' (structural relationships) (choices: precision, dependencies, ask; example: precision)").requiredOption("--target-description <target-description>", "Description of what to trace and WHY. Include context about what you're trying to understand or analyze.").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.traceMode !== undefined) args.trace_mode = cmdOpts.traceMode;
		if (cmdOpts.targetDescription !== undefined) args.target_description = cmdOpts.targetDescription;
		const call = proxy.tracer(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.tracer(step: \"value\", step_number: 1, total_steps: 1, ne, ...)").addHelpText("afterAll", () => "\n" + "// optional (7): files_checked, relevant_files, relevant_context, confidence, use_assistant_model, ..." + "\n");
program.command("testgen").summary("testgen --step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").description("Creates comprehensive test suites with edge case coverage for specific functions, classes, or modules. Analyzes code paths, identifies failure modes, and generates framework-specific tests. Be specific about scope - target particular components rather than testing everything.").usage("--step <step> --step-number <step-number:number> --total-steps <total-steps:number> --next-step-required <next-step-required:true|false> --findings <findings> --model <model> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--step <step>", "Test plan for this step. Step 1: outline how you'll analyse structure, business logic, critical paths, and edge cases. Later steps: record findings and new scenarios as they emerge.").requiredOption("--step-number <step-number:number>", "Current test-generation step (starts at 1)  each step should build on prior work. (example: 1)", (value) => parseFloat(value)).requiredOption("--total-steps <total-steps:number>", "Estimated number of steps needed for test planning; adjust as new scenarios appear. (example: 1)", (value) => parseFloat(value)).requiredOption("--next-step-required <next-step-required:true|false>", "True while more investigation or planning remains; set False when test planning is ready for expert validation. (example: true)", (value) => value !== "false").requiredOption("--findings <findings>", "Summarise functionality, critical paths, edge cases, boundary conditions, error handling, and existing test patterns. Cover both happy and failure paths.").option("--files-checked <files-checked:value1,value2>", "Absolute paths of every file examined, including those ruled out. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-files <relevant-files:value1,value2>", "Absolute paths of code that requires new or updated tests (implementation, dependencies, existing test fixtures). (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--relevant-context <relevant-context:value1,value2>", "Methods/functions identified as involved in the issue (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--issues-found <issues-found:value1,value2>", "Issues identified with severity levels during work (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).option("--confidence <confidence:exploring|low|medium|high|very_high|almost_certain|certain>", "Indicate your current confidence in the test generation assessment. Use: 'exploring' (starting analysis), 'low' (early investigation), 'medium' (some patterns identified), 'high' (strong understanding), 'very_high' (very strong understanding), 'almost_certain' (nearly complete test plan), 'certain' (100% confidence - test plan is thoroughly complete and all test scenarios are identified with no need for external model validation). Do NOT use 'certain' unless the test generation analysis is comprehensively complete, use 'very_high' or 'almost_certain' instead if not 100% sure. Using 'certain' means you have complete confidence locally and prevents external model validation. (choices: exploring, low, medium, high, very_high, almost_certain, certain; example: exploring)").option("--hypothesis <hypothesis>", "Current theory about issue/goal based on work").option("--use-assistant-model <use-assistant-model:true|false>", "Use assistant model for expert analysis after workflow steps. False skips expert analysis, relies solely on your personal investigation. Defaults to True for comprehensive validation. (default: true; example: true)", (value) => value !== "false").option("--temperature <temperature:number>", "0 = deterministic  1 = creative. (example: 1)", (value) => parseFloat(value)).option("--thinking-mode <thinking-mode:minimal|low|medium|high|max>", "Reasoning depth: minimal, low, medium, high, or max. (choices: minimal, low, medium, high, max; example: minimal)").option("--continuation-id <continuation-id>", "Unique thread continuation ID for multi-turn conversations. Works across different tools. ALWAYS reuse the last continuation_id you were giventhis preserves full conversation context, files, and findings so the agent can resume seamlessly. (example: example-id)").option("--images <images:value1,value2>", "Optional absolute paths to diagrams or visuals that clarify the system under test. (example: value1,value2)", (value) => value.split(",").map((v) => v.trim())).requiredOption("--model <model>", "Currently in auto model selection mode. CRITICAL: When the user names a model, you MUST use that exact name unless the server rejects it. If no model is provided, you may use the `listmodels` tool to review options and select an appropriate match. Top models: gpt-5.2 (score 100, 400K ctx, thinking, code-gen); gpt-5.1-codex (score 100, 400K ctx, thinking, code-gen); gpt-5.2-pro (score 100, 400K ctx, thinking, code-gen); gpt-5-codex (score 95, 400K ctx, thinking); gpt-5.1-codex-mini (score 90, 400K ctx, thinking, code-gen); +8 more via `listmodels`.").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.step !== undefined) args.step = cmdOpts.step;
		if (cmdOpts.stepNumber !== undefined) args.step_number = cmdOpts.stepNumber;
		if (cmdOpts.totalSteps !== undefined) args.total_steps = cmdOpts.totalSteps;
		if (cmdOpts.nextStepRequired !== undefined) args.next_step_required = cmdOpts.nextStepRequired;
		if (cmdOpts.findings !== undefined) args.findings = cmdOpts.findings;
		if (cmdOpts.filesChecked !== undefined) args.files_checked = cmdOpts.filesChecked;
		if (cmdOpts.relevantFiles !== undefined) args.relevant_files = cmdOpts.relevantFiles;
		if (cmdOpts.relevantContext !== undefined) args.relevant_context = cmdOpts.relevantContext;
		if (cmdOpts.issuesFound !== undefined) args.issues_found = cmdOpts.issuesFound;
		if (cmdOpts.confidence !== undefined) args.confidence = cmdOpts.confidence;
		if (cmdOpts.hypothesis !== undefined) args.hypothesis = cmdOpts.hypothesis;
		if (cmdOpts.useAssistantModel !== undefined) args.use_assistant_model = cmdOpts.useAssistantModel;
		if (cmdOpts.temperature !== undefined) args.temperature = cmdOpts.temperature;
		if (cmdOpts.thinkingMode !== undefined) args.thinking_mode = cmdOpts.thinkingMode;
		if (cmdOpts.continuationId !== undefined) args.continuation_id = cmdOpts.continuationId;
		if (cmdOpts.images !== undefined) args.images = cmdOpts.images;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		const call = proxy.testgen(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.testgen(step: \"value\", step_number: 1, total_steps: 1, n, ...)").addHelpText("afterAll", () => "\n" + "// optional (11): files_checked, relevant_files, relevant_context, issues_found, confidence, ..." + "\n");
program.command("challenge").summary("challenge --prompt <prompt> [--raw <json>]").description("Prevents reflexive agreement by forcing critical thinking and reasoned analysis when a statement is challenged. Trigger automatically when a user critically questions, disagrees or appears to push back on earlier answers, and use it manually to sanity-check contentious claims.").usage("--prompt <prompt> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--prompt <prompt>", "Statement to scrutinize. If you invoke `challenge` manually, strip the word 'challenge' and pass just the statement. Automatic invocations send the full user message as-is; do not modify it.").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.prompt !== undefined) args.prompt = cmdOpts.prompt;
		const call = proxy.challenge(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.challenge(prompt: \"value\")");
program.command("apilookup").summary("apilookup --prompt <prompt> [--raw <json>]").description("Use this tool automatically when you need current API/SDK documentation, latest version info, breaking changes, deprecations, migration guides, or official release notes. This tool searches authoritative sources (official docs, GitHub, package registries) to ensure up-to-date accuracy.").usage("--prompt <prompt> [--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").requiredOption("--prompt <prompt>", "The API, SDK, library, framework, or technology you need current documentation, version info, breaking changes, or migration guidance for.").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		if (cmdOpts.prompt !== undefined) args.prompt = cmdOpts.prompt;
		const call = proxy.apilookup(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.apilookup(prompt: \"value\")");
program.command("listmodels").summary("listmodels [--raw <json>]").description("Shows which AI model providers are configured, available model names, their aliases and capabilities.").usage("[--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		const call = proxy.listmodels(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.listmodels()");
program.command("version").summary("version [--raw <json>]").description("Get server version, configuration details, and list of available tools.").usage("[--raw <json>]").option("--raw <json>", "Provide raw JSON arguments to the tool, bypassing flag parsing.").action(async (cmdOpts) => {
	const globalOptions = program.opts();
	const runtime = await ensureRuntime();
	const serverName = embeddedName;
	const proxy = createServerProxy(runtime, serverName, { initialSchemas: embeddedSchemas });
	try {
		const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : {};
		const call = proxy.version(args);
		const result = await invokeWithTimeout(call, globalOptions.timeout || 12e4);
		printResult(result, globalOptions.output ?? "text");
	} finally {
		await runtime.close(serverName).catch(() => {});
	}
}).addHelpText("after", () => "\nExample:\n  " + "mcporter call pal.version()");
program.command("__mcporter_inspect", { hidden: true }).description("Internal metadata printer for mcporter inspect-cli.").action(() => {
	const payload = buildMetadataPayload();
	console.log(JSON.stringify(payload, null, 2));
});
configureToolCommandHelps();
const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === "0" || FORCE_COLOR === "false";
const forceEnableColor = FORCE_COLOR === "1" || FORCE_COLOR === "true" || FORCE_COLOR === "2" || FORCE_COLOR === "3";
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || !forceDisableColor && Boolean(stdoutStream?.isTTY));
const tint = {
	bold(text) {
		return supportsAnsiColor ? "\x1B[1m" + text + "\x1B[0m" : text;
	},
	dim(text) {
		return supportsAnsiColor ? "\x1B[90m" + text + "\x1B[0m" : text;
	},
	extraDim(text) {
		return supportsAnsiColor ? "\x1B[38;5;244m" + text + "\x1B[0m" : text;
	}
};
function configureGeneratedCommandHelp(command) {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + " " + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? "";
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? "";
			return supportsAnsiColor ? tint.extraDim(description) : description;
		}
	});
}
function configureToolCommandHelps() {
	program.commands.forEach((cmd) => {
		if (cmd.name() === "__mcporter_inspect") {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}
function renderStandaloneHelp() {
	const colorfulTitle = tint.bold(embeddedName) + " " + tint.dim(" " + embeddedDescription);
	const plainTitle = embeddedName + "  " + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [
		title,
		"",
		"Usage: " + embeddedName + " <command> [options]",
		""
	];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push("", formatGlobalFlags(), "", formatQuickStart());
	if (generatorInfo) {
		lines.push("", tint.extraDim(generatorInfo));
	}
	return lines.join("\n");
}
program.helpInformation = () => renderStandaloneHelp();
function formatEmbeddedTools() {
	const header = supportsAnsiColor ? tint.bold("Embedded tools") : "Embedded tools";
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description ? supportsAnsiColor ? tint.extraDim(entry.description) : entry.description : undefined;
		const base = renderedDesc ? entry.name + " - " + renderedDesc : entry.name;
		lines.push("  " + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push("    " + renderedFlags);
		}
		lines.push("");
	});
	if (lines[lines.length - 1] === "") {
		lines.pop();
	}
	return lines.join("\n");
}
function formatGlobalFlags() {
	const header = supportsAnsiColor ? tint.bold("Global flags") : "Global flags";
	const entries = [["-t, --timeout <ms>", "Call timeout in milliseconds"], ["-o, --output <format>", "text | markdown | json | raw (default text)"]];
	const formatted = entries.map(([flag, summary]) => "  " + flag.padEnd(28) + summary);
	return [header, ...formatted].join("\n");
}
function formatQuickStart() {
	const header = supportsAnsiColor ? tint.bold("Quick start") : "Quick start";
	const examples = quickStartExamples();
	if (!examples.length) {
		return header;
	}
	const formatted = examples.map(([cmd, note]) => "  " + cmd + "\n    " + tint.dim("# " + note));
	return [header, ...formatted].join("\n");
}
function quickStartExamples() {
	const examples = [];
	const commandMap = new Map();
	program.commands.forEach((cmd) => {
		const name = cmd.name();
		if (name !== "__mcporter_inspect") {
			commandMap.set(name, name);
		}
	});
	const embedded = Array.isArray(generatorTools) ? generatorTools : [];
	for (const entry of embedded.slice(0, 3)) {
		const commandName = commandMap.get(entry.name) ?? entry.name;
		const flags = entry.flags ? " " + entry.flags.replace(/<[^>]+>/g, "<value>") : "";
		examples.push([embeddedName + " " + commandName + flags, "invoke " + commandName]);
	}
	if (!examples.length) {
		examples.push([embeddedName + " <tool> --key value", "invoke a tool with flags"]);
	}
	return examples;
}
function printResult(result, format$2) {
	const wrapped = createCallResult(result);
	switch (format$2) {
		case "json": {
			const json$2 = wrapped.json();
			if (json$2) {
				console.log(JSON.stringify(json$2, null, 2));
				return;
			}
			break;
		}
		case "markdown": {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case "raw": {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}
function normalizeEmbeddedServer(server) {
	const base = { ...server };
	if (server.command.kind === "http") {
		const urlRaw = server.command.url;
		const urlValue = typeof urlRaw === "string" ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...server.command,
				url: new URL(urlValue)
			}
		};
	}
	if (server.command.kind === "stdio") {
		return {
			...base,
			command: {
				...server.command,
				args: [...server.command.args ?? []]
			}
		};
	}
	return base;
}
function determineArtifactKind() {
	const scriptPath = typeof process !== "undefined" && Array.isArray(process.argv) ? process.argv[1] ?? "" : "";
	if (scriptPath.endsWith(".ts")) {
		return "template";
	}
	if (scriptPath.endsWith(".js")) {
		return "bundle";
	}
	return "binary";
}
function resolveArtifactPath() {
	if (typeof process !== "undefined" && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}
function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path$12 = resolveArtifactPath();
	if (artifactKind === "template" && path$12) {
		invocation.outputPath = invocation.outputPath ?? path$12;
	} else if (artifactKind === "bundle" && path$12) {
		invocation.bundle = invocation.bundle ?? path$12;
	} else if (artifactKind === "binary" && path$12) {
		invocation.compile = invocation.compile ?? path$12;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path: path$12,
			kind: artifactKind
		},
		invocation
	};
}
async function ensureRuntime() {
	return await createRuntime({ servers: [normalizeEmbeddedServer(embeddedServer)] });
}
async function invokeWithTimeout(call, timeout) {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer;
	try {
		return await Promise.race([call, new Promise((_, reject) => {
			timer = setTimeout(() => {
				reject(new Error("Call timed out after " + timeout + "ms."));
			}, timeout);
		})]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}
async function runCli() {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}
if (process.env.MCPORTER_DISABLE_AUTORUN !== "1") {
	runCli().catch((error$47) => {
		const message = error$47 instanceof Error ? error$47.message : String(error$47);
		console.error(message);
		process.exit(1);
	});
}

//#endregion