#!/usr/bin/env python3
import json
import os
import re
import shlex
import sys


def _die(msg: str) -> None:
    print(f"pal-mcporter: {msg}", file=sys.stderr)
    raise SystemExit(2)


def _read_json(path: str | None) -> dict:
    if path:
        with open(path) as f:
            return json.load(f)
    return json.load(sys.stdin)


def _placeholder(opt: dict) -> str:
    # Deprecated for command rendering (kept for backwards compatibility).
    ph = opt.get("placeholder") or "<value>"
    return ph


def _format_flag_value(value: object) -> str:
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return str(value)
    if value is None:
        return "null"
    return shlex.quote(str(value))


def _render_examples(tool: dict, pal_script_path: str) -> str:
    name = tool.get("name") or ""
    desc = (tool.get("description") or "").strip().splitlines()[0]
    options = tool.get("options") or []
    required = [o for o in options if o.get("required")]
    props = {o.get("property") for o in options if o.get("property")}

    uses_raw = any((o.get("type") in {"array", "object"}) for o in required)

    parts: list[str] = [
        "bash",
        shlex.quote(pal_script_path),
        "-o",
        "markdown",
        shlex.quote(name),
    ]

    if uses_raw:
        args: dict[str, object] = {}
        for opt in required:
            prop = opt.get("property") or opt.get("cliName")
            if not prop:
                continue
            args[prop] = _default_for_option(name, opt)
        parts.extend(["--raw", shlex.quote(json.dumps(args, separators=(",", ":")))])
    else:
        for opt in required:
            cli = opt.get("cliName") or opt.get("property")
            prop = opt.get("property") or cli
            if not cli or not prop:
                continue
            parts.append(f"--{cli}")
            parts.append(_format_flag_value(_default_for_option(name, opt)))

    lines = [f"# {name} â€” {desc}", " ".join(parts)]
    lines.append("# Tip: pass optional params via: --raw '{...}' (the generated CLI only flags required params)")
    if "continuation_id" in props:
        lines.append(
            "# Tip: continuation_id works only while the same PAL server stays running (ad-hoc stdio calls restart the server)"
        )
    if "absolute_file_paths" in props:
        lines.append("# Tip: prefer absolute_file_paths=[...] over pasting large code blocks")
    if "images" in props:
        lines.append("# Tip: images=[/abs/path.png,...] or base64 strings")
    if "model" in props:
        lines.append(
            f"# Tip: override model=<name> (see: bash {shlex.quote(pal_script_path)} -o json listmodels)"
        )
    if "thinking_mode" in props:
        lines.append("# Tip: thinking_mode=minimal|low|medium|high|max")
    if "temperature" in props:
        lines.append("# Tip: temperature=0..1")

    return "\n".join(lines)


def cmd_examples(schema_path: str | None, pal_script_path: str) -> None:
    data = _read_json(schema_path)
    tools = data.get("tools", [])
    print("# PAL tool examples (generated)")
    print(f"# Generated by: bash {shlex.quote(pal_script_path)} examples")
    print("")
    for tool in tools:
        print(_render_examples(tool, pal_script_path))
        print("")


def cmd_disable_candidate(schema_path: str) -> None:
    data = _read_json(schema_path)
    for tool in data.get("tools", []):
        name = tool.get("name")
        if name and name not in {"version", "listmodels"}:
            print(name)
            return


def _default_for_option(tool_name: str, opt: dict) -> object:
    prop = opt.get("property") or opt.get("cliName") or "value"
    typ = opt.get("type")

    if prop == "working_directory_absolute_path":
        return os.environ.get("PWD", "/")

    if prop == "model":
        m = os.environ.get("PAL_SELFTEST_MODEL", "").strip()
        if m:
            return m
        m = os.environ.get("PAL_DEFAULT_MODEL", "").strip()
        if m:
            return m
        return "auto"

    if prop in {"step_number", "total_steps"}:
        return 1
    if prop == "next_step_required":
        return False

    if prop == "num_files_documented":
        return 0
    if prop == "total_files_to_document":
        return 1

    if prop == "trace_mode":
        return "precision"
    if prop == "target_description":
        return "selftest"

    if prop == "cli_name":
        cli = os.environ.get("PAL_SELFTEST_CLI_NAME", "").strip()
        if cli:
            return cli
        ph = opt.get("placeholder") or ""
        m = re.match(r"^<[^:]+:([^>]+)>$", ph)
        if m:
            return m.group(1).split("|")[0]
        return "codex"

    if prop == "prompt":
        if tool_name == "clink":
            return "Connectivity check. Reply with exactly: OK. Do not run any shell commands."
        return f"selftest: {tool_name}"
    if prop == "step":
        return f"selftest: {tool_name}"
    if prop == "findings":
        return "selftest"

    if typ == "boolean":
        return False
    if typ in {"number", "integer"}:
        return 1
    if typ == "array":
        return []
    if typ == "object":
        return {}

    return "selftest"


def _cli_flag_value(value: object) -> str:
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return str(value)
    if value is None:
        return "null"
    return str(value)


def cmd_selftest_spec(schema_path: str) -> None:
    data = _read_json(schema_path)
    tools = data.get("tools", [])

    for tool in tools:
        name = tool.get("name")
        if not name:
            continue
        if name in {"version", "listmodels", "chat"}:
            continue

        schema_props = ((tool.get("inputSchema") or {}).get("properties") or {})
        opts = tool.get("options") or []
        required = [o for o in opts if o.get("required")]

        args: dict[str, object] = {}
        for o in required:
            prop = o.get("property") or o.get("cliName")
            if not prop:
                continue
            val = _default_for_option(name, o)
            minv = (schema_props.get(prop) or {}).get("minimum")
            if minv is not None and isinstance(val, (int, float)) and not isinstance(val, bool):
                if val < minv:
                    val = int(minv) if isinstance(minv, int) else float(minv)
            args[prop] = val

        for o in opts:
            prop = o.get("property")
            if prop == "temperature":
                args[prop] = 0
            elif prop == "thinking_mode":
                args[prop] = os.environ.get("PAL_SELFTEST_THINKING_MODE", "minimal")
            elif name == "clink" and prop == "role":
                args[prop] = "planner"
            elif prop == "model":
                m = os.environ.get("PAL_SELFTEST_MODEL", "").strip()
                if m:
                    args[prop] = m

        if name == "consensus" and "models" not in args:
            m = (
                os.environ.get("PAL_SELFTEST_MODEL", "").strip()
                or os.environ.get("PAL_DEFAULT_MODEL", "").strip()
                or "gpt-5.2-pro"
            )
            args["models"] = [{"model": m, "stance": "for"}, {"model": m, "stance": "against"}]
            args["total_steps"] = max(int(args.get("total_steps", 1)), len(args["models"]) + 1)
            args["next_step_required"] = True

        file_path = os.environ.get("PAL_SELFTEST_FILE_PATH", "").strip()
        if file_path:
            if "relevant_files" in schema_props and "relevant_files" not in args:
                args["relevant_files"] = [file_path]
            if "absolute_file_paths" in schema_props and "absolute_file_paths" not in args:
                args["absolute_file_paths"] = [file_path]

        if name == "precommit":
            repo_path = os.environ.get("PAL_SELFTEST_REPO_PATH", "").strip() or os.environ.get(
                "PWD", "/"
            )
            args["path"] = repo_path
            if "include_staged" in schema_props and "include_staged" not in args:
                args["include_staged"] = True

        if name == "clink" and not os.environ.get("PAL_SELFTEST_CLI_NAME", "").strip():
            continue

        flags: list[str] = []
        for o in required:
            cli = o.get("cliName") or o.get("property")
            prop = o.get("property") or o.get("cliName")
            if not cli or not prop:
                continue
            flags.append(f"--{cli}")
            flags.append(_cli_flag_value(args.get(prop)))

        print(json.dumps({"tool": name, "flags": flags, "raw": args}, separators=(",", ":")))


def main(argv: list[str]) -> int:
    if len(argv) < 2:
        _die("usage: pal_tools.py <examples|disable-candidate|selftest-spec> ...")

    cmd = argv[1]
    if cmd == "examples":
        if len(argv) != 3:
            _die("usage: pal_tools.py examples <pal_script_path>")
        cmd_examples(None, argv[2])
        return 0
    if cmd == "examples-from":
        if len(argv) != 4:
            _die("usage: pal_tools.py examples-from <schema_json_path> <pal_script_path>")
        cmd_examples(argv[2], argv[3])
        return 0
    if cmd == "disable-candidate":
        if len(argv) != 3:
            _die("usage: pal_tools.py disable-candidate <schema_json_path>")
        cmd_disable_candidate(argv[2])
        return 0
    if cmd == "selftest-spec":
        if len(argv) != 3:
            _die("usage: pal_tools.py selftest-spec <schema_json_path>")
        cmd_selftest_spec(argv[2])
        return 0

    _die(f"unknown command: {cmd}")


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
