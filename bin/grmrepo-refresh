#!/usr/bin/env zsh
# Refresh the GRM (git-repo-manager) config based on local canonical clones.
#
# This intentionally tracks canonical clones, not standard git worktrees.
# A canonical clone has a `.git/` directory (worktrees have a `.git` file).

set -euo pipefail
unsetopt xtrace 2>/dev/null || true
set +x 2>/dev/null || true

config_path="${GRMREPO_CONFIG:-$HOME/.config/grm/config.toml}"
github_root="${GHPATH:-$HOME/code/github.com}"
code_root="${github_root%/github.com}"
if [[ "$code_root" == "$github_root" ]]; then
  code_root="$HOME/code"
fi

github_root_tilde="${github_root/#$HOME/~}"
code_root_tilde="${code_root/#$HOME/~}"

tmp="$(mktemp "${TMPDIR:-/tmp}/grmrepo-config.XXXXXX")"
trap 'rm -f "$tmp"' EXIT

_remote_type() {
  local url="$1"
  if [[ "$url" == http://* || "$url" == https://* ]]; then
    echo "https"
  else
    echo "ssh"
  fi
}

_write_repo_block() {
  local repo_name="$1"
  local repo_dir="$2"

  print -r -- "[[trees.repos]]"
  print -r -- "name = \"${repo_name}\""
  print -r -- "worktree_setup = false"
  print -r -- ""

  local -a remotes
  remotes=("${(@f)$(git -C "$repo_dir" remote 2>/dev/null || true)}")
  remotes=("${(@o)remotes}")

  local remote_name remote_url remote_type
  for remote_name in "${remotes[@]}"; do
    remote_url="$(git -C "$repo_dir" remote get-url "$remote_name" 2>/dev/null || true)"
    [[ -n "$remote_url" ]] || continue

    # Skip unsupported protocols (e.g. local filesystem remotes like /Users/me/repo).
    if [[ "$remote_url" != http://* && "$remote_url" != https://* && "$remote_url" != *:* && "$remote_url" != ssh://* ]]; then
      continue
    fi

    remote_type="$(_remote_type "$remote_url")"

    print -r -- "[[trees.repos.remotes]]"
    print -r -- "name = \"${remote_name}\""
    print -r -- "url = \"${remote_url}\""
    print -r -- "type = \"${remote_type}\""
    print -r -- ""
  done
}

typeset -a code_repo_dirs
code_repo_dirs=()
for d in "$code_root/openai" "$code_root/chronosphere-openai"; do
  [[ -d "$d/.git" ]] || continue
  code_repo_dirs+=("$d")
done
code_repo_dirs=("${(@o)${(@u)code_repo_dirs}}")

{
  print -r -- "# Generated by grmrepo-refresh"
  print -r -- "# Canonical clone roots:"
  print -r -- "#   - ~/code/github.com/<owner>/<repo>"
  print -r -- "# Exceptions:"
  print -r -- "#   - github.com/openai/openai -> ~/code/openai"
  print -r -- "#   - github.com/chronosphereio/chronosphere-openai -> ~/code/chronosphere-openai"
  print -r -- ""

  # IMPORTANT:
  # GRM splits repo names on the final `/` into (namespace, name), and `repos status`
  # currently uses only `name` when locating the repo path. To keep status working,
  # we emit one tree per namespace (GitHub owner), and keep `name` as just `<repo>`.
  if [[ -d "$github_root" ]]; then
    local owner_dir owner repo_dir repo_name
    for owner_dir in "$github_root"/*(N-/); do
      owner="${owner_dir:t}"

      local -a repos
      repos=()
      for repo_dir in "$owner_dir"/*(N-/); do
        [[ -d "$repo_dir/.git" ]] || continue
        repos+=("$repo_dir")
      done
      (( ${#repos[@]} > 0 )) || continue

      print -r -- "[[trees]]"
      print -r -- "root = \"${github_root_tilde}/${owner}\""
      print -r -- ""

      repos=("${(@o)repos}")
      for repo_dir in "${repos[@]}"; do
        repo_name="${repo_dir:t}"
        _write_repo_block "$repo_name" "$repo_dir"
      done
    done
  fi

  if (( ${#code_repo_dirs[@]} > 0 )); then
    print -r -- "[[trees]]"
    print -r -- "root = \"${code_root_tilde}\""
    print -r -- ""

    for repo_dir in "${code_repo_dirs[@]}"; do
      repo_name="${repo_dir#$code_root/}"
      _write_repo_block "$repo_name" "$repo_dir"
    done
  fi
} > "$tmp"

mkdir -p "$(dirname "$config_path")"
if [[ -f "$config_path" ]] && command -v cmp >/dev/null 2>&1 && cmp -s "$tmp" "$config_path"; then
  exit 0
fi
cat "$tmp" >| "$config_path"

echo "Wrote: $config_path" >&2
